<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="氨基酸小童鞋的博客" href="https://zhihao-a.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="氨基酸小童鞋的博客" href="https://zhihao-a.github.io/atom.xml"><link rel="alternate" type="application/json" title="氨基酸小童鞋的博客" href="https://zhihao-a.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="刷题汇总"><link rel="canonical" href="https://zhihao-a.github.io/2023/12/17/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E5%8F%8A%E9%A2%98%E8%A7%A3%E6%B1%87%E6%80%BB/"><title>算法训练及题解汇总 | 氨基酸小童鞋 = 氨基酸小童鞋的博客 = 氨基酸小童鞋的博客</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">算法训练及题解汇总</h1><div class="meta"><span class="item" title="创建时间：2023-12-17 13:12:33"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-12-17T13:12:33+08:00">2023-12-17</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>199k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>3:01</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">氨基酸小童鞋</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2023/12/17/834185a7da19730b.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2023/12/17/d381655addb17c95.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2023/12/17/003de54d666d08f8.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2023/12/17/241970b90607109d.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2023/12/17/50ba7546276faaee.jpg"></li><li class="item" data-background-image="https://s3.bmp.ovh/imgs/2023/12/17/aef587a6506849f9.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://zhihao-a.github.io/2023/12/17/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E5%8F%8A%E9%A2%98%E8%A7%A3%E6%B1%87%E6%80%BB/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="氨基酸小童鞋"><meta itemprop="description" content="氨基酸小童鞋的博客, 氨基酸小童鞋的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="氨基酸小童鞋的博客"></span><div class="body md" itemprop="articleBody"><h2 id="cowcode题解"><a class="anchor" href="#cowcode题解">#</a> cowcode 题解</h2><h3 id="简单"><a class="anchor" href="#简单">#</a> 简单</h3><h4 id="二叉树前中后续遍历"><a class="anchor" href="#二叉树前中后续遍历">#</a> 二叉树前中后续遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树节点的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    stack&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !nodes.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            nodes.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = nodes.<span class="built_in">top</span>();</span><br><span class="line">            nodes.<span class="built_in">pop</span>();</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    stack&lt;TreeNode*&gt; nodes;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !nodes.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            nodes.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = nodes.<span class="built_in">top</span>();</span><br><span class="line">            nodes.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    stack&lt;TreeNode*&gt; nodes;</span><br><span class="line">    TreeNode* lastVisited = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> || !nodes.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            nodes.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode* topNode = nodes.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (topNode-&gt;right != <span class="literal">NULL</span> &amp;&amp; topNode-&gt;right != lastVisited) &#123;</span><br><span class="line">                root = topNode-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(topNode-&gt;val);</span><br><span class="line">                lastVisited = topNode;</span><br><span class="line">                nodes.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一棵二叉树</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    root-&gt;left-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preorder = <span class="built_in">preorderTraversal</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Preorder traversal: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : preorder) &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; inorder = <span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Inorder traversal: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : inorder) &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; postorder = <span class="built_in">postorderTraversal</span>(root);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Postorder traversal: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : postorder) &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="nc78-反转链表"><a class="anchor" href="#nc78-反转链表">#</a> NC78 反转链表</h4><p>知识点<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTgw">链表</span></p><p>给定一个单链表的头结点 pHead (该头节点是有值的，比如在下图，它的 val 是 1)，长度为 n，反转该链表后，返回新链表的表头。</p><p>数据范围： 0≤𝑛≤10000≤<em>n</em>≤1000</p><p>要求：空间复杂度 𝑂(1)<em>O</em> (1) ，时间复杂度 𝑂(𝑛)<em>O</em>(<em>n</em>) 。</p><p>如当输入链表 {1,2,3} 时，</p><p>经反转后，原链表变为 {3,2,1}，所以对应的输出为 {3,2,1}。</p><p>以上转换过程如下图所示：</p><p><img data-src="https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249" alt="img"></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;3,2,1&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空链表则输出空                 </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *	int val;</span></span><br><span class="line"><span class="comment"> *	struct ListNode *next;</span></span><br><span class="line"><span class="comment"> *	ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param head ListNode类 </span></span><br><span class="line"><span class="comment">     * @return ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        ListNode * p = head ;</span><br><span class="line">        <span class="keyword">if</span>(!p) <span class="keyword">return</span> p;</span><br><span class="line">        ListNode * q = head-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode * k; </span><br><span class="line">        <span class="comment">// p -&gt; q -&gt; k </span></span><br><span class="line">        <span class="comment">// 每次都是q的next指向p</span></span><br><span class="line">        <span class="comment">// 然后p和q都向后移一位，k也随着q的后移，也后移一位</span></span><br><span class="line">        <span class="keyword">while</span>(q)&#123;</span><br><span class="line">            <span class="comment">// 保存下一次的后继，因为q的后继要断开，以防后续节点丢失</span></span><br><span class="line">            k = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = k;</span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="中等"><a class="anchor" href="#中等">#</a> 中等</h3><h4 id="bm7-链表中环的入口结点"><a class="anchor" href="#bm7-链表中环的入口结点">#</a> BM7 链表中环的入口结点</h4><p>知识点<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTgw">链表</span><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTg1">哈希</span><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTA1NA==">双指针</span></p><p>给一个长度为 n 链表，若其中包含环，请找出该链表的环的入口结点，否则，返回 null。</p><p>数据范围： �≤10000<em>n</em>≤10000，1&lt;= 结点值 &lt;=100001&lt;= 结点值 &lt;=10000</p><p>要求：空间复杂度 �(1)<em>O</em> (1)，时间复杂度 �(�)<em>O</em>(<em>n</em>)</p><p>例如，输入 {1,2},{3,4,5} 时，对应的环形链表如下图所示：</p><p><img data-src="https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46" alt="img"></p><p>可以看到环的入口结点的结点值为 3，所以返回结点值为 3 的结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead || !pHead-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">         ListNode *small = pHead-&gt;next;</span><br><span class="line">         ListNode *fast = pHead-&gt;next-&gt;next;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == small)&#123;</span><br><span class="line">                fast = pHead;</span><br><span class="line">                <span class="keyword">while</span>(fast!=small)&#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    small = small-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            small = small-&gt;next;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="nc10-大数乘法"><a class="anchor" href="#nc10-大数乘法">#</a> NC10 <strong>大数乘法</strong></h4><p><strong>描述</strong></p><p>以字符串的形式读入两个数字，编写一个函数计算它们的乘积，以字符串形式返回。</p><p>数据范围： 读入的数字大小满足 0≤n≤1010000≤<em>n</em>≤101000</p><p><strong>示例 1</strong></p><p>输入：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;11&quot;</span><span class="punctuation">,</span><span class="string">&quot;99&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;1089&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">11</span>*<span class="number">99</span>=<span class="number">1089</span> </span><br></pre></td></tr></table></figure><p><strong>示例 2</strong></p><p>输入：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;1&quot;</span><span class="punctuation">,</span><span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure><p><strong>多项式乘法</strong><br>题解思路： 将每个数转换为多项式表示，这样就利用多项式乘法对其求积。<br>分析：<br>1. 一个任意 n 位梳子可以用 n-1 次多项式表示:<br><img data-src="https://uploadfiles.nowcoder.com/images/20210706/809820957_1625553233564/7CFD10161B50FD7E62FFA2CA2E65B4F9" alt="图片说明"></p><p>2. 两个多项式乘法，用 A (x) 和 B (x) 表示两个数：<br><img data-src="https://uploadfiles.nowcoder.com/images/20210706/809820957_1625553270115/8631D8DCBEA4BA2BB48221FFB6ECE299" alt="图片说明"><br>可以看出得到的多项式：a 与 b 的下标之和要等于幂次； 即 c (x):<br><img data-src="https://uploadfiles.nowcoder.com/images/20210706/809820957_1625553289461/1F6DD2D718B859E3CD7E34E72BCE9D35" alt="图片说明"></p><p>其中 m 与 n 分别是两个数的长度。</p><p><strong>复杂度分析：</strong><br>时间复杂度：O (MN); 多项式每一项都要与另一个数的多项式每一项相乘，如上图所示<br>空间复杂度：O (M+N); 最差两个多项式的 x 次方都不相同，需要 M+N 的空间存储对应次方的系数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param s string字符串 第一个整数</span></span><br><span class="line"><span class="comment">     * @param t string字符串 第二个整数</span></span><br><span class="line"><span class="comment">     * @return string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">string <span class="title">solve</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="string">&quot;0&quot;</span> || t ==<span class="string">&quot;0&quot;</span>)  <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">length</span>(),n = t.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(m+n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j= <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> y = t[j] -<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                res[(m-i<span class="number">-1</span>) + (n-j<span class="number">-1</span>)]+=x*y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m+n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            res[i<span class="number">+1</span>] += res[i]/<span class="number">10</span>; <span class="comment">// 向高位进位</span></span><br><span class="line">            res[i] %=<span class="number">10</span>;  <span class="comment">// 自己剩下的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否有最高位,由此来判断最后一位</span></span><br><span class="line">        <span class="comment">// 最多就是（m + n）位 </span></span><br><span class="line">        <span class="type">int</span> index = (res[m+n<span class="number">-1</span>]==<span class="number">0</span>?m+n<span class="number">-2</span>:m+n<span class="number">-1</span>);</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = res[index--];</span><br><span class="line">            result += <span class="built_in">to_string</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="nc108-最大正方形"><a class="anchor" href="#nc108-最大正方形">#</a> NC108 最大正方形</h4><p>知识点<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTkz">动态规划</span></p><p>描述</p><p>给定一个由 ‘0’ 和 ‘1’ 组成的 2 维矩阵，返回该矩阵中最大的由 ‘1’ 组成的正方形的面积。输入的矩阵是字符形式而非数字形式。</p><p 1,0="">数据范围：矩阵的长宽满足 0≤�≤200≤<em>n</em>≤20, 矩阵中的元素属于</p><p>进阶：空间复杂度 �(�2)<em>O</em>(<em>n</em>2) ， 时间复杂度 �(�2)<em>O</em>(<em>n</em>2)</p><p>示例 1</p><p>输入：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[<span class="comment">[1,0,1,0,0]</span>,<span class="comment">[1,0,1,1,1]</span>,<span class="comment">[1,1,1,1,1]</span>,<span class="comment">[1,0,0,1,0]</span>]</span></span><br></pre></td></tr></table></figure><p>复制</p><p>返回值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>复制</p><p>示例 2</p><p>输入：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[1,0,0],[0,0,0],[0,0,0]]</span></span><br></pre></td></tr></table></figure><p>复制</p><p>返回值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 最大正方形</span></span><br><span class="line"><span class="comment">     * @param matrix char字符型vector&lt;vector&lt;&gt;&gt; </span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// dp[i][j] 表示以matrix[i-1][j-1]为右下角的最大正方形的边长</span></span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// 因为当前边长会受到其他三个正方形的限制，因此取最小的</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                result = <span class="built_in">max</span>(result,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result*result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="nc77-调整数组顺序使奇数位于偶数前面一"><a class="anchor" href="#nc77-调整数组顺序使奇数位于偶数前面一">#</a> NC77 调整数组顺序使奇数位于偶数前面 (一)</h4><p>知识点<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTc4">数组</span></p><p>输入一个长度为 n 整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p>数据范围：0≤𝑛≤50000≤<em>n</em>≤5000，数组中每个数的值 0≤𝑣𝑎𝑙≤100000≤<em>v<strong>a</strong>l</em>≤10000</p><p>要求：时间复杂度 𝑂(𝑛)<em>O</em>(<em>n</em>)，空间复杂度 𝑂(𝑛)<em>O</em>(<em>n</em>)</p><p>进阶：时间复杂度 𝑂(𝑛2)<em>O</em>(<em>n</em>2)，空间复杂度 𝑂(1)<em>O</em>(1)</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[1,2,3,4]</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[1,3,2,4]</span></span><br></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[2,4,6,5,7]</span></span><br></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[5,7,2,4,6]</span></span><br></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[1,3,5,6,7]</span></span><br></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[1,3,5,7,6]</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param array int整型vector </span></span><br><span class="line"><span class="comment">     * @return int整型vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 遍历寻找第一个偶数，当找到第一个偶数之后，说明前面都是满足要求的奇数</span></span><br><span class="line">        <span class="comment">// 为了能够保证奇数和偶数的各自的相对位置不发生变化，所以从当前找到的第一个偶数开始</span></span><br><span class="line">        <span class="comment">// 寻找第一个奇数，然后从这个偶数开始到找到的奇数的各个偶数后移一位，然后把找到的奇数</span></span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">int</span> n = array.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// 遍历寻找第一个偶数，当找到第一个偶数之后，说明前面都是满足要求的奇数</span></span><br><span class="line">            <span class="keyword">if</span>(array[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> j = i;</span><br><span class="line">                <span class="comment">// 为了能够保证奇数和偶数的各自的相对位置不发生变化，所以从当前找到的第一个偶数开始</span></span><br><span class="line">               <span class="comment">// 寻找第一个奇数，</span></span><br><span class="line">                <span class="keyword">while</span>(j&lt;n &amp;&amp; array[j]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==n) <span class="keyword">break</span>;</span><br><span class="line">                num = array[j];</span><br><span class="line">                <span class="comment">// 然后从这个偶数开始到找到的奇数的各个偶数后移一位，然后把找到的奇数</span></span><br><span class="line">                <span class="keyword">while</span>(j<span class="number">-1</span>&gt;=i)&#123;</span><br><span class="line">                    array[j] = array[j<span class="number">-1</span>];</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">// 填充在空出的位置上</span></span><br><span class="line">                array[i] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="nc79-丑数"><a class="anchor" href="#nc79-丑数">#</a> NC79 丑数</h4><p>知识点<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTA1MA==">基础数学</span><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTA1OA==">二分</span></p><p>把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含质因子 7。 习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 n 个丑数。</p><p>数据范围：0≤𝑛≤20000≤<em>n</em>≤2000</p><p>要求：空间复杂度 𝑂(𝑛)<em>O</em>(<em>n</em>) ， 时间复杂度 𝑂(𝑛)<em>O</em>(<em>n</em>)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><p><img data-src="https://uploadfiles.nowcoder.com/files/20210620/908787715_1624191012473/33.gif" alt="33"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param index int整型 </span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">// 大致思路就是根据已经出现的“丑数” 2^x3^y5^z</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt;=<span class="number">6</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(index)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i2 = <span class="number">0</span>,i3 = <span class="number">0</span>,i5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;index;i++)&#123;</span><br><span class="line">            res[i] = <span class="built_in">min</span>(res[i2]*<span class="number">2</span>,<span class="built_in">min</span>(res[i3]*<span class="number">3</span>,res[i5]*<span class="number">5</span>));</span><br><span class="line">            <span class="comment">// 记录每一个质因子都乘到那个地方了</span></span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[i2]*<span class="number">2</span>)&#123;</span><br><span class="line">                i2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[i3]*<span class="number">3</span>)&#123;</span><br><span class="line">                i3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[i5]*<span class="number">5</span>)&#123;</span><br><span class="line">                i5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>NC42 有重复项数字的全排列</p><p>知识点<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTkx">递归</span></p><p>给出一组可能包含重复项的数字，返回该组数字的所有排列。结果以字典序升序排列。</p><p>数据范围： 0&lt;𝑛≤80&lt;<em>n</em>≤8 ，数组中的值满足 −1≤𝑣𝑎𝑙≤5−1≤<em>v<strong>a</strong>l</em>≤5</p><p>要求：空间复杂度 𝑂(𝑛!)<em>O</em>(<em>n</em>!)，时间复杂度 𝑂(𝑛!)<em>O</em>(<em>n</em>!)</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,1,2</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[[1,1,2]</span>,<span class="selector-attr">[1,2,1]</span>,<span class="selector-attr">[2,1,1]</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[0,1]</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[0,1],[1,0]]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>具体做法：</strong></p><ul><li>step 1：先对数组按照字典序排序，获取第一个排列情况。</li><li>step 2：准备一个数组暂存递归过程中组装的排列情况。使用额外的 vis 数组用于记录哪些位置的数字被加入了。</li><li>step 3：每次递归从头遍历数组，获取数字加入：首先根据 vis 数组，已经加入的元素不能再次加入了；同时，如果当前的元素 num [i] 与同一层的前一个元素 num [i-1] 相同且 num [i-1] 已经用，也不需要将其纳入。</li><li>step 4：进入下一层递归前将 vis 数组当前位置标记为使用过。</li><li>step 5：回溯的时候需要修改 vis 数组当前位置标记，同时去掉刚刚加入数组的元素，</li><li>step 6：临时数组长度到达原数组长度就是一种排列情况。</li></ul><p><strong>图示：</strong></p><p><img data-src="https://uploadfiles.nowcoder.com/images/20220216/397721558_1645013679697/A5CBD09507C7283E8AC96D5B211D5320" alt="alt"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param num int整型vector</span></span><br><span class="line"><span class="comment">     * @return int整型vector&lt;vector&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; num) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(num.<span class="built_in">begin</span>(), num.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(num.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(vector&lt;<span class="type">int</span>&gt;)&gt; permute = [&amp;](vector&lt;<span class="type">int</span>&gt;temp)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.<span class="built_in">size</span>() == num.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                result.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; num[i<span class="number">-1</span>]==num[i] &amp;&amp; !used[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                temp.<span class="built_in">emplace_back</span>(num[i]);</span><br><span class="line">                <span class="built_in">permute</span>(temp);</span><br><span class="line"></span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">permute</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="困难"><a class="anchor" href="#困难">#</a> 困难</h3><h4 id="nc6-二叉树中的最大路径和"><a class="anchor" href="#nc6-二叉树中的最大路径和">#</a> NC6 二叉树中的最大路径和</h4><p>知识点<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTgz">树</span><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTA1MQ=="> dfs</span></p><p>二叉树里面的路径被定义为：从该树的任意节点出发，经过父 =&gt; 子或者子 =&gt; 父的连接，达到任意节点的序列。</p><p>注意:</p><p>1. 同一个节点在一条二叉树路径里中最多出现一次</p><p>2. 一条路径至少包含一个节点，且不一定经过根节点</p><p>给定一个二叉树的根节点 root，请你计算它的最大路径和</p><p>例如：<br>给出以下的二叉树，<br><img data-src="https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786349381_11531EA9352057ACF47D25928F132E96" alt="img"><br>最优路径是：2=&gt;1=&gt;3，或者 3=&gt;1=&gt;2，最大路径和 = 2+1+3=6</p><p>数据范围：节点数满足 1≤i≤1051≤<em>n</em>≤105 ，节点上的值满足 ∣∣≤1000∣<em>v<strong>a</strong>l</em>∣≤1000</p><p>要求：空间复杂度 �(1)<em>O</em> (1)，时间复杂度 �(�)<em>O</em>(<em>n</em>)</p><p>示例 1</p><p>输入：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="template-variable">&#123;1,2,3&#125;</span></span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>示例</p><p>输入：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">-20</span>,<span class="number">8</span>,<span class="number">20</span>,#,#,<span class="number">15</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">41</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其中一条最大路径为:<span class="number">15</span>=&gt;<span class="number">20</span>=&gt;<span class="number">6</span>，路径和为<span class="number">15</span>+<span class="number">20</span>+<span class="number">6</span>=<span class="number">41</span>   </span><br></pre></td></tr></table></figure><p>示例 3</p><p>输入：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">-2</span>,#,<span class="string">-3</span>&#125;    </span><br><span class="line">返回值</span><br><span class="line"><span class="string">-2</span></span><br></pre></td></tr></table></figure><p>算法思想一：递归</p><p>解题思路：</p><p>首先，考虑实现一个简化的函数 <strong>maxGain</strong> (node)，该函数计算二叉树中的一个节点的最大贡献值，具体而言，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。<br>具体而言，该函数的计算如下。<br>空节点的最大贡献值等于 0。<br>非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和（对于叶节点而言，最大贡献值等于节点值）</p><p>例如二叉树：root = [-10,9,20,null,null,15,7]</p><p>叶节点 9、15、7 的最大贡献值分别为 9、15、7。<br>得到叶节点的最大贡献值之后，再计算非叶节点的最大贡献值。节点 20 的最大贡献值等于 20+max (15,7)=35，节点 -10 的最大贡献值等于 −10+max (9,35)=25。<br>上述计算过程是递归的过程，因此，对根节点调用函数 maxGain，即可得到每个节点的最大贡献值。</p><p>根据函数 maxGain 得到每个节点的最大贡献值之后，如何得到二叉树的最大路径和？对于二叉树中的一个节点，该节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值，如果子节点的最大贡献值为正，则计入该节点的最大路径和，否则不计入该节点的最大路径和。维护一个全局变量 maxSum 存储最大路径和，在递归过程中更新 maxSum 的值，最后得到的 maxSum 的值即为二叉树中的最大路径和。</p><p><strong>图解</strong>：</p><p><img data-src="https://uploadfiles.nowcoder.com/images/20210706/889362376_1625558552657/B673751B8180262E6396E8E78FFA1EAD" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//    </span></span><br><span class="line">   <span class="type">int</span> result = <span class="number">0</span>,result_n=INT_MIN;</span><br><span class="line">   function&lt;<span class="type">int</span>(TreeNode*)&gt;  maxGain = [&amp;](TreeNode* root)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          result_n = <span class="built_in">max</span>(result_n,root-&gt;val);</span><br><span class="line">          <span class="type">int</span> left = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(root-&gt;left),<span class="number">0</span>);</span><br><span class="line">          <span class="type">int</span> right = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(root-&gt;right),<span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">          <span class="type">int</span> price = root-&gt;val + left + right;</span><br><span class="line">          result = <span class="built_in">max</span>(result,price);</span><br><span class="line">          <span class="comment">// 返回当前节点的最大贡献值，也就是左子树和右子树中的较大值加上本身的节点值</span></span><br><span class="line">          <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(left,right);</span><br><span class="line"></span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="built_in">maxGain</span>(root);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果全都是负数，这个result会是0，此时就输出所有节点中，最大的那个</span></span><br><span class="line">    <span class="comment">// result_n 在遍历的时候就记录并维护了每一个节点中最大的那个</span></span><br><span class="line">   <span class="keyword">return</span> result ? result :result_n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nc35-编辑距离二"><a class="anchor" href="#nc35-编辑距离二">#</a> NC35 编辑距离 (二)</h4><p>知识点<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTc5">字符串</span><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTkz">动态规划</span></p><p>描述</p><p>给定两个字符串 str1 和 str2，再给定三个整数 ic，dc 和 rc，分别代表插入、删除和替换一个字符的代价，请输出将 str1 编辑成 str2 的最小代价。</p><p>要求：空间复杂度 O*(<em>n</em>)，时间复杂度 O*(<em>n<strong>l</strong>o<strong>g</strong>n</em>)</p><p>示例 1</p><p>输入：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abc&quot;</span><span class="punctuation">,</span><span class="string">&quot;adc&quot;</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>复制</p><p>返回值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>复制</p><p>示例 2</p><p>输入：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;abc&quot;</span><span class="punctuation">,</span><span class="string">&quot;adc&quot;</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">100</span></span><br></pre></td></tr></table></figure><p>复制</p><p>返回值：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><p>备注：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>≤∣���<span class="number">1</span>∣,∣���<span class="number">2</span>∣≤<span class="number">50001</span>≤∣str1∣,∣str2∣≤<span class="number">5000</span></span><br><span class="line"><span class="attribute">1</span>≤��,��,��≤<span class="number">100001</span>≤ic,dc,rc≤<span class="number">10000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * min edit cost</span></span><br><span class="line"><span class="comment">     * @param str1 string字符串 the string</span></span><br><span class="line"><span class="comment">     * @param str2 string字符串 the string</span></span><br><span class="line"><span class="comment">     * @param ic int整型 insert cost</span></span><br><span class="line"><span class="comment">     * @param dc int整型 delete cost</span></span><br><span class="line"><span class="comment">     * @param rc int整型 replace cost</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minEditCost</span><span class="params">(string str1, string str2, <span class="type">int</span> ic, <span class="type">int</span> dc, <span class="type">int</span> rc)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="comment">// 大致思路： dp[i][j] 表示 str1[0..i] 与 str2[0..j]匹配的话，最少的代价，这样的话可以通过这样来判断当前的代价和之前的代价之间的关系</span></span><br><span class="line">        <span class="comment">// 如果当前最后一位能够匹配 即 str1[i] == str2[j] ,那么当前最小代价就等于dp[i-1][j-1]  </span></span><br><span class="line">        <span class="comment">// 如果当前最后一位不能够匹配的话，那么就有以下几种可能</span></span><br><span class="line">           <span class="comment">// str1[0..i-1] 与 str2[0..j]匹配的最小代价 加上去除最后一位的代价，即 dp[i-1][j] + dc </span></span><br><span class="line">           <span class="comment">// str1[0..i] 与 str2[0..j-1]匹配的最小代价 加上插入最后一位的代价，即 dp[i][j-1] + ic </span></span><br><span class="line">           <span class="comment">// str1[0..i-1] 与 str2[0..j-1]匹配的最小代价 加上替换最后一位的代价，即 dp[i-1][j-1] + rc </span></span><br><span class="line">        <span class="comment">// 然后就是将以上四种可能进行比较，选择最小代价的那个，就是当前dp[i][j] 的最小值</span></span><br><span class="line">        <span class="type">int</span> m = str<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = str<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span> ,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>));</span><br><span class="line">        <span class="comment">// 初始化dp数组 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m<span class="number">+1</span>;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dc*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n<span class="number">+1</span>;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = ic*j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历，然后根据事先制定的策略进行打表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;m<span class="number">+1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;n<span class="number">+1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                     dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + rc;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j] + dc,<span class="built_in">min</span>(dp[i][j<span class="number">-1</span>] + ic,dp[i][j]));</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="nc36-在两个长度相等的排序数组中找到上中位数"><a class="anchor" href="#nc36-在两个长度相等的排序数组中找到上中位数">#</a> NC36 在两个长度相等的排序数组中找到上中位数</h4><p>知识点<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTc4">数组</span><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTA1OA==">二分</span><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL2V4YW0vb2o/cGFnZT0xJmFtcDt0YWI9JUU3JUFFJTk3JUU2JUIzJTk1JUU3JUFGJTg3JmFtcDt0b3BpY0lkPTE5Nj90YWc9NTk0">分治</span></p><p>描述</p><p>给定两个递增数组 arr1 和 arr2，已知两个数组的长度都为 N，求两个数组中所有数的上中位数。</p><p>上中位数：假设递增序列长度为 n，为第 n/2 个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * find median in two sorted array</span></span><br><span class="line"><span class="comment">     * @param arr1 int整型vector the array1</span></span><br><span class="line"><span class="comment">     * @param arr2 int整型vector the array2</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMedianinTwoSortedAray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr1, vector&lt;<span class="type">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> length_arr1 = arr<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> length_arr2 = arr<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum_length = length_arr1 + length_arr2;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; findK = [&amp;](<span class="type">int</span> left1, <span class="type">int</span> right1,</span><br><span class="line">        <span class="type">int</span> left2, <span class="type">int</span> right2, <span class="type">int</span> k)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (left1 &gt; right1) &#123;</span><br><span class="line">                <span class="keyword">return</span> arr2[left2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left2 &gt; right2) &#123;</span><br><span class="line">                <span class="keyword">return</span> arr1[left1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算两个数组区间的中间位置</span></span><br><span class="line">            <span class="type">int</span> mid1 = left1 + (right1 - left1) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> mid2 = left2 + (right2 - left2) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 计算中间之前的数字的个数</span></span><br><span class="line">            <span class="type">int</span> Hlength = mid1 - left1 + mid2 - left2 + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr1[mid1] &lt; arr2[mid2]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Hlength &lt;= k) &#123;</span><br><span class="line">                    <span class="comment">// 此时说明寻找的第k个数，不在前面</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">findK</span>(mid1 + <span class="number">1</span>, right1, left2, right2, k - (mid1 - left1 + <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">findK</span>(left1, right1, left2, mid2 - <span class="number">1</span>, k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Hlength &lt;= k) &#123;</span><br><span class="line">                    <span class="comment">// 此时说明寻找的第k个数，不在前面</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">findK</span>(left1, right1, mid2<span class="number">+1</span>, right2, k - (mid2 - left2 + <span class="number">1</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">findK</span>(left1, mid1<span class="number">-1</span>, left2, right2, k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum_length%<span class="number">2</span>==<span class="number">0</span>?<span class="built_in">findK</span>(<span class="number">0</span>,length_arr1<span class="number">-1</span>,<span class="number">0</span>,length_arr2<span class="number">-1</span>,sum_length/<span class="number">2</span>):<span class="built_in">findK</span>(<span class="number">0</span>,length_arr1<span class="number">-1</span>,<span class="number">0</span>,length_arr2<span class="number">-1</span>,sum_length/<span class="number">2</span><span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>python</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedianSortedArrays</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="comment">#寻找两个有序数组中第K个数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">FindKthElm</span>(<span class="params">A:<span class="built_in">list</span>,A_begin:<span class="built_in">int</span>,A_end:<span class="built_in">int</span>,B:<span class="built_in">list</span>,B_begin:<span class="built_in">int</span>,B_end:<span class="built_in">int</span>,k:<span class="built_in">int</span></span>):</span><br><span class="line">            <span class="comment">#如果一个数组中的开始和结束的索引中间没有元素，就返回另一个数组中的第K个数</span></span><br><span class="line">            <span class="keyword">if</span> A_begin &gt; A_end:</span><br><span class="line">                <span class="keyword">return</span> B[B_begin+k-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> B_begin &gt; B_end:</span><br><span class="line">                <span class="keyword">return</span> A[A_begin+k-<span class="number">1</span>]</span><br><span class="line">            <span class="comment">#先找到两个数组中的中间位置A_mid 和 B_mid</span></span><br><span class="line">            A_mid = A_begin + (A_end - A_begin)//<span class="number">2</span></span><br><span class="line">            B_mid = B_begin + (B_end - B_begin)//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#计算两个有序数组中间位置之前的元素个数，即A_mid 和 B_mid 之前的元素个数之和</span></span><br><span class="line">            halfLen = A_mid - A_begin + B_mid - B_begin + <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> A[A_mid] &lt; B[B_mid]:</span><br><span class="line">                <span class="comment">#如果 A[A_mid] &lt; B[B_begin] 的话</span></span><br><span class="line">                <span class="comment"># 此时 halfLen &gt; k B[B_mid：B_end]不可能存在第K个数</span></span><br><span class="line">                <span class="keyword">if</span> halfLen &gt; k:</span><br><span class="line">                    <span class="keyword">return</span> FindKthElm(A,A_begin,A_end,B,B_begin,B_mid-<span class="number">1</span>,k)</span><br><span class="line">                <span class="comment"># 此时 halfLend &lt;= k 那么 A[A_begin:A_mid]肯定包含在前K个数之中，</span></span><br><span class="line">                <span class="comment"># 所以只用在后面寻找第 k - (A_mid - A_begin + 1) 个就行了</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> FindKthElm(A,A_mid + <span class="number">1</span>,A_end,B,B_begin,B_end,k - (A_mid - A_begin + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果 A[A_mid] &gt; B[B_begin] 的话</span></span><br><span class="line">                <span class="comment"># 此时 halfLen &gt; k A[A_mid：A_end]不可能存在第K个数</span></span><br><span class="line">                <span class="keyword">if</span> halfLen &gt; k:</span><br><span class="line">                    <span class="keyword">return</span> FindKthElm(A, A_begin, A_mid - <span class="number">1</span>, B, B_begin, B_end, k)</span><br><span class="line">                <span class="comment">#此时 halfLend &lt;= k 那么 B[B_begin:B_mid]肯定包含在前K个数之中，</span></span><br><span class="line">                <span class="comment"># 所以只用在后面寻找第 k - (B_mid - B_begin + 1) 个就行了</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> FindKthElm(A, A_begin, A_end, B, B_mid + <span class="number">1</span>, B_end, k - (B_mid - B_begin + <span class="number">1</span>))</span><br><span class="line">        m = <span class="built_in">len</span>(nums1)</span><br><span class="line">        n = <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="keyword">return</span> FindKthElm(nums1,<span class="number">0</span>,m-<span class="number">1</span>,nums2,<span class="number">0</span>,n-<span class="number">1</span>,(m+n)//<span class="number">2</span> + <span class="number">1</span>) <span class="keyword">if</span> (m + n)%<span class="number">2</span>!=<span class="number">0</span> <span class="keyword">else</span> ( FindKthElm(nums1,<span class="number">0</span>,m-<span class="number">1</span>,nums2,<span class="number">0</span>,n-<span class="number">1</span>,(m+n)//<span class="number">2</span>) +  FindKthElm(nums1,<span class="number">0</span>,m-<span class="number">1</span>,nums2,<span class="number">0</span>,n-<span class="number">1</span>,(m+n)//<span class="number">2</span> + <span class="number">1</span>) ) /<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="nc82-滑动窗口的最大值"><a class="anchor" href="#nc82-滑动窗口的最大值">#</a> <strong>NC82</strong> <strong>滑动窗口的最大值</strong></h4><p>给定一个长度为 n 的数组 num 和滑动窗口的大小 size ，找出所有滑动窗口里数值的最大值。</p><p>例如，如果输入数组 {2,3,4,2,6,2,5,1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4,4,6,6,6,5}； 针对数组 {2,3,4,2,6,2,5,1} 的滑动窗口有以下 6 个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p>窗口大于数组长度或窗口长度为 0 的时候，返回空。</p><p>数据范围： 1≤𝑛≤100001≤<em>n</em>≤10000，0≤𝑠𝑖𝑧𝑒≤100000≤<em>s<strong>i</strong>z**e</em>≤10000，数组中每个元素的值满足 ∣𝑣𝑎𝑙∣≤10000∣<em>v<strong>a</strong>l</em>∣≤10000</p><p>要求：空间复杂度 𝑂(𝑛)<em>O</em>(<em>n</em>)，时间复杂度 𝑂(𝑛)<em>O</em>(<em>n</em>)</p><p>方法一种存在很多大量重复计算，比如说，对于数组，假设我们当前遍历到下标 i，对于下标 i+1 的元素（假设 i 和 i+1 都在同一个窗口），如果比 arr [i] 大，说明了什么？<br>如果 arr [i+1] 已经大于了 arr [i], 那么还要 arr [i] 有什么用。就有点 “既生瑜何生亮” 的感觉。<br>如果 arr [i+1] &lt; arr [i] 呢？显然 arr [i] 还是需要保留的。为什么呢？<br>因为又可以 arr [i] 对于下一个 arr [i+1] 所在的窗口来说，arr [i] 已经失效了。</p><p>假设这里有那么一个容器可以保留上述操作。</p><ol><li>遍历数组的每一个元素，</li><li>如果容器为空，则直接将当前元素加入到容器中。</li><li>如果容器不为空，则让当前元素和容器的最后一个元素比较，如果大于，则将容器的最后一个元素删除，然后继续讲当前元素和容器的最后一个元素比较</li><li>如果当前元素小于容器的最后一个元素，则直接将当前元素加入到容器的末尾</li><li>如果容器头部的元素已经不属于当前窗口的边界，则应该将头部元素删除</li></ol><p>总结一下，首先容器中放的元素应该是单调递减的。然后还有删除容器头部元素和最后一个元素的操作。因此，这样的数据结构就是双端队列。c++ 中就是 <code>deque</code></p><p>如何判断队列中头部的元素是否过期呢？<br>这里我们可以存数组的下标，根据下标的比较来判断。比如，当前遍历到下标为 5 的元素，窗口的大小为 3， 显然显然下标为 2 的已经过期了。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxInWindows</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; num, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">       <span class="comment">// 利用双端队列，并且保证队头元素始终为当前窗口内的最大值</span></span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">       <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">0</span> || size == <span class="number">0</span> || size &gt; n)&#123;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line">       deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          <span class="comment">// 弹出当前对于最大值没有任何帮助的值</span></span><br><span class="line">          <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; num[que.<span class="built_in">back</span>()]&lt;num[i])&#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          que.<span class="built_in">push_back</span>(i);</span><br><span class="line">          <span class="comment">// 判断队列头部的元素的下标是否过期，是否已经不属于当前窗口</span></span><br><span class="line">          <span class="keyword">if</span>(que.<span class="built_in">front</span>() + size&lt;=i)&#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(i + <span class="number">1</span> &gt;= size )&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num[que.<span class="built_in">front</span>()]);</span><br><span class="line">          &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O (n), 其中 n 为数组大小<br>空间复杂度：O (k)，k 为窗口的大小</p><h2 id="leetcode题解"><a class="anchor" href="#leetcode题解">#</a> Leetcode 题解</h2><h3 id="简单-2"><a class="anchor" href="#简单-2">#</a> 简单</h3><h4 id="27-移除元素"><a class="anchor" href="#27-移除元素">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZWxlbWVudC8=">27. 移除元素</span></h4><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code> ，你需要 <strong><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEUlOUYlRTUlOUMlQjAlRTclQUUlOTclRTYlQjMlOTU=">原地</span></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEUlOUYlRTUlOUMlQjAlRTclQUUlOTclRTYlQjMlOTU=">原地 </span>修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以 **「引用」** 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">len</span> = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,2,2,3]</span>, val = 3</span><br><span class="line">输出：2, nums = <span class="comment">[2,2]</span></span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = <span class="comment">[2,2,3,3]</span> 或 nums = <span class="comment">[2,2,0,0]</span>，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0,1,2,2</span>,<span class="number">3,0,4,2</span>], val = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">0,1,3,0</span>,<span class="number">4</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;right;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">               <span class="comment">//将这个值交换到后面</span></span><br><span class="line">               <span class="built_in">swap</span>(nums[i] , nums[right<span class="number">-1</span>]);</span><br><span class="line">               right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=val) i++;</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="keyword">return</span> right;    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="303-区域和检索-数组不可变"><a class="anchor" href="#303-区域和检索-数组不可变">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yYW5nZS1zdW0tcXVlcnktaW1tdXRhYmxlLw==">303. 区域和检索 - 数组不可变</span></h4><p>给定一个整数数组 <code>nums</code> ，处理以下类型的多个查询:</p><ol><li>计算索引 <code>left</code> 和 <code>right</code> （包含 <code>left</code> 和 <code>right</code> ）之间的 <code>nums</code> 元素的 <strong>和</strong> ，其中 <code>left &lt;= right</code></li></ol><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和 <code>right</code> 之间的元素的 <strong>总和</strong> ，包含 <code>left</code> 和 <code>right</code> 两点（也就是 <code>nums[left] + nums[left + 1] + ... + nums[right]</code> )</li></ul><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[<span class="string">-2</span>, 0, 3, <span class="string">-5</span>, 2, <span class="string">-1</span>]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, <span class="string">-1</span>, <span class="string">-3</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray = new NumArray([<span class="string">-2</span>, 0, 3, <span class="string">-5</span>, 2, <span class="string">-1</span>]);</span><br><span class="line">numArray.sumRange(0, 2); // return 1 ((<span class="string">-2</span>) + 0 + 3)</span><br><span class="line">numArray.sumRange(2, 5); // return <span class="string">-1</span> (3 + (<span class="string">-5</span>) + 2 + (<span class="string">-1</span>)) </span><br><span class="line">numArray.sumRange(0, 5); // return <span class="string">-3</span> ((<span class="string">-2</span>) + 0 + 3 + (<span class="string">-5</span>) + 2 + (<span class="string">-1</span>))</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li><li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li><li>最多调用 <code>104</code> 次 <code>sumRange</code> 方法</li></ul><p>一般思路：最朴素的想法是存储数组 nums 的值，每次调用 sumRange 时，通过循环的方法计算数组 nums 从下标 i 到下标 j 范围内的元素和， 由于每次检索的时间和检索的下标范围有关，因此检索的时间复杂度较高，如果检索次数较多，则会超出时间限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i= left;i&lt;=right;i++)&#123;</span><br><span class="line">        result += data[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray* obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;sumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>优化方法：因为是查询密集型，所以尽量优化查询，使得查询复杂度为 O (1) , 考虑到使用前缀和，即在初始化的时候，就按照前缀和的方式进行存储，这样在查询的时候就只用将两个前缀和相减就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sums;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        sums.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>] = sums[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j + <span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="26-删除有序数组中的重复项"><a class="anchor" href="#26-删除有序数组中的重复项">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1hcnJheS8=">26. 删除有序数组中的重复项</span></h4><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你 **<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS9pdGVtLyVFNSU4RSU5RiVFNSU5QyVCMCVFNyVBRSU5NyVFNiVCMyU5NQ=="> 原地</span> ** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。 <code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><p><strong>判题标准:</strong></p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums <span class="operator">=</span> [...]<span class="comment">; // 输入数组</span></span><br><span class="line">int[] expectedNums <span class="operator">=</span> [...]<span class="comment">; // 长度正确的期望答案</span></span><br><span class="line"></span><br><span class="line">int k <span class="operator">=</span> removeDuplicates(nums)<span class="comment">; // 调用</span></span><br><span class="line"></span><br><span class="line">assert k <span class="operator">=</span><span class="operator">=</span> expectedNums.length<span class="comment">;</span></span><br><span class="line">for (int i <span class="operator">=</span> <span class="number">0</span><span class="comment">; i &lt; k; i++) &#123;</span></span><br><span class="line">    assert nums[i] <span class="operator">=</span><span class="operator">=</span> expectedNums[i]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,1,2]</span></span><br><span class="line">输出：2, nums = <span class="comment">[1,2,_]</span></span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0,0,1,1</span>,<span class="number">1,2,2,3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">0,1,2,3</span>,<span class="number">4</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">5</span> ， 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li></ul><p>双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span> , right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[left]!=nums[right])&#123;</span><br><span class="line">            nums[left + <span class="number">1</span>] = nums[right];</span><br><span class="line">            left ++;</span><br><span class="line">           &#125;</span><br><span class="line">           right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">removeDuplicates</span>(nums);</span><br><span class="line">    cout &lt;&lt; length &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;n:nums)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="455-分发饼干"><a class="anchor" href="#455-分发饼干">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hc3NpZ24tY29va2llcy8=">455. 分发饼干</span></h4><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code> ，都有一个胃口值 <code>g[i]</code> ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code> ，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code> ，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: g = [1,2,3], s = [1,1]</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: </span></span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: g = [1,2], s = [1,2,3]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br><span class="line"><span class="section">解释: </span></span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul><p>思路：先排序（孩子胃口递增排序，饼干也是从小到大排序），然后按照孩子的胃口从小到大，分饼干，如果此时的这块饼干不能满足当下的这个孩子，因为孩子的胃口是从小到大递增排序的，所以之后的孩子肯定也不能满足，所以就可以跳过不访问了，找到满足这个孩子胃口的饼干之后，移除这个饼干，相当于也是跳过，从下一块饼干开始为下一个孩子选择满足他胃口的饼干，如果某个孩子尝试了剩下的所有饼干都没有满足，那么就不用再继续了，因为按照我们的访问顺序和操作原理，已经没有饼干可以选择了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 优先用小饼干先去试探，如果小饼干不够了再尝试用更大的饼干</span></span><br><span class="line">     <span class="comment">// 先将两个数组进行排序</span></span><br><span class="line">     <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">     <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">     <span class="comment">// 按照孩子的胃口从小到大进行满足，如果一个孩子没被满足，那么</span></span><br><span class="line">     <span class="comment">// 后面的所有孩子就都得不到满足</span></span><br><span class="line">     <span class="type">int</span> n = <span class="number">0</span>; <span class="comment">// 记录被满足的孩子数</span></span><br><span class="line">     <span class="type">int</span> g_length = g.<span class="built_in">size</span>();</span><br><span class="line">     <span class="type">int</span> s_length = s.<span class="built_in">size</span>();</span><br><span class="line">     <span class="comment">// 将排好序的饼干放入栈，从大到小放入（即栈顶的饼干是最小的）</span></span><br><span class="line">     stack&lt;<span class="type">int</span>&gt;  myStack;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=s_length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">          myStack.<span class="built_in">push</span>(s[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> top;</span><br><span class="line">     <span class="keyword">while</span>(n &lt; g_length &amp;&amp; !myStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      </span><br><span class="line">          <span class="keyword">while</span>(!myStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            top = myStack.<span class="built_in">top</span>();</span><br><span class="line">            myStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(top &gt;= g[n])&#123;</span><br><span class="line">                <span class="comment">// 如果这个小孩找到满足自己胃口的饼干了，</span></span><br><span class="line">                <span class="comment">// 那么就继续给下一个小孩找</span></span><br><span class="line">                n++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="121-买卖股票的最佳时机"><a class="anchor" href="#121-买卖股票的最佳时机">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLw==">121. 买卖股票的最佳时机</span></h4><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第<span class="number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="number"> 5 </span>。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = <span class="string">[7,6,4,3,1]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p><strong>遍历</strong>：在遍历的同时维护最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="type">int</span> length = prices.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">if</span>(length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> right = <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(right&lt;length)&#123;</span><br><span class="line">          <span class="keyword">if</span>(right &lt; length &amp;&amp; prices[right] &gt;= prices[left])&#123;</span><br><span class="line">             result = <span class="built_in">max</span>(result,prices[right]-prices[left]);</span><br><span class="line">             right++;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = right;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划</strong>：其中 dp [i] 相当于在此时卖出最多能赚多少，如果找到一个在此时卖出能赔的点，那就在此时重新买进，等待下一个卖点，这个过程中不断维护最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> * dp = <span class="keyword">new</span> <span class="type">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] =<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">                dp[i]  = prices[i]-prices[i<span class="number">-1</span>]+dp[i<span class="number">-1</span>]&lt;<span class="number">0</span> ? <span class="number">0</span>:prices[i]-prices[i<span class="number">-1</span>]+dp[i<span class="number">-1</span>] ;</span><br><span class="line">                result = result&lt;dp[i] ? dp[i] :result;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="705-设计哈希集合"><a class="anchor" href="#705-设计哈希集合">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZXNpZ24taGFzaHNldC8=">705. 设计哈希集合</span></h4><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><p>实现 <code>MyHashSet</code> 类：</p><ul><li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li><li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li><li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li></ul><p><strong>示例：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;MyHashSet&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;contains&quot;</span>, <span class="string">&quot;contains&quot;</span>, <span class="string">&quot;add&quot;</span>, <span class="string">&quot;contains&quot;</span>, <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;contains&quot;</span>]</span><br><span class="line">[[], [<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">1</span>], [<span class="number">3</span>], [<span class="number">2</span>], [<span class="number">2</span>], [<span class="number">2</span>], [<span class="number">2</span>]]</span><br><span class="line">输出：</span><br><span class="line">[<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyHashSet myHashSet = <span class="keyword">new</span> MyHashSet();</span><br><span class="line">myHashSet.add(<span class="number">1</span>);      <span class="comment">// set = [1]</span></span><br><span class="line">myHashSet.add(<span class="number">2</span>);      <span class="comment">// set = [1, 2]</span></span><br><span class="line">myHashSet.<span class="built_in">contains</span>(<span class="number">1</span>); <span class="comment">// 返回 True</span></span><br><span class="line">myHashSet.<span class="built_in">contains</span>(<span class="number">3</span>); <span class="comment">// 返回 False ，（未找到）</span></span><br><span class="line">myHashSet.add(<span class="number">2</span>);      <span class="comment">// set = [1, 2]</span></span><br><span class="line">myHashSet.<span class="built_in">contains</span>(<span class="number">2</span>); <span class="comment">// 返回 True</span></span><br><span class="line">myHashSet.remove(<span class="number">2</span>);   <span class="comment">// set = [1]</span></span><br><span class="line">myHashSet.<span class="built_in">contains</span>(<span class="number">2</span>); <span class="comment">// 返回 False ，（已移除）</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= key &lt;= 106</code></li><li>最多调用 <code>104</code> 次 <code>add</code> 、 <code>remove</code> 和 <code>contains</code></li></ul><p>为了实现哈希集合这一数据结构，有以下几个关键问题需要解决：</p><p>哈希函数：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上。</p><ul><li><p>冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：</p></li><li><p>链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。</p></li><li><p>开放地址法：当发现哈希值 h 处产生冲突时，根据某种策略，从 h 出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查 h+1,h+2,h+3,… 这些整数对应的位置。</p></li><li><p>再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。</p><p>扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;list&lt;<span class="type">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyHashSet</span>(): <span class="built_in">data</span>(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].<span class="built_in">push_back</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                data[h].<span class="built_in">erase</span>(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = <span class="built_in">hash</span>(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].<span class="built_in">begin</span>(); it != data[h].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2739-总行驶距离"><a class="anchor" href="#2739-总行驶距离">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90b3RhbC1kaXN0YW5jZS10cmF2ZWxlZC8=">2739. 总行驶距离</span></h4><p>卡车有两个油箱。给你两个整数， <code>mainTank</code> 表示主油箱中的燃料（以升为单位）， <code>additionalTank</code> 表示副油箱中的燃料（以升为单位）。</p><p>该卡车每耗费 <code>1</code> 升燃料都可以行驶 <code>10</code> km。每当主油箱使用了 <code>5</code> 升燃料时，如果副油箱至少有 <code>1</code> 升燃料，则会将 <code>1</code> 升燃料从副油箱转移到主油箱。</p><p>返回卡车可以行驶的最大距离。</p><p>注意：从副油箱向主油箱注入燃料不是连续行为。这一事件会在每消耗 <code>5</code> 升燃料时突然且立即发生。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mainTank = 5, additionalTank = 10</span><br><span class="line">输出：60</span><br><span class="line">解释：</span><br><span class="line">在用掉<span class="number"> 5 </span>升燃料后，主油箱中燃料还剩下 (5 -<span class="number"> 5 </span>+ 1) =<span class="number"> 1 </span>升，行驶距离为 50km 。</span><br><span class="line">在用掉剩下的<span class="number"> 1 </span>升燃料后，没有新的燃料注入到主油箱中，主油箱变为空。</span><br><span class="line">总行驶距离为 60km 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：mainTank </span>=<span class="string"> 1, additionalTank = 2</span></span><br><span class="line"><span class="string">输出：10</span></span><br><span class="line"><span class="string">解释：</span></span><br><span class="line"><span class="string">在用掉 1 升燃料后，主油箱变为空。</span></span><br><span class="line"><span class="string">总行驶距离为 10km 。</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= mainTank, additionalTank &lt;= 100</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distanceTraveled</span><span class="params">(<span class="type">int</span> mainTank, <span class="type">int</span> additionalTank)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> del ;</span><br><span class="line">       <span class="keyword">while</span>(mainTank&gt;<span class="number">0</span>)&#123;</span><br><span class="line">          del = <span class="built_in">min</span>(<span class="number">5</span>,mainTank);</span><br><span class="line">          result += <span class="number">10</span>*del;</span><br><span class="line">          <span class="keyword">if</span>(del==<span class="number">5</span> &amp;&amp; additionalTank&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">             mainTank -= del - <span class="number">1</span>;</span><br><span class="line">             additionalTank--;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mainTank -= del;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2928-给小朋友们分糖果-i"><a class="anchor" href="#2928-给小朋友们分糖果-i">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXN0cmlidXRlLWNhbmRpZXMtYW1vbmctY2hpbGRyZW4taS8=">2928. 给小朋友们分糖果 I</span></h4><p>给你两个正整数 <code>n</code> 和 <code>limit</code> 。</p><p>请你将 <code>n</code> 颗糖果分给 <code>3</code> 位小朋友，确保没有任何小朋友得到超过 <code>limit</code> 颗糖果，请你返回满足此条件下的 <strong>总方案数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, limit = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：总共有<span class="number"> 3 </span>种方法分配<span class="number"> 5 </span>颗糖果，且每位小朋友的糖果数不超过<span class="number"> 2 </span>：(1, 2, 2) ，(2, 1, 2) 和 (2, 2, 1) 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, limit = 3</span><br><span class="line">输出：10</span><br><span class="line">解释：总共有<span class="number"> 10 </span>种方法分配<span class="number"> 3 </span>颗糖果，且每位小朋友的糖果数不超过<span class="number"> 3 </span>：(0, 0, 3) ，(0, 1, 2) ，(0, 2, 1) ，(0, 3, 0) ，(1, 0, 2) ，(1, 1, 1) ，(1, 2, 0) ，(2, 0, 1) ，(2, 1, 0) 和 (3, 0, 0) 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 50</code></li><li><code>1 &lt;= limit &lt;= 50</code></li></ul><p>思路</p><p>枚举第一个小朋友分得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 颗糖果，那么还剩下 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>−</mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">n−x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord mathnormal">x</span></span></span></span> 颗糖果，此时有两种情况：</p><ul><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>−</mtext><mi>x</mi><mo>&gt;</mo><mi>l</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">n−x&gt;limit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span> ，至少有一个小朋友会分得大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">limit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span> 颗糖果，此时不存在合法方案。</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mtext>−</mtext><mi>x</mi><mo>≤</mo><mi>l</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">n−x≤limit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7719400000000001em;vertical-align:-.13597em"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span>，对于第二个小朋友来说，至少得分得 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mtext>⁡</mtext><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mtext>−</mtext><mi>x</mi><mtext>−</mtext><mi>l</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max⁡(0,n−x−limit)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord">⁡</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> 颗糖果，才能保证第三个小朋友分得的糖果不超过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">limit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span> 颗。同时至多能拿到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mtext>⁡</mtext><mo stretchy="false">(</mo><mi>l</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mtext>−</mtext><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">min⁡(limit,n−x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord">⁡</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> 颗糖果。</p></li></ul><p>对于第二种情况计算出所有的合法方案即可。</p><p>复杂度分析</p><ul><li><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mtext>⁡</mtext><mo stretchy="false">(</mo><mi>l</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min⁡(limit,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord">⁡</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p></li><li><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="built_in">min</span>(limit, n); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n - i &gt; <span class="number">2</span> * limit) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 因为后两个小朋友分到的糖果具有相互制约和对称的特点，所以第二个小朋友能够分到的糖果的范围即是剩下的 n - i 个糖果产生的可能组合数</span></span><br><span class="line">            ans += <span class="built_in">min</span>(n - i, limit) - <span class="built_in">max</span>(<span class="number">0</span>, n - i - limit) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img data-src="E:%5Ctypora%E5%9B%BE%E7%89%87%5Cimage-20240601101309353.png" alt="image-20240601101309353"></p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x * (x - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cal</span>(n + <span class="number">2</span>) - <span class="number">3</span> * <span class="built_in">cal</span>(n - limit + <span class="number">1</span>) + <span class="number">3</span> * <span class="built_in">cal</span>(n - (limit + <span class="number">1</span>) * <span class="number">2</span> + <span class="number">2</span>) - <span class="built_in">cal</span>(n - <span class="number">3</span> * (limit + <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="中等-2"><a class="anchor" href="#中等-2">#</a> 中等</h3><h4 id="2789-合并后数组中的最大元素"><a class="anchor" href="#2789-合并后数组中的最大元素">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LWVsZW1lbnQtaW4tYW4tYXJyYXktYWZ0ZXItbWVyZ2Utb3BlcmF0aW9ucy8=">2789. 合并后数组中的最大元素</span></h4><p>给你一个下标从 <strong>0</strong> 开始、由正整数组成的数组 <code>nums</code> 。</p><p>你可以在数组上执行下述操作 <strong>任意</strong> 次：</p><ul><li>选中一个同时满足 <code>0 &lt;= i &lt; nums.length - 1</code> 和 <code>nums[i] &lt;= nums[i + 1]</code> 的整数 <code>i</code> 。将元素 <code>nums[i + 1]</code> 替换为 <code>nums[i] + nums[i + 1]</code> ，并从数组中删除元素 <code>nums[i]</code> 。</li></ul><p>返回你可以从最终数组中获得的 <strong>最大</strong> 元素的值。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="selector-attr">[2,3,7,9,3]</span></span><br><span class="line">输出：<span class="number">21</span></span><br><span class="line">解释：我们可以在数组上执行下述操作：</span><br><span class="line">- 选中 <span class="selector-tag">i</span> = <span class="number">0</span> ，得到数组 nums = <span class="selector-attr">[5,7,9,3]</span> 。</span><br><span class="line">- 选中 <span class="selector-tag">i</span> = <span class="number">1</span> ，得到数组 nums = <span class="selector-attr">[5,16,3]</span> 。</span><br><span class="line">- 选中 <span class="selector-tag">i</span> = <span class="number">0</span> ，得到数组 nums = <span class="selector-attr">[21,3]</span> 。</span><br><span class="line">最终数组中的最大元素是 <span class="number">21</span> 。可以证明我们无法获得更大的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="selector-attr">[5,3,3]</span></span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：我们可以在数组上执行下述操作：</span><br><span class="line">- 选中 <span class="selector-tag">i</span> = <span class="number">1</span> ，得到数组 nums = <span class="selector-attr">[5,6]</span> 。</span><br><span class="line">- 选中 <span class="selector-tag">i</span> = <span class="number">0</span> ，得到数组 nums = <span class="selector-attr">[11]</span> 。</span><br><span class="line">最终数组中只有一个元素，即 <span class="number">11</span> 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 106</code></li></ul><p><strong>解法：贪心 + 后序遍历</strong></p><p>思路：首先理解题意，题目中的一次替换删除操作，其实是相当于将两个相邻并且非递减的数字进行求和合并。两个数字的和来替换掉原来的两个数字。而经过若干次这样的合并，整个数组的和是不变的。合并后数组中的每个元素，都是原数组的某个子数组的和，并且这些子数组拼接起来能构成整个原数组。为了使数组的最大值最大，我们可以贪心地做尽可能多的合并，直到整个数组都不能进行合并。合并的要求是后面的数字不小于前面的数字，我们就尽可能先合并靠后的数字，使其尽快能大，才能够合并前面的数字。</p><p>我们从后往前倒序遍历一次数组，依次比较两个相邻的元素，如果两个相邻的元素能够合并，就将其合并。如果不能合并，就继续往前判断。因为这样的操作流程，在比较过程中，靠后的数是所有操作流程可能性中能产生的最大值，而靠前的数，是所有操作流程可能性中能产生的最小值。如果在遍历过程中，比较的结果是不能合并，那么其他任何操作流程都无法合并这两个数。如果可以合并，那我们就贪心地合并，因为这样能使接下来的比较中，靠后的数字尽可能大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxArrayValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 贪心思想，如果让后面的数尽可能大，就能够达到想要的最大数组的值</span></span><br><span class="line">    <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span>   result = nums[length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = length - <span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="comment">// 如果这个数比前面的大，就合并他，如果没有前面的大，那么他就是没有办法合并的</span></span><br><span class="line">        <span class="comment">// 只能丢掉此时的值，然后从他开始，因为他本身就比后面的大，肯定有更强的实力能</span></span><br><span class="line">        <span class="comment">// 合并更多的，得到更大的值</span></span><br><span class="line">        <span class="keyword">if</span>(result &gt;= nums[i])&#123;</span><br><span class="line">            result += nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums =&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">maxArrayValue</span>(nums) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2684-矩阵中移动的最大次数"><a class="anchor" href="#2684-矩阵中移动的最大次数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLW51bWJlci1vZi1tb3Zlcy1pbi1hLWdyaWQv">2684. 矩阵中移动的最大次数</span></h4><p>给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的矩阵 <code>grid</code> ，矩阵由若干 <strong>正</strong> 整数组成。</p><p>你可以从矩阵第一列中的 <strong>任一</strong> 单元格出发，按以下方式遍历 <code>grid</code> ：</p><ul><li>从单元格 <code>(row, col)</code> 可以移动到 <code>(row - 1, col + 1)</code> 、 <code>(row, col + 1)</code> 和 <code>(row + 1, col + 1)</code> 三个单元格中任一满足值 <strong>严格</strong> 大于当前单元格的单元格。</li></ul><p>返回你在矩阵中能够 <strong>移动</strong> 的 <strong>最大</strong> 次数。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2023/04/11/yetgriddrawio-10.png" alt="img"></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">11</span>],[<span class="number">10</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">15</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：可以从单元格 (<span class="number">0</span>, <span class="number">0</span>) 开始并且按下面的路径移动：</span><br><span class="line">- <span class="function"><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span> -&gt;</span> (<span class="number">0</span>, <span class="number">1</span>).</span><br><span class="line">- <span class="function"><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span> -&gt;</span> (<span class="number">1</span>, <span class="number">2</span>).</span><br><span class="line">- <span class="function"><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span> -&gt;</span> (<span class="number">2</span>, <span class="number">3</span>).</span><br><span class="line">可以证明这是能够移动的最大次数。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[3,2,4],[2,1,9],[1,1,7]]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：从第一列的任一单元格开始都无法移动。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= m, n &lt;= 1000</code></li><li><code>4 &lt;= m * n &lt;= 105</code></li><li><code>1 &lt;= grid[i][j] &lt;= 106</code></li></ul><p>得加上记忆化搜索</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxMoves_memorySearch</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//  这种得加上记忆化搜索的方式，要不会超时，该版本还没有加上记忆化搜索</span></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; dfs = [=](<span class="type">int</span> x,<span class="type">int</span> y)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(y==n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历他从任意一个可以到达的方向的次数的最大值</span></span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;<span class="number">0</span> &amp;&amp; grid[x<span class="number">-1</span>][y<span class="number">+1</span>] &gt; grid[x][y])&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,<span class="built_in">dfs</span>(x<span class="number">-1</span>,y<span class="number">+1</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(grid[x][y<span class="number">+1</span>] &gt; grid[x][y])&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,<span class="built_in">dfs</span>(x,y<span class="number">+1</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;m<span class="number">-1</span> &amp;&amp; grid[x<span class="number">+1</span>][y<span class="number">+1</span>] &gt; grid[x][y])&#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res,<span class="built_in">dfs</span>(x<span class="number">+1</span>,y<span class="number">+1</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">             result = <span class="built_in">max</span>(result,<span class="built_in">dfs</span>(i,<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态规划方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxMoves_dp</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">         <span class="comment">// 动态规划</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j<span class="number">+1</span>] &gt; grid[i][j])&#123;</span><br><span class="line">                    dp[i][j]  = <span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">+1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j<span class="number">+1</span>] &gt; grid[i][j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],dp[i][j<span class="number">+1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;m<span class="number">-1</span> &amp;&amp; grid[i<span class="number">+1</span>][j<span class="number">+1</span>] &gt; grid[i][j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],dp[i<span class="number">+1</span>][j<span class="number">+1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            result = <span class="built_in">max</span>(dp[i][<span class="number">0</span>],result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="310-最小高度树"><a class="anchor" href="#310-最小高度树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWhlaWdodC10cmVlcy8=">310. 最小高度树</span></h4><p>树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</p><p>给你一棵包含 <code>n</code> 个节点的树，标记为 <code>0</code> 到 <code>n - 1</code> 。给定数字 <code>n</code> 和一个有 <code>n - 1</code> 条无向边的 <code>edges</code> 列表（每一个边都是一对标签），其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条无向边。</p><p>可选择树中任何一个节点作为根。当选择节点 <code>x</code> 作为根节点时，设结果树的高度为 <code>h</code> 。在所有可能的树中，具有最小高度的树（即， <code>min(h)</code> ）被称为 <strong>最小高度树</strong> 。</p><p>请你找到所有的 <strong>最小高度树</strong> 并按 <strong>任意顺序</strong> 返回它们的根节点标签列表。</p><p>树的 <strong>高度</strong> 是指根节点和叶子节点之间最长向下路径上边的数量。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/09/01/e1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, edges = <span class="comment">[<span class="comment">[1,0]</span>,<span class="comment">[1,2]</span>,<span class="comment">[1,3]</span>]</span></span><br><span class="line">输出：<span class="comment">[1]</span></span><br><span class="line">解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/09/01/e2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 6, edges = <span class="comment">[<span class="comment">[3,0]</span>,<span class="comment">[3,1]</span>,<span class="comment">[3,2]</span>,<span class="comment">[3,4]</span>,<span class="comment">[5,4]</span>]</span></span><br><span class="line">输出：<span class="comment">[3,4]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>edges.length == n - 1</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>ai != bi</code></li><li>所有 <code>(ai, bi)</code> 互不相同</li><li>给定的输入 <strong>保证</strong> 是一棵树，并且 <strong>不会有重复的边</strong></li></ul><p>思路一：深度优先搜索，每一个节点作为根节点，比较并记录最小高度的根节点，时间复杂度 O (n2) ，不能通过内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索，基本思路：每一个节点作为根节点，比较并记录最小高度的根节点</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees_dfs</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">       vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edg</span>(n);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:edges)&#123;</span><br><span class="line">        edg[e[<span class="number">0</span>]].<span class="built_in">push_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">        edg[e[<span class="number">1</span>]].<span class="built_in">push_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">const</span> <span class="type">int</span> MAX = INT16_MAX;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">       <span class="type">int</span> minHight = MAX;</span><br><span class="line">       <span class="type">int</span> height ;</span><br><span class="line">       function&lt;<span class="type">int</span>(<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;)&gt; dfs = [&amp;](<span class="type">int</span> x,vector&lt;<span class="type">int</span>&gt; tag)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="comment">// 循环入栈还还没有遍历计算过的节点</span></span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;child:edg[x])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!tag[child])&#123;</span><br><span class="line">                    tag[child] = <span class="number">1</span>;</span><br><span class="line">                    res = <span class="built_in">max</span>(res,<span class="built_in">dfs</span>(child,tag) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 如果没有更新的话，就属于不存在没有遍历过的子节点</span></span><br><span class="line">            <span class="comment">// 这样的话，高度就是0</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">// 遍历寻找任意一个作为根节点的最大高度并记录此时根节点</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">           <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tag</span><span class="params">(n)</span></span>;</span><br><span class="line">           tag[i] = <span class="number">1</span>;</span><br><span class="line">           height = <span class="built_in">dfs</span>(i,tag);</span><br><span class="line">           <span class="keyword">if</span>(minHight &lt; height)&#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(minHight &gt; height)&#123;</span><br><span class="line">            minHight = height;</span><br><span class="line">            result.<span class="built_in">clear</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(i);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line">   vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges = &#123;&#123;<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">3</span>,<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">findMinHeightTrees_dfs</span>(n,edges);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:result)&#123;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：广度优先搜索，原理：就是找到最远的路径，路径中间作为根节点，因为能够平分的原因，所以此时树的高度最小，此时最长路径中间节点就是最小高度树的根节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定节点出发寻找距离最远的节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLongestNode</span><span class="params">(<span class="type">int</span> u, vector&lt;<span class="type">int</span>&gt; &amp; parent, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到节点的个数</span></span><br><span class="line">        <span class="type">int</span> n = adj.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 用于广度优先搜索的队列</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">        <span class="comment">// 访问记录标签</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 将此时的节点入队</span></span><br><span class="line">        qu.<span class="built_in">emplace</span>(u);</span><br><span class="line">        <span class="comment">// 并将此时的访问标签置为True (即表示已经访问过该标签，可避免重复访问)</span></span><br><span class="line">        visit[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 初始化最远节点</span></span><br><span class="line">        <span class="type">int</span> node = <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 如果队列非空，就取出此时队头元素</span></span><br><span class="line">            <span class="type">int</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            node = curr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; v : adj[curr]) &#123;</span><br><span class="line">                <span class="comment">// 遍历寻找该节点的后继节点（没有访问过）</span></span><br><span class="line">                <span class="keyword">if</span> (!visit[v]) &#123;</span><br><span class="line">                    visit[v] = <span class="literal">true</span>;</span><br><span class="line">                    parent[v] = curr;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 广度优先搜索找到距离</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造图结构</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; edge : edges) &#123;</span><br><span class="line">            adj[edge[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            adj[edge[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(edge[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义父节点，用来记录路径</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">parent</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="comment">/* 找到与节点 0 最远的节点 x */</span></span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">findLongestNode</span>(<span class="number">0</span>, parent, adj);</span><br><span class="line">        <span class="comment">/* 找到与节点 x 最远的节点 y */</span></span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">findLongestNode</span>(x, parent, adj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 求出节点 x 到节点 y 的路径 */</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        parent[x] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">-1</span>) &#123;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(y);</span><br><span class="line">            y = parent[y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到的x和y是这棵树上最远的两个节点</span></span><br><span class="line">        <span class="comment">// 相距最远两个节点的一半就是最小高度</span></span><br><span class="line">        <span class="type">int</span> m = path.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 根据最长路径上的节点数</span></span><br><span class="line">        <span class="comment">// 如果节点数是偶数的话，最小高度树的根节点就是路径中间那两个</span></span><br><span class="line">        <span class="comment">// 如果节点数是奇数的话，最小高度树的根节点就是路径中间那一个</span></span><br><span class="line">        <span class="keyword">if</span> (m % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;path[m / <span class="number">2</span> - <span class="number">1</span>], path[m / <span class="number">2</span>]&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;path[m / <span class="number">2</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> n = <span class="number">6</span>;</span><br><span class="line">   vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges = &#123;&#123;<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">3</span>,<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">findMinHeightTrees_dfs</span>(n,edges);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:result)&#123;</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="80-删除有序数组中的重复项-ii"><a class="anchor" href="#80-删除有序数组中的重复项-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1hcnJheS1paS8=">80. 删除有序数组中的重复项 II</span></h4><p>给你一个有序数组 <code>nums</code> ，请你 **<span class="exturl" data-url="aHR0cDovL2JhaWtlLmJhaWR1LmNvbS9pdGVtLyVFNSU4RSU5RiVFNSU5QyVCMCVFNyVBRSU5NyVFNiVCMyU5NQ=="> 原地</span> ** 删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEUlOUYlRTUlOUMlQjAlRTclQUUlOTclRTYlQjMlOTU=">原地 </span>修改输入数组</strong> 并在使用 O (1) 额外空间的条件下完成。</p><p><strong>说明：</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以 **「引用」** 方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">len</span> = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[1,1,1,2,2,3]</span></span><br><span class="line">输出：<span class="number">5</span>, nums = <span class="string">[1,1,2,2,3]</span></span><br><span class="line">解释：函数应返回新长度 length = <span class="number">5</span>, 并且原数组的前五个元素被修改为 <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0,0,1,1</span>,<span class="number">1,1,2,3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">7</span>, nums = [<span class="number">0,0,1,1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应返回新长度 length = <span class="number">7</span>, 并且原数组的前七个元素被修改为 <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按升序排列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span> , right = <span class="number">0</span>,step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            step = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 循环找到此时的不同的地方</span></span><br><span class="line">            <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[left] == nums[right])&#123;</span><br><span class="line">                right ++;</span><br><span class="line">                step ++;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">             <span class="comment">// 记录此时的right所指的值</span></span><br><span class="line">            <span class="keyword">if</span>(step&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                nums[left + <span class="number">2</span>] = nums[right];</span><br><span class="line">                <span class="keyword">if</span>(nums[left + <span class="number">1</span>]!=nums[left])&#123;</span><br><span class="line">                    nums[left + <span class="number">1</span>] = nums[right<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                left +=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[left + <span class="number">1</span>] = nums[right];</span><br><span class="line">                left +=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 处理最后一个是两个的情况，因为此时right已经大于nums.size()了，所以得特别处理</span></span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(step&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                nums[left + <span class="number">1</span>] = nums[right<span class="number">-1</span>];</span><br><span class="line">                left ++;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1969-数组元素的最小非零乘积"><a class="anchor" href="#1969-数组元素的最小非零乘积">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLW5vbi16ZXJvLXByb2R1Y3Qtb2YtdGhlLWFycmF5LWVsZW1lbnRzLw==">1969. 数组元素的最小非零乘积</span></h4><p>给你一个正整数 <code>p</code> 。你有一个下标从 <strong>1</strong> 开始的数组 <code>nums</code> ，这个数组包含范围 <code>[1, 2p - 1]</code> 内所有整数的二进制形式（两端都 <strong>包含</strong>）。你可以进行以下操作 <strong>任意</strong> 次：</p><ul><li>从 <code>nums</code> 中选择两个元素 <code>x</code> 和 <code>y</code> 。</li><li>选择 <code>x</code> 中的一位与 <code>y</code> 对应位置的位交换。对应位置指的是两个整数 <strong>相同位置</strong> 的二进制位。</li></ul><p>比方说，如果 <code>x = 11***0***1</code> 且 <code>y = 00***1***1</code> ，交换右边数起第 <code>2</code> 位后，我们得到 <code>x = 11***1***1</code> 和 <code>y = 00***0***1</code> 。</p><p>请你算出进行以上操作 <strong>任意次</strong> 以后， <code>nums</code> 能得到的 <strong>最小非零</strong> 乘积。将乘积对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><p>** 注意：** 答案应为取余 <strong>之前</strong> 的最小值。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：p <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：nums <span class="operator">=</span> [<span class="number">1</span>] 。</span><br><span class="line">只有一个元素，所以乘积为该元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：p = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：nums = [01, 10, 11] 。</span><br><span class="line">所有交换要么使乘积变为<span class="number"> 0 </span>，要么乘积与初始乘积相同。</span><br><span class="line">所以，数组乘积<span class="number"> 1 </span>*<span class="number"> 2 </span>*<span class="number"> 3 </span>=<span class="number"> 6 </span>已经是最小值。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：p = 3</span><br><span class="line">输出：1512</span><br><span class="line">解释：nums = [001, 010, 011, 100, 101, 110, 111]</span><br><span class="line">- 第一次操作中，我们交换第二个和第五个元素最左边的数位。</span><br><span class="line">    - 结果数组为 [001, 110, 011, 100, 001, 110, 111] 。</span><br><span class="line">- 第二次操作中，我们交换第三个和第四个元素中间的数位。</span><br><span class="line">    - 结果数组为 [001, 110, 001, 110, 001, 110, 111] 。</span><br><span class="line">数组乘积<span class="number"> 1 </span>*<span class="number"> 6 </span>*<span class="number"> 1 </span>*<span class="number"> 6 </span>*<span class="number"> 1 </span>*<span class="number"> 6 </span>*<span class="number"> 7 </span>=<span class="number"> 1512 </span>是最小乘积。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= p &lt;= 60</code></li></ul><p>计算快速幂的方式 （递归版本）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">binpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res = <span class="built_in">binpow</span>(a, b / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> (b % <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> res * res * a;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> res * res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">binpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a;</span><br><span class="line">    a = a * a;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本道题就是，一个简单问题的扩展，就是 abc，按照从小到大排列，可以知道要使减小的更多，应该选择较小的减少</p><p>即 (a-k) bc = abc-kbc 而 ab (c-k) = abc - abk 其中 abk&lt;bck 所以要想减少的多，尽量从较小的数上去减值</p><p>再者，如果增大的话，保证增大的少，应该尽量增大较大的值，即 (a+k) bc = abc + bck ab (c+k) = abc + abk</p><p>因为 abk &lt; bck 所以要保证乘积增加的尽量少，应尽可能在较大的值进行增加</p><p>综合起来如果一个值减少 k，另一个值增加 k，减少的值尽量从较小的值上去做减法，增加的值尽量在较大的值上做</p><p>因为经过自由组合，可以发现 (a-k) b (c+k) = abc + b (a-c) k - k2 相比于 (a-k)(b+k) c = abc +c (a-b) k - k2 因为 b (a-c) k &lt; c (a-b) k &lt; 0，所以为了保证更小所以选择 (a-k) b (c+k) 这个组合 ，所以根据贪心可以直接知道本题的答案 (2 ^ p - 1 )・( 2 ^ p - 2) ^ (2 ^ ( p - 1) -1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂算法</span></span><br><span class="line"><span class="comment">// log(n)的时间复杂度计算a的n次方</span></span><br><span class="line"><span class="comment">// 递归公式就是 a</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">binpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果当前的幂为0的话就直接输出1</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归调用，计算右移一位的</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="built_in">binpow</span>(a,b/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 如果b是个奇数，说明最后一位是一个1，所以</span></span><br><span class="line">    <span class="comment">// 右移导致丢了一个a,最后再乘上去</span></span><br><span class="line">    <span class="keyword">if</span>(b%<span class="number">2</span>)</span><br><span class="line">       <span class="keyword">return</span> (res%mod)*(res%mod)%mod*a%mod;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">return</span> (res%mod)*(res%mod)%mod;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minNonZeroProduct</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(p==<span class="number">1</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> x = <span class="built_in">binpow</span>(<span class="number">2</span>,p) - <span class="number">1</span>;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> y = (<span class="type">long</span> <span class="type">long</span>)<span class="number">1</span>&lt;&lt;(p<span class="number">-1</span>);</span><br><span class="line">   <span class="keyword">return</span>  <span class="built_in">binpow</span>(x<span class="number">-1</span>,y<span class="number">-1</span>)*x%mod;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">minNonZeroProduct</span>(<span class="number">32</span>) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="189-轮转数组"><a class="anchor" href="#189-轮转数组">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3RhdGUtYXJyYXkv">189. 轮转数组</span></h4><p>给定一个整数数组 <code>nums</code> ，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">输入</span><span class="punctuation">:</span> <span class="string">nums = [1,2,3,4,5,6,7], k = 3</span></span><br><span class="line"><span class="attribute">输出</span><span class="punctuation">:</span> <span class="string">[5,6,7,1,2,3,4]</span></span><br><span class="line"><span class="attribute">解释</span><span class="punctuation">:</span></span><br><span class="line"><span class="attribute">向右轮转 1 步</span><span class="punctuation">:</span> <span class="string">[7,1,2,3,4,5,6]</span></span><br><span class="line"><span class="attribute">向右轮转 2 步</span><span class="punctuation">:</span> <span class="string">[6,7,1,2,3,4,5]</span></span><br><span class="line"><span class="attribute">向右轮转 3 步</span><span class="punctuation">:</span> <span class="string">[5,6,7,1,2,3,4]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">-1</span>,<span class="string">-100</span>,3,99], k = 2</span><br><span class="line">输出：[3,99,<span class="string">-1</span>,<span class="string">-100</span>]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,<span class="string">-1</span>,<span class="string">-100</span>,3]</span><br><span class="line">向右轮转 2 步: [3,99,<span class="string">-1</span>,<span class="string">-100</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= k &lt;= 105</code></li></ul><p><strong>进阶：</strong></p><ul><li>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</li><li>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</li></ul><p><strong>环装替换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求解最大公约数</span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">       <span class="type">int</span> temp;</span><br><span class="line">       <span class="keyword">while</span>(b)&#123;</span><br><span class="line">           temp = b;</span><br><span class="line">           b = a%b;</span><br><span class="line">           a = temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 求解最小公倍数 </span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (a*b)/<span class="built_in">gcd</span>(a,b);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">       k = k % n;</span><br><span class="line">       <span class="type">int</span> count = <span class="built_in">gcd</span>(k, n);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; count; ++start) &#123;</span><br><span class="line">           <span class="type">int</span> current = start;</span><br><span class="line">           <span class="type">int</span> prev = nums[start];</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               <span class="type">int</span> next = (current + k) % n;</span><br><span class="line">               <span class="built_in">swap</span>(nums[next], prev);</span><br><span class="line">               current = next;</span><br><span class="line">           &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="122-买卖股票的最佳时机-ii"><a class="anchor" href="#122-买卖股票的最佳时机-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iZXN0LXRpbWUtdG8tYnV5LWFuZC1zZWxsLXN0b2NrLWlpLw==">122. 买卖股票的最佳时机 II</span></h4><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和 / 或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第<span class="number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="number"> 5 </span>-<span class="number"> 1 </span>=<span class="number"> 4 </span>。</span><br><span class="line">     随后，在第<span class="number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="number"> 6 </span>-<span class="number"> 3 </span>=<span class="number"> 3 </span>。</span><br><span class="line">     总利润为<span class="number"> 4 </span>+<span class="number"> 3 </span>=<span class="number"> 7 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第<span class="number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="number"> 5 </span>-<span class="number"> 1 </span>=<span class="number"> 4 </span>。</span><br><span class="line">     总利润为<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = <span class="string">[7,6,4,3,1]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><p>因为交易次数不受限，如果可以把所有的上坡全部收集到，一定是利益最大化的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span>  length = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i<span class="number">+1</span>]&gt;prices[i])&#123;</span><br><span class="line">                result += prices[i<span class="number">+1</span>] - prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="518-零钱兑换-ii"><a class="anchor" href="#518-零钱兑换-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb2luLWNoYW5nZS1paS8=">518. 零钱兑换 II</span></h4><p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p><p>假设每一种面额的硬币有无限个。</p><p>题目数据保证结果符合 32 位带符号整数。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line">5=5</span><br><span class="line">5=2<span class="string">+2</span><span class="string">+1</span></span><br><span class="line">5=2<span class="string">+1</span><span class="string">+1</span><span class="string">+1</span></span><br><span class="line">5=1<span class="string">+1</span><span class="string">+1</span><span class="string">+1</span><span class="string">+1</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount = 3, coins = [2]</span><br><span class="line">输出：0</span><br><span class="line">解释：只用面额<span class="number"> 2 </span>的硬币不能凑成总金额<span class="number"> 3 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：amount </span>=<span class="string"> 10, coins = [10] </span></span><br><span class="line"><span class="string">输出：1</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 300</code></li><li><code>1 &lt;= coins[i] &lt;= 5000</code></li><li><code>coins</code> 中的所有值 <strong>互不相同</strong></li><li><code>0 &lt;= amount &lt;= 5000</code></li></ul><p>动态规划：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span>&amp; coin : coins) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">               dp[i] += dp[i - coin];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[amount];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// int result = 0;</span></span><br><span class="line">       <span class="comment">// int length = coins.size();</span></span><br><span class="line">       <span class="comment">// function&lt;void(int,int)&gt; chage_bfs = [&amp;](int amount,int k)-&gt;void&#123;</span></span><br><span class="line">       <span class="comment">//     if(amount &lt; 0 )</span></span><br><span class="line">       <span class="comment">//        return;</span></span><br><span class="line">       <span class="comment">//     if(amount == 0)&#123;</span></span><br><span class="line">       <span class="comment">//         result++ ;</span></span><br><span class="line">       <span class="comment">//         return ;</span></span><br><span class="line">       <span class="comment">//     &#125;</span></span><br><span class="line">       <span class="comment">//     for(int i=k;i&lt;length;i++)&#123;</span></span><br><span class="line">       <span class="comment">//         chage_bfs(amount-coins[i],i);</span></span><br><span class="line">       <span class="comment">//     &#125;</span></span><br><span class="line">       <span class="comment">// &#125;;</span></span><br><span class="line">       <span class="comment">// chage_bfs(amount,0);</span></span><br><span class="line">       <span class="comment">// return result;</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="274-h-指数"><a class="anchor" href="#274-h-指数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9oLWluZGV4Lw==">274. H 指数</span></h4><p>给你一个整数数组 <code>citations</code> ，其中 <code>citations[i]</code> 表示研究者的第 <code>i</code> 篇论文被引用的次数。计算并返回该研究者的 <strong><code>h</code> 指数</strong>。</p><p>根据维基百科上 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9oLWluZGV4LzM5OTE0NTI/ZnI9YWxhZGRpbg==">h 指数的定义</span>： <code>h</code> 代表 “高引用次数” ，一名科研人员的 <code>h</code> <strong>指数</strong> 是指他（她）至少发表了 <code>h</code> 篇论文，并且 <strong>至少</strong> 有 <code>h</code> 篇论文被引用次数大于等于 <code>h</code> 。如果 <code>h</code> 有多种可能的值，<strong> <code>h</code> 指数</strong> 是其中最大的那个。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：citations = [3,0,6,1,5]</span><br><span class="line">输出：3 </span><br><span class="line">解释：给定数组表示研究者总共有<span class="number"> 5 </span>篇论文，每篇论文相应的被引用了 3, 0, 6, 1,<span class="number"> 5 </span>次。</span><br><span class="line">     由于研究者有<span class="number"> 3 </span>篇论文每篇 至少 被引用了<span class="number"> 3 </span>次，其余两篇论文每篇被引用 不多于<span class="number"> 3 </span>次，所以她的 h 指数是 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：citations </span>=<span class="string"> [1,3,1]</span></span><br><span class="line"><span class="string">输出：1</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == citations.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= citations[i] &lt;= 1000</code></li></ul><ul><li>先排序，然后从论文引用次数从大到小进行遍历，时间复杂度 o (nlogn)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = citations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(citations.<span class="built_in">begin</span>(),citations.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(result &lt; length)&#123;</span><br><span class="line">              <span class="keyword">if</span>(citations[length<span class="number">-1</span>-result]&gt;= result + <span class="number">1</span>)&#123;</span><br><span class="line">                 result++;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>用 counter 数组记录论文引用次数等于 i 的论文篇数，引用次数大于总论文篇数的按照总论文篇数计算，然后接着遍历 counter 数组就可以了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> n = citations.<span class="built_in">size</span>(), tot = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (citations[i] &gt;= n) &#123;</span><br><span class="line">                counter[n]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counter[citations[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tot += counter[i];</span><br><span class="line">            <span class="keyword">if</span> (tot &gt;= i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="238-除自身以外数组的乘积"><a class="anchor" href="#238-除自身以外数组的乘积">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wcm9kdWN0LW9mLWFycmF5LWV4Y2VwdC1zZWxmLw==">238. 除自身以外数组的乘积</span></h4><p>给你一个整数数组 <code>nums</code> ，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p><p>题目数据 <strong>保证</strong> 数组 <code>nums</code> 之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p><p>请 ** 不要使用除法，** 且在 <code>O(*n*)</code> 时间复杂度内完成此题。</p><p><strong>示例 1:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1,2,3,4</span>]</span><br><span class="line">输出: [<span class="number">24,12,8,6</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = <span class="comment">[-1,1,0,-3,3]</span></span><br><span class="line">输出: <span class="comment">[0,0,9,0,0]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>-30 &lt;= nums[i] &lt;= 30</code></li><li><strong>保证</strong> 数组 <code>nums</code> 之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内</li></ul><p>** 进阶：** 你可以在 <code>O(1)</code> 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 <strong>不被视为</strong> 额外空间。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 用两个数组left 和 right</span></span><br><span class="line">       <span class="comment">// left计算并保存[0....i-1]的 乘积</span></span><br><span class="line">       <span class="comment">// right 计算并保存[i+1....n-1] 的乘积</span></span><br><span class="line">       <span class="comment">// 如果想要除了i位置的其他位置的乘积，就 是 result[i] = left[i] * right[i];</span></span><br><span class="line">       <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(length,<span class="number">1</span>)</span></span>;</span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(length,<span class="number">1</span>)</span></span>;</span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(length)</span></span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">           left[i] = left[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=length<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">           right[i] = right[i<span class="number">+1</span>]*nums[i<span class="number">+1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">           result[i] = left[i]*right[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2580-统计将重叠区间合并成组的方案数"><a class="anchor" href="#2580-统计将重叠区间合并成组的方案数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC13YXlzLXRvLWdyb3VwLW92ZXJsYXBwaW5nLXJhbmdlcy8=">2580. 统计将重叠区间合并成组的方案数</span></h4><p>给你一个二维整数数组 <code>ranges</code> ，其中 <code>ranges[i] = [starti, endi]</code> 表示 <code>starti</code> 到 <code>endi</code> 之间（包括二者）的所有整数都包含在第 <code>i</code> 个区间中。</p><p>你需要将 <code>ranges</code> 分成 <strong>两个</strong> 组（可以为空），满足：</p><ul><li>每个区间只属于一个组。</li><li>两个有 <strong>交集</strong> 的区间必须在 <strong>同一个</strong> 组内。</li></ul><p>如果两个区间有至少 <strong>一个</strong> 公共整数，那么这两个区间是 <strong>有交集</strong> 的。</p><ul><li>比方说，区间 <code>[1, 3]</code> 和 <code>[2, 5]</code> 有交集，因为 <code>2</code> 和 <code>3</code> 在两个区间中都被包含。</li></ul><p>请你返回将 <code>ranges</code> 划分成两个组的 <strong>总方案数</strong> 。由于答案可能很大，将它对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：ranges = <span class="string">[[6,10],[5,15]]</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">两个区间有交集，所以它们必须在同一个组内。</span><br><span class="line">所以有两种方案：</span><br><span class="line">- 将两个区间都放在第 <span class="number">1</span> 个组中。</span><br><span class="line">- 将两个区间都放在第 <span class="number">2</span> 个组中。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：ranges = <span class="comment">[<span class="comment">[1,3]</span>,<span class="comment">[10,20]</span>,<span class="comment">[2,5]</span>,<span class="comment">[4,8]</span>]</span></span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">区间 <span class="comment">[1,3]</span> 和 <span class="comment">[2,5]</span> 有交集，所以它们必须在同一个组中。</span><br><span class="line">同理，区间 <span class="comment">[2,5]</span> 和 <span class="comment">[4,8]</span> 也有交集，所以它们也必须在同一个组中。</span><br><span class="line">所以总共有 4 种分组方案：</span><br><span class="line">- 所有区间都在第 1 组。</span><br><span class="line">- 所有区间都在第 2 组。</span><br><span class="line">- 区间 <span class="comment">[1,3]</span> ，<span class="comment">[2,5]</span> 和 <span class="comment">[4,8]</span> 在第 1 个组中，<span class="comment">[10,20]</span> 在第 2 个组中。</span><br><span class="line">- 区间 <span class="comment">[1,3]</span> ，<span class="comment">[2,5]</span> 和 <span class="comment">[4,8]</span> 在第 2 个组中，<span class="comment">[10,20]</span> 在第 1 个组中。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ranges.length &lt;= 105</code></li><li><code>ranges[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 109</code></li></ul><p>题目要求我们将一组区间分成两组，其中有交集的区间必须在同一组。因此，首先将有交集的区间合并一个集合，集合与集合之间不存在有交集的区间，因此每个集合可以选择分到第一组还是第二组。如果最终得到 k 个集合，那么方案数就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.849108em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.849108em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span></span></span></span></span></span></span></span></p><p>我们首先按照左端点从小到大对区间进行排序，然后对于第 i 个区间，不断的向右扩展与它有交集的区间，令<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">r=ranges[i][1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span></span> 是当前右端点，过程中还需要不断地更新右端点，直到下一个区间不再与之相交为止，具体来说，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j=i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.74285em;vertical-align:-.08333em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">j&lt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.85396em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span>, 并且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">ranges[j][0]&lt;=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:.36687em;vertical-align:0"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span></span></span></span> 时，就继续合并第 j 个区间，更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r=max(r,ranges[j][1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:.05724em">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>，然后令 j 加 1, 当条件不满足时，k 增加 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countWays</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ranges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(ranges.<span class="built_in">begin</span>(), ranges.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = ranges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ) &#123;</span><br><span class="line">            <span class="type">int</span> r = ranges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; ranges[j][<span class="number">0</span>] &lt;= r) &#123;</span><br><span class="line">                r = <span class="built_in">max</span>(r, ranges[j][<span class="number">1</span>]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res * <span class="number">2</span> % mod;</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int countWays(vector&lt;vector&lt;int&gt;&gt;&amp; ranges) &#123;</span></span><br><span class="line">    <span class="comment">//   long long  mod = 1e9 + 7;</span></span><br><span class="line">    <span class="comment">//   int result = 2;</span></span><br><span class="line">    <span class="comment">//   int k = 0;</span></span><br><span class="line">    <span class="comment">//   function&lt;bool(vector&lt;int&gt;,vector&lt;int&gt;)&gt; cmp = [=](vector&lt;int&gt; a,vector&lt;int&gt; b )-&gt;bool&#123;</span></span><br><span class="line">    <span class="comment">//         if(a[0]!=b[0])</span></span><br><span class="line">    <span class="comment">//            return a[0] &lt; b[0];</span></span><br><span class="line">    <span class="comment">//         else</span></span><br><span class="line">    <span class="comment">//            return a[1] &lt; b[1];</span></span><br><span class="line">    <span class="comment">//       &#125;;</span></span><br><span class="line">    <span class="comment">//       sort(ranges.begin(),ranges.end(),cmp);</span></span><br><span class="line">    <span class="comment">//       int length = ranges.size();</span></span><br><span class="line">    <span class="comment">//       for(int i = 0;i&lt;length-1;)&#123;</span></span><br><span class="line">    <span class="comment">//         if(ranges[i][1] &gt;= ranges[i+1][0])&#123;</span></span><br><span class="line">    <span class="comment">//             if(ranges[i][1] &lt; ranges[i+1][1])&#123;</span></span><br><span class="line">    <span class="comment">//                 ranges[i][1] = ranges[i+1][1];</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             ranges.erase(ranges.begin() + i + 1);</span></span><br><span class="line">    <span class="comment">//             length--;</span></span><br><span class="line">    <span class="comment">//         &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//             i++;</span></span><br><span class="line">    <span class="comment">//             result = result*2%mod;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//       &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //   for(auto range:ranges)&#123;</span></span><br><span class="line">    <span class="comment">//     //     for(auto r:range)&#123;</span></span><br><span class="line">    <span class="comment">//     //         cout &lt;&lt; r &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//     //     &#125;</span></span><br><span class="line">    <span class="comment">//     //     cout &lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//     //   &#125;</span></span><br><span class="line">    <span class="comment">//     //   cout &lt;&lt; length &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     // // 计算大数幂</span></span><br><span class="line">    <span class="comment">//     //   function&lt;long long(long long ,long long)&gt; big_min = [&amp;](long long  a,long long  b)-&gt;long long &#123;</span></span><br><span class="line">    <span class="comment">//     //     if(b==0) return 1;</span></span><br><span class="line">    <span class="comment">//     //     int res = big_min(a,b/2);</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">//     //     if(b%2) </span></span><br><span class="line">    <span class="comment">//     //            return (res%mod)*(res%mod)%mod*a%mod;</span></span><br><span class="line">    <span class="comment">//     //     else </span></span><br><span class="line">    <span class="comment">//     //             return (res%mod*res%mod)%mod;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //   &#125;;</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">//     //   int   result = big_min(2,length)%mod;</span></span><br><span class="line">    <span class="comment">//       return result;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h4 id="380-o1-时间插入-删除和获取随机元素"><a class="anchor" href="#380-o1-时间插入-删除和获取随机元素">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnNlcnQtZGVsZXRlLWdldHJhbmRvbS1vMS8=">380. O (1) 时间插入、删除和获取随机元素</span></h4><p>实现 <code>RandomizedSet</code> 类：</p><ul><li><code>RandomizedSet()</code> 初始化 <code>RandomizedSet</code> 对象</li><li><code>bool insert(int val)</code> 当元素 <code>val</code> 不存在时，向集合中插入该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>bool remove(int val)</code> 当元素 <code>val</code> 存在时，从集合中移除该项，并返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>int getRandom()</code> 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 <strong>相同的概率</strong> 被返回。</li></ul><p>你必须实现类的所有函数，并满足每个函数的 <strong>平均</strong> 时间复杂度为 <code>O(1)</code> 。</p><p><strong>示例：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;RandomizedSet&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;getRandom&quot;</span>, <span class="string">&quot;remove&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;getRandom&quot;</span>]</span><br><span class="line"><span class="string">[[], [1], [2], [2], [], [1], [2], []]</span></span><br><span class="line">输出</span><br><span class="line">[null, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">RandomizedSet randomizedSet = new RandomizedSet();</span><br><span class="line">randomizedSet.<span class="built_in">insert</span>(<span class="number">1</span>); // 向集合中插入 <span class="number">1</span> 。返回 <span class="literal">true</span> 表示 <span class="number">1</span> 被成功地插入。</span><br><span class="line">randomizedSet.<span class="built_in">remove</span>(<span class="number">2</span>); // 返回 <span class="literal">false</span> ，表示集合中不存在 <span class="number">2</span> 。</span><br><span class="line">randomizedSet.<span class="built_in">insert</span>(<span class="number">2</span>); // 向集合中插入 <span class="number">2</span> 。返回 <span class="literal">true</span> 。集合现在包含 [<span class="number">1</span>,<span class="number">2</span>] 。</span><br><span class="line">randomizedSet.getRandom(); // getRandom 应随机返回 <span class="number">1</span> 或 <span class="number">2</span> 。</span><br><span class="line">randomizedSet.<span class="built_in">remove</span>(<span class="number">1</span>); // 从集合中移除 <span class="number">1</span> ，返回 <span class="literal">true</span> 。集合现在包含 [<span class="number">2</span>] 。</span><br><span class="line">randomizedSet.<span class="built_in">insert</span>(<span class="number">2</span>); // <span class="number">2</span> 已在集合中，所以返回 <span class="literal">false</span> 。</span><br><span class="line">randomizedSet.getRandom(); // 由于 <span class="number">2</span> 是集合中唯一的数字，getRandom 总是返回 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li>最多调用 <code>insert</code> 、 <code>remove</code> 和 <code>getRandom</code> 函数 <code>2 * ``105</code> 次</li><li>在调用 <code>getRandom</code> 方法时，数据结构中 <strong>至少存在一个</strong> 元素。</li></ul><p>这道题要求实现一个类，满足插入、删除和获取随机元素操作的平均时间复杂度为 O (1) O (1) O (1)。</p><p>变长数组可以在 O (1) 的时间内完成获取随机元素操作，但是由于无法在 O (1) 的时间内判断元素是否存在，因此不能在 O (1) 的时间内完成插入和删除操作。哈希表可以在 O (1) 的时间内完成插入和删除操作，但是由于无法根据下标定位到特定元素，因此不能在 O (1) 的时间内完成获取随机元素操作。为了满足插入、删除和获取随机元素操作的时间复杂度都是 O (1)，需要将变长数组和哈希表结合，变长数组中存储元素，哈希表中存储每个元素在变长数组中的下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line">      <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 先判断字典中是否有这个数据</span></span><br><span class="line">       <span class="keyword">if</span>(index.<span class="built_in">count</span>(val))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="type">int</span> length = data.<span class="built_in">size</span>();</span><br><span class="line">          data.<span class="built_in">push_back</span>(val);</span><br><span class="line">          index[val] = length;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!index.<span class="built_in">count</span>(val))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 获取该数字的索引</span></span><br><span class="line">        <span class="type">int</span> i = index[val];</span><br><span class="line">        <span class="comment">// 获取数组中最后一个位置的值</span></span><br><span class="line">        <span class="type">int</span> last = data.<span class="built_in">back</span>();</span><br><span class="line">        <span class="comment">// 然后将该位置替换成最后一个值</span></span><br><span class="line">        <span class="comment">// 这样做不会破坏其他位置的索引位置</span></span><br><span class="line">        data[i] = last;</span><br><span class="line">        data.<span class="built_in">pop_back</span>();  <span class="comment">// 弹出最后一个值</span></span><br><span class="line">        <span class="comment">// 更新字典</span></span><br><span class="line">        index[last] = i;</span><br><span class="line">        index.<span class="built_in">erase</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> randomInt = <span class="built_in">rand</span>() % data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> data[randomInt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">      unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;  index;</span><br><span class="line">      </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet* obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;insert(val);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="134-加油站"><a class="anchor" href="#134-加油站">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9nYXMtc3RhdGlvbi8=">134. 加油站</span></h4><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从<span class="number"> 3 </span>号加油站(索引为<span class="number"> 3 </span>处)出发，可获得<span class="number"> 4 </span>升汽油。此时油箱有 =<span class="number"> 0 </span>+<span class="number"> 4 </span>=<span class="number"> 4 </span>升汽油</span><br><span class="line">开往<span class="number"> 4 </span>号加油站，此时油箱有<span class="number"> 4 </span>-<span class="number"> 1 </span>+<span class="number"> 5 </span>=<span class="number"> 8 </span>升汽油</span><br><span class="line">开往<span class="number"> 0 </span>号加油站，此时油箱有<span class="number"> 8 </span>-<span class="number"> 2 </span>+<span class="number"> 1 </span>=<span class="number"> 7 </span>升汽油</span><br><span class="line">开往<span class="number"> 1 </span>号加油站，此时油箱有<span class="number"> 7 </span>-<span class="number"> 3 </span>+<span class="number"> 2 </span>=<span class="number"> 6 </span>升汽油</span><br><span class="line">开往<span class="number"> 2 </span>号加油站，此时油箱有<span class="number"> 6 </span>-<span class="number"> 4 </span>+<span class="number"> 3 </span>=<span class="number"> 5 </span>升汽油</span><br><span class="line">开往<span class="number"> 3 </span>号加油站，你需要消耗<span class="number"> 5 </span>升汽油，正好足够你返回到<span class="number"> 3 </span>号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从<span class="number"> 0 </span>号或<span class="number"> 1 </span>号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从<span class="number"> 2 </span>号加油站出发，可以获得<span class="number"> 4 </span>升汽油。 此时油箱有 =<span class="number"> 0 </span>+<span class="number"> 4 </span>=<span class="number"> 4 </span>升汽油</span><br><span class="line">开往<span class="number"> 0 </span>号加油站，此时油箱有<span class="number"> 4 </span>-<span class="number"> 3 </span>+<span class="number"> 2 </span>=<span class="number"> 3 </span>升汽油</span><br><span class="line">开往<span class="number"> 1 </span>号加油站，此时油箱有<span class="number"> 3 </span>-<span class="number"> 3 </span>+<span class="number"> 3 </span>=<span class="number"> 3 </span>升汽油</span><br><span class="line">你无法返回<span class="number"> 2 </span>号加油站，因为返程需要消耗<span class="number"> 4 </span>升汽油，但是你的油箱只有<span class="number"> 3 </span>升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>gas.length == n</code></li><li><code>cost.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li></ul><p><img data-src="E:%5Ctypora%E5%9B%BE%E7%89%87%5Cimage-20240328223627041.png" alt="image-20240328223627041"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> gas_num = <span class="number">0</span>,cost_num = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length = gas.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> tag = <span class="number">0</span> ,k = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> t = <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">while</span>(tag&lt;length &amp;&amp;!t )&#123;</span><br><span class="line">           tag = <span class="number">0</span>;</span><br><span class="line">           gas_num = <span class="number">0</span>;</span><br><span class="line">           cost_num = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(tag&lt;length)&#123;</span><br><span class="line">               gas_num += gas[k];</span><br><span class="line">               cost_num += cost[k];</span><br><span class="line">               k = k + <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span>(k &gt;= length )&#123;</span><br><span class="line">                   t = <span class="literal">true</span>;</span><br><span class="line">                   k = k%length;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(gas_num&lt;cost_num)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            tag++;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tag&lt;length?<span class="number">-1</span>:k;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2952-需要添加的硬币的最小数量"><a class="anchor" href="#2952-需要添加的硬币的最小数量">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLW51bWJlci1vZi1jb2lucy10by1iZS1hZGRlZC8=">2952. 需要添加的硬币的最小数量</span></h4><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>coins</code> ，表示可用的硬币的面值，以及一个整数 <code>target</code> 。</p><p>如果存在某个 <code>coins</code> 的子序列总和为 <code>x</code> ，那么整数 <code>x</code> 就是一个 <strong>可取得的金额</strong> 。</p><p>返回需要添加到数组中的 <strong>任意面值</strong> 硬币的 <strong>最小数量</strong> ，使范围 <code>[1, target]</code> 内的每个整数都属于 <strong>可取得的金额</strong> 。</p><p>数组的 <strong>子序列</strong> 是通过删除原始数组的一些（<strong>可能不删除</strong>）元素而形成的新的 <strong>非空</strong> 数组，删除过程不会改变剩余元素的相对位置。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1,4,10], target = 19</span><br><span class="line">输出：2</span><br><span class="line">解释：需要添加面值为<span class="number"> 2 </span>和<span class="number"> 8 </span>的硬币各一枚，得到硬币数组 [1,2,4,8,10] 。</span><br><span class="line">可以证明从<span class="number"> 1 </span>到<span class="number"> 19 </span>的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为<span class="number"> 2 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1,4,10,5,7,19], target = 19</span><br><span class="line">输出：1</span><br><span class="line">解释：只需要添加一枚面值为<span class="number"> 2 </span>的硬币，得到硬币数组 [1,2,4,5,7,10,19] 。</span><br><span class="line">可以证明从<span class="number"> 1 </span>到<span class="number"> 19 </span>的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为<span class="number"> 1 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1,1,1], target = 20</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">需要添加面值为<span class="number"> 4 </span>、8 和<span class="number"> 16 </span>的硬币各一枚，得到硬币数组 [1,1,1,4,8,16] 。 </span><br><span class="line">可以证明从<span class="number"> 1 </span>到<span class="number"> 20 </span>的所有整数都可由数组中的硬币组合得到，且需要添加到数组中的硬币数目最小为<span class="number"> 3 </span>。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= target &lt;= 105</code></li><li><code>1 &lt;= coins.length &lt;= 105</code></li><li><code>1 &lt;= coins[i] &lt;= target</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumAddedCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(coins.<span class="built_in">begin</span>(),coins.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> length = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span> ,con_max = <span class="number">1</span> ;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxnum</span><span class="params">(length,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">          <span class="comment">// 没有1 添加1，必须要有1</span></span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; coins[i]!=<span class="number">1</span>)&#123;</span><br><span class="line">              result++;</span><br><span class="line">               <span class="comment">// 如果遍历结束后，仍没有达到要求，也就是在coins数组后面追加的情况</span></span><br><span class="line">               <span class="comment">// 单独处理一下coins长度为1并且需要添加面值为1的情况</span></span><br><span class="line">              <span class="keyword">while</span>(con_max + <span class="number">1</span> &lt; coins[<span class="number">0</span>])&#123;</span><br><span class="line">                 con_max = <span class="number">2</span>*con_max + <span class="number">1</span>;</span><br><span class="line">                 result++;</span><br><span class="line">              &#125;</span><br><span class="line">              con_max = con_max + coins[<span class="number">0</span>];</span><br><span class="line">              maxnum[<span class="number">0</span>] = con_max;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(i&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(maxnum[i<span class="number">-1</span>] + <span class="number">1</span> &gt;= coins[i])&#123;</span><br><span class="line">                  maxnum[i] = maxnum[i<span class="number">-1</span>] + coins[i];</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="type">int</span> k = maxnum[i<span class="number">-1</span>];</span><br><span class="line">                  <span class="keyword">while</span>(k + <span class="number">1</span> &lt; coins[i])&#123;</span><br><span class="line">                      k = <span class="number">2</span>*k<span class="number">+1</span>;</span><br><span class="line">                      result++;</span><br><span class="line">                  &#125;</span><br><span class="line">                  maxnum[i] = k + coins[i];</span><br><span class="line">              &#125;</span><br><span class="line">             </span><br><span class="line">           &#125;</span><br><span class="line">            <span class="comment">// 每次承接以下当下的最大能表示的值，这样最后那个最大表示的值能够保留下来</span></span><br><span class="line">            <span class="comment">// 以供循环结束再继续进行判断进行判断</span></span><br><span class="line">           con_max =maxnum[i];</span><br><span class="line">           <span class="keyword">if</span>(con_max &gt;= target)&#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(con_max &lt; target)&#123;</span><br><span class="line">            con_max = <span class="number">2</span>*con_max<span class="number">+1</span>;</span><br><span class="line">            result++;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="331-验证二叉树的前序序列化"><a class="anchor" href="#331-验证二叉树的前序序列化">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92ZXJpZnktcHJlb3JkZXItc2VyaWFsaXphdGlvbi1vZi1hLWJpbmFyeS10cmVlLw==">331. 验证二叉树的前序序列化</span></h4><p>序列化二叉树的一种方法是使用 <strong>前序遍历</strong> 。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code> 。</p><p><img data-src="https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg" alt="img"></p><p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code> ，其中 <code>#</code> 代表一个空节点。</p><p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p><p><strong>保证</strong> 每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>'#'</code> 。</p><p>你可以认为输入格式总是有效的</p><ul><li>例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</li></ul><p>** 注意：** 不允许重建树。</p><p><strong>示例 1:</strong></p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = &quot;9,3,4,<span class="punctuation">#</span>,<span class="punctuation">#</span>,1,<span class="punctuation">#</span>,<span class="punctuation">#</span>,2,<span class="punctuation">#</span>,6,<span class="punctuation">#</span>,<span class="punctuation">#</span>&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">preorder</span> = <span class="string">&quot;1,#&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="attr">preorder</span> = <span class="string">&quot;9,#,#,1&quot;</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 104</code></li><li><code>preorder</code> 由以逗号 <code>“，”</code> 分隔的 <code>[0,100]</code> 范围内的整数和 <code>“#”</code> 组成</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidSerialization</span><span class="params">(string preorder)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; mystack;</span><br><span class="line">        <span class="type">int</span> length = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历，然后依次按照先弹出子节点然后再弹出父节点，判断最后是否能让栈空</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt; length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[k]==<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">if</span>(preorder[k]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!mystack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                       mystack.<span class="built_in">top</span>()++;</span><br><span class="line">                    &#125;</span><br><span class="line">                   </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此时是数字，因为此时已经知道他是数字了，只用同步长度就可以了</span></span><br><span class="line">                    <span class="comment">// 不用知道数字是多少</span></span><br><span class="line">                    <span class="keyword">while</span>(k&lt;length &amp;&amp; preorder[k]!=<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    mystack.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 最关键的一步，这一步，我们就是检查堆顶是否已经有子节点全部弹出的，这样自己就可以弹出了</span></span><br><span class="line">            <span class="comment">// 也就是堆顶是否等于2，等于2就说明有两个子节点都弹出了，弹出之后要循环的更新自己的父节点的值，如果父节点也满足情况了，</span></span><br><span class="line">            <span class="comment">// 就继续弹出，依次进行。</span></span><br><span class="line">              <span class="keyword">while</span>(!mystack.<span class="built_in">empty</span>() &amp;&amp; mystack.<span class="built_in">top</span>()==<span class="number">2</span>)&#123;</span><br><span class="line">                mystack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!mystack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    mystack.<span class="built_in">top</span>()++;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(mystack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mystack.<span class="built_in">empty</span>()&amp;&amp;k==length<span class="number">-1</span>?<span class="literal">true</span>:<span class="literal">false</span>; </span><br><span class="line">         </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2192-有向无环图中一个节点的所有祖先"><a class="anchor" href="#2192-有向无环图中一个节点的所有祖先">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hbGwtYW5jZXN0b3JzLW9mLWEtbm9kZS1pbi1hLWRpcmVjdGVkLWFjeWNsaWMtZ3JhcGgv">2192. 有向无环图中一个节点的所有祖先</span></h4><p>给你一个正整数 <code>n</code> ，它表示一个 <strong>有向无环图</strong> 中节点的数目，节点编号为 <code>0</code> 到 <code>n - 1</code> （包括两者）。</p><p>给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [fromi, toi]</code> 表示图中一条从 <code>fromi</code> 到 <code>toi</code> 的单向边。</p><p>请你返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个节点的所有 <strong>祖先</strong> ，这些祖先节点 <strong>升序</strong> 排序。</p><p>如果 <code>u</code> 通过一系列边，能够到达 <code>v</code> ，那么我们称节点 <code>u</code> 是节点 <code>v</code> 的 <strong>祖先</strong> 节点。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2019/12/12/e1.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]</span><br><span class="line">输出：[[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]</span><br><span class="line">解释：</span><br><span class="line">上图为输入所对应的图。</span><br><span class="line">- 节点<span class="number"> 0 </span>，1 和<span class="number"> 2 </span>没有任何祖先。</span><br><span class="line">- 节点<span class="number"> 3 </span>有<span class="number"> 2 </span>个祖先<span class="number"> 0 </span>和<span class="number"> 1 </span>。</span><br><span class="line">- 节点<span class="number"> 4 </span>有<span class="number"> 2 </span>个祖先<span class="number"> 0 </span>和<span class="number"> 2 </span>。</span><br><span class="line">- 节点<span class="number"> 5 </span>有<span class="number"> 3 </span>个祖先<span class="number"> 0 </span>，1 和<span class="number"> 3 </span>。</span><br><span class="line">- 节点<span class="number"> 6 </span>有<span class="number"> 5 </span>个祖先<span class="number"> 0 </span>，1 ，2 ，3 和<span class="number"> 4 </span>。</span><br><span class="line">- 节点<span class="number"> 7 </span>有<span class="number"> 4 </span>个祖先<span class="number"> 0 </span>，1 ，2 和<span class="number"> 3 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2019/12/12/e2.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, edgeList = <span class="comment">[<span class="comment">[0,1]</span>,<span class="comment">[0,2]</span>,<span class="comment">[0,3]</span>,<span class="comment">[0,4]</span>,<span class="comment">[1,2]</span>,<span class="comment">[1,3]</span>,<span class="comment">[1,4]</span>,<span class="comment">[2,3]</span>,<span class="comment">[2,4]</span>,<span class="comment">[3,4]</span>]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[]</span>,<span class="comment">[0]</span>,<span class="comment">[0,1]</span>,<span class="comment">[0,1,2]</span>,<span class="comment">[0,1,2,3]</span>]</span></span><br><span class="line">解释：</span><br><span class="line">上图为输入所对应的图。</span><br><span class="line">- 节点 0 没有任何祖先。</span><br><span class="line">- 节点 1 有 1 个祖先 0 。</span><br><span class="line">- 节点 2 有 2 个祖先 0 和 1 。</span><br><span class="line">- 节点 3 有 3 个祖先 0 ，1 和 2 。</span><br><span class="line">- 节点 4 有 4 个祖先 0 ，1 ，2 和 3 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>0 &lt;= edges.length &lt;= min(2000, n * (n - 1) / 2)</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= fromi, toi &lt;= n - 1</code></li><li><code>fromi != toi</code></li><li>图中不会有重边。</li><li>图是 <strong>有向</strong> 且 <strong>无环</strong> 的。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">getAncestors</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="comment">// 重新构造图结构,因为是无权图，所以直接构建每个节点的前驱节点</span></span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; former(n); </span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">behind</span>(n);   <span class="comment">// 后驱节点</span></span><br><span class="line">        <span class="comment">// 能够到达i节点的前驱结点</span></span><br><span class="line">        vector&lt;set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">result</span>(n);             <span class="comment">// 利用有序集合进行去重和排序</span></span><br><span class="line">        <span class="comment">// 更新构造前驱和后继数据机构</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:edges)&#123;</span><br><span class="line">               former[e[<span class="number">1</span>]].<span class="built_in">insert</span>(e[<span class="number">0</span>]);</span><br><span class="line">               behind[e[<span class="number">0</span>]].<span class="built_in">insert</span>(e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; first;</span><br><span class="line">        <span class="comment">// 寻找没有前驱节点的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(former[i].<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">                first.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从小到大依次弹出没有前驱的节点</span></span><br><span class="line">        <span class="keyword">while</span>(!first.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> top = first.<span class="built_in">top</span>();</span><br><span class="line">            first.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 弹出一个之后就遍历他的后继节点</span></span><br><span class="line">            <span class="comment">// 顺便将该top节点与后继节点之间的边去掉</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;b:behind[top])&#123;</span><br><span class="line">                former[b].<span class="built_in">erase</span>(top);</span><br><span class="line">                <span class="comment">// 根据能够到达该后继节点的前驱，就能到达该后继节点的原则</span></span><br><span class="line">                <span class="comment">// 该后继节点的祖先就是  (前驱结点的祖先集合 + 前驱节点)</span></span><br><span class="line">                result[b].<span class="built_in">insert</span>(result[top].<span class="built_in">begin</span>(),result[top].<span class="built_in">end</span>());</span><br><span class="line">                result[b].<span class="built_in">insert</span>(top);</span><br><span class="line">                <span class="comment">// 检查此时的后继节点是否满足没有了前驱的要求</span></span><br><span class="line">                <span class="comment">// 如果满足就加入优先队列</span></span><br><span class="line">                <span class="comment">// 也就是拓扑排序的遍历过程</span></span><br><span class="line">                <span class="keyword">if</span>(former[b].<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    first.<span class="built_in">push</span>(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将内置数据结构变为vector</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            res[i].<span class="built_in">insert</span>(res[i].<span class="built_in">end</span>(),result[i].<span class="built_in">begin</span>(),result[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">                </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="1026-节点与其祖先之间的最大差值"><a class="anchor" href="#1026-节点与其祖先之间的最大差值">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRpZmZlcmVuY2UtYmV0d2Vlbi1ub2RlLWFuZC1hbmNlc3Rvci8=">1026. 节点与其祖先之间的最大差值</span></h4><p>给定二叉树的根节点 <code>root</code> ，找出存在于 <strong>不同</strong> 节点 <code>A</code> 和 <code>B</code> 之间的最大值 <code>V</code> ，其中 <code>V = |A.val - B.val|</code> ，且 <code>A</code> 是 <code>B</code> 的祖先。</p><p>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/11/09/tmp-tree.jpg" alt="img"></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">8</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">6</span>,null,<span class="number">14</span>,null,null,<span class="number">4</span>,<span class="number">7</span>,<span class="number">13</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释： </span><br><span class="line">我们有大量的节点与其祖先的差值，其中一些如下：</span><br><span class="line">|<span class="type">8</span> - <span class="number">3</span>| <span class="type">= 5</span></span><br><span class="line">|<span class="type">3</span> - <span class="number">7</span>| <span class="type">= 4</span></span><br><span class="line">|<span class="type">8</span> - <span class="number">1</span>| <span class="type">= 7</span></span><br><span class="line">|<span class="type">10</span> - <span class="number">13</span>| <span class="type">= 3</span></span><br><span class="line">在所有可能的差值中，最大值 <span class="number">7</span> 由 |<span class="type">8</span> - <span class="number">1</span>| <span class="type">= 7</span> 得出。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/11/09/tmp-tree-1.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">0</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在 <code>2</code> 到 <code>5000</code> 之间。</li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> result = <span class="number">-1</span>;</span><br><span class="line">       function&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(TreeNode*root)&gt; maxAnces = [&amp;](TreeNode*root)-&gt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&#123;</span><br><span class="line">           <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;<span class="number">1e5</span><span class="number">+1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">           <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> &#123;root-&gt;val,root-&gt;val&#125;;</span><br><span class="line">           <span class="type">int</span> left=<span class="number">1e5</span><span class="number">+1</span>,right=<span class="number">-1</span>;</span><br><span class="line">          <span class="comment">// 通过左右子树更新左右边界</span></span><br><span class="line">           pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; leftchild = <span class="built_in">maxAnces</span>(root-&gt;left);</span><br><span class="line">           right = <span class="built_in">max</span>(right,leftchild.second);</span><br><span class="line">           left = <span class="built_in">min</span>(left,leftchild.first);</span><br><span class="line">          </span><br><span class="line">           pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; rightchild = <span class="built_in">maxAnces</span>(root-&gt;right);</span><br><span class="line">           right = <span class="built_in">max</span>(right,rightchild.second);</span><br><span class="line">           left = <span class="built_in">min</span>(left,rightchild.first);</span><br><span class="line">        </span><br><span class="line">           <span class="comment">// 更新完左右边界之后，根据子树的左右边界，比较最大的那个，实时更新维护最大差值</span></span><br><span class="line">           result = <span class="built_in">max</span>(result,<span class="built_in">abs</span>(root-&gt;val - left));</span><br><span class="line">           result = <span class="built_in">max</span>(result,<span class="built_in">abs</span>(root-&gt;val - right));</span><br><span class="line">           <span class="comment">// 把根节点考虑进去，进一步更新真正的左右边界，以供父节点参考</span></span><br><span class="line">           left = <span class="built_in">min</span>(root-&gt;val,left);</span><br><span class="line">           right = <span class="built_in">max</span>(root-&gt;val,right);</span><br><span class="line">           <span class="keyword">return</span> &#123;left,right&#125;;</span><br><span class="line">           </span><br><span class="line">       &#125;;</span><br><span class="line">       pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; dis = <span class="built_in">maxAnces</span>(root);</span><br><span class="line">       <span class="comment">//cout &lt;&lt;dis.first &lt;&lt; &quot; &quot; &lt;&lt; dis.second &lt;&lt;endl;</span></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1702-修改后的最大二进制字符串"><a class="anchor" href="#1702-修改后的最大二进制字符串">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWJpbmFyeS1zdHJpbmctYWZ0ZXItY2hhbmdlLw==">1702. 修改后的最大二进制字符串</span></h4><p>给你一个二进制字符串 <code>binary</code> ，它仅有 <code>0</code> 或者 <code>1</code> 组成。你可以使用下面的操作任意次对它进行修改：</p><ul><li><p>操作 1 ：如果二进制串包含子字符串</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;00&quot;</span></span><br></pre></td></tr></table></figure><p>，你可以用</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure><p>将其替换。</p><ul><li>比方说， <code>&quot;**00**010&quot; -&gt; &quot;**10**010&quot;</code></li></ul></li><li><p>操作 2 ：如果二进制串包含子字符串</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure><p>，你可以用</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;01&quot;</span></span><br></pre></td></tr></table></figure><p>将其替换。</p><ul><li>比方说， <code>&quot;000**10**&quot; -&gt; &quot;000**01**&quot;</code></li></ul></li></ul><p>请你返回执行上述操作任意次以后能得到的 <strong>最大二进制字符串</strong> 。如果二进制字符串 <code>x</code> 对应的十进制数字大于二进制字符串 <code>y</code> 对应的十进制数字，那么我们称二进制字符串 <code>x</code> 大于二进制字符串 <code>y</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：binary = <span class="string">&quot;000110&quot;</span></span><br><span class="line">输出：<span class="string">&quot;111011&quot;</span></span><br><span class="line">解释：一个可行的转换为：</span><br><span class="line"><span class="string">&quot;000110&quot;</span> -&gt; <span class="string">&quot;000101&quot;</span> </span><br><span class="line"><span class="string">&quot;000101&quot;</span> -&gt; <span class="string">&quot;100101&quot;</span> </span><br><span class="line"><span class="string">&quot;100101&quot;</span> -&gt; <span class="string">&quot;110101&quot;</span> </span><br><span class="line"><span class="string">&quot;110101&quot;</span> -&gt; <span class="string">&quot;110011&quot;</span> </span><br><span class="line"><span class="string">&quot;110011&quot;</span> -&gt; <span class="string">&quot;111011&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：binary <span class="operator">=</span> <span class="string">&quot;01&quot;</span></span><br><span class="line">输出：<span class="string">&quot;01&quot;</span></span><br><span class="line">解释：<span class="string">&quot;01&quot;</span> 没办法进行任何转换。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= binary.length &lt;= 105</code></li><li><code>binary</code> 仅包含 <code>'0'</code> 和 <code>'1'</code> 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">maximumBinaryString</span><span class="params">(string binary)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 假设遍历到当前字符之前，result 中已经是binary[0:i-1] 中结果了</span></span><br><span class="line">       <span class="comment">// 有两种情况</span></span><br><span class="line">         <span class="comment">// 当前字符是1</span></span><br><span class="line">             <span class="comment">// 直接添加，因为不管前面是如何的字符串，都是直接添加</span></span><br><span class="line">         <span class="comment">// 当前字符是0</span></span><br><span class="line">            <span class="comment">// 此时就应该判断一下</span></span><br><span class="line">               <span class="comment">// 寻找一下result中的零的位置 </span></span><br><span class="line">                  <span class="comment">// 如果零的位置不是最后，就将零替换为1 ，零位置后一个位置上的数变为零，并为下一次零的位置记录一下，下一次就不用遍历了</span></span><br><span class="line">                  <span class="comment">// 如果零的位置是最后一个那就变为1，然后直接添加零就好了</span></span><br><span class="line">       <span class="type">int</span> length = binary.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">if</span>(length&lt;=<span class="number">1</span>) <span class="keyword">return</span> binary;</span><br><span class="line">       string result = binary.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt;  <span class="title">dp</span><span class="params">(length,<span class="number">-1</span>)</span></span>;</span><br><span class="line">       <span class="keyword">if</span>(result[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(binary[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                result += binary[i];</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="comment">// 最后一位是零的话，那前面肯定没有零了</span></span><br><span class="line">              <span class="keyword">if</span>(result[result.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    result[result.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    result += binary[i];</span><br><span class="line">                    dp[i] = i;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="keyword">if</span>(dp[i<span class="number">-1</span>] !=<span class="number">-1</span>)&#123;</span><br><span class="line">                     result[dp[i<span class="number">-1</span>]] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                     result[dp[i<span class="number">-1</span>] + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                     dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                     result += <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     result += <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                     dp[i] = i;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    if(s==&quot;00&quot;)&#123;</span></span><br><span class="line">    <span class="comment">//        result = &quot;10&quot;;</span></span><br><span class="line">    <span class="comment">//        if(length==2) return result;</span></span><br><span class="line">    <span class="comment">//        while(i&lt;length)&#123;</span></span><br><span class="line">    <span class="comment">//             if(binary[i]==&#x27;1&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//                 result+= binary[i];                       </span></span><br><span class="line">    <span class="comment">//             &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                 if(result[result.size()-1]==&#x27;1&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//                    int j = result.size()-1;</span></span><br><span class="line">    <span class="comment">//                    while(j&gt;=0)&#123;</span></span><br><span class="line">    <span class="comment">//                     if(result[j] == &#x27;0&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//                         result[j] = &#x27;1&#x27;;</span></span><br><span class="line">    <span class="comment">//                         result[j+1] = &#x27;0&#x27;;</span></span><br><span class="line">    <span class="comment">//                         break;</span></span><br><span class="line">    <span class="comment">//                      &#125;</span></span><br><span class="line">    <span class="comment">//                      j--;</span></span><br><span class="line">    <span class="comment">//                   &#125;</span></span><br><span class="line">    <span class="comment">//                     result += &#x27;1&#x27;; </span></span><br><span class="line">    <span class="comment">//                 &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                     result[result.size()-1] = &#x27;1&#x27;;</span></span><br><span class="line">    <span class="comment">//                     result += binary[i];</span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             i++;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;else if(s==&quot;01&quot;)&#123;</span></span><br><span class="line">    <span class="comment">//        result = &quot;01&quot;;</span></span><br><span class="line">    <span class="comment">//        if(length==2) return result;</span></span><br><span class="line">    <span class="comment">//         while(i&lt;length)&#123;</span></span><br><span class="line">    <span class="comment">//             if(binary[i]==&#x27;1&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//                 result+= binary[i];</span></span><br><span class="line">    <span class="comment">//             &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                 int j = result.size()-1;</span></span><br><span class="line">    <span class="comment">//                 while(j&gt;=0)&#123;</span></span><br><span class="line">    <span class="comment">//                     if(result[j] == &#x27;0&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//                         result[j] = &#x27;1&#x27;;</span></span><br><span class="line">    <span class="comment">//                         result[j+1] = &#x27;0&#x27;;</span></span><br><span class="line">    <span class="comment">//                         break;</span></span><br><span class="line">    <span class="comment">//                     &#125;</span></span><br><span class="line">    <span class="comment">//                     j--;</span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//                 result += &#x27;1&#x27;;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             i++;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    &#125;else if(s==&quot;10&quot;)&#123;</span></span><br><span class="line">    <span class="comment">//        result = &quot;10&quot;;</span></span><br><span class="line">    <span class="comment">//         if(length==2) return result;</span></span><br><span class="line">    <span class="comment">//          while(i&lt;length)&#123;</span></span><br><span class="line">    <span class="comment">//             if(binary[i]==&#x27;1&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//                 result+= binary[i];</span></span><br><span class="line">    <span class="comment">//             &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                 if(result[result.size()-1]==&#x27;1&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//                    int j = result.size()-1;</span></span><br><span class="line">    <span class="comment">//                    while(j&gt;=0)&#123;</span></span><br><span class="line">    <span class="comment">//                     if(result[j] == &#x27;0&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//                         result[j] = &#x27;1&#x27;;</span></span><br><span class="line">    <span class="comment">//                         result[j+1] = &#x27;0&#x27;;</span></span><br><span class="line">    <span class="comment">//                         break;</span></span><br><span class="line">    <span class="comment">//                      &#125;</span></span><br><span class="line">    <span class="comment">//                      j--;</span></span><br><span class="line">    <span class="comment">//                   &#125;</span></span><br><span class="line">    <span class="comment">//                 result += &#x27;1&#x27;; </span></span><br><span class="line">    <span class="comment">//                 &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                     result[result.size()-1] = &#x27;1&#x27;;</span></span><br><span class="line">    <span class="comment">//                     result += binary[i];</span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             i++;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;else if(s==&quot;11&quot;)&#123;</span></span><br><span class="line">    <span class="comment">//         result = &quot;11&quot;;</span></span><br><span class="line">    <span class="comment">//          if(length==2) return result;</span></span><br><span class="line">    <span class="comment">//           while(i&lt;length)&#123;</span></span><br><span class="line">    <span class="comment">//             if(binary[i]==&#x27;1&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//                 result+= binary[i];</span></span><br><span class="line">    <span class="comment">//             &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                 if(result[result.size()-1] = &#x27;0&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//                     result[result.size()-1] = &#x27;1&#x27;;</span></span><br><span class="line">    <span class="comment">//                     result += &#x27;0&#x27;;</span></span><br><span class="line">    <span class="comment">//                     continue;</span></span><br><span class="line">    <span class="comment">//                 &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                    int j = result.size()-1;</span></span><br><span class="line">    <span class="comment">//                    while(j&gt;=0)&#123;</span></span><br><span class="line">    <span class="comment">//                     if(result[j] == &#x27;0&#x27;)&#123;</span></span><br><span class="line">    <span class="comment">//                         result[j] = &#x27;1&#x27;;</span></span><br><span class="line">    <span class="comment">//                         result[j+1] = &#x27;0&#x27;;</span></span><br><span class="line">    <span class="comment">//                         break;</span></span><br><span class="line">    <span class="comment">//                         j--;</span></span><br><span class="line">    <span class="comment">//                      &#125;</span></span><br><span class="line">    <span class="comment">//                    &#125;</span></span><br><span class="line">    <span class="comment">//                   result += &#x27;1&#x27;; </span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">       <span class="comment">//return result;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2007-从双倍数组中还原原数组"><a class="anchor" href="#2007-从双倍数组中还原原数组">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW9yaWdpbmFsLWFycmF5LWZyb20tZG91YmxlZC1hcnJheS8=">2007. 从双倍数组中还原原数组</span></h4><p>一个整数数组 <code>original</code> 可以转变成一个 <strong>双倍</strong> 数组 <code>changed</code> ，转变方式为将 <code>original</code> 中每个元素 <strong>值乘以 2</strong> 加入数组中，然后将所有元素 <strong>随机打乱</strong> 。</p><p>给你一个数组 <code>changed</code> ，如果 <code>change</code> 是 <strong>双倍</strong> 数组，那么请你返回 <code>original</code> 数组，否则请返回空数组。 <code>original</code> 的元素可以以 <strong>任意</strong> 顺序返回。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：changed = [1,3,4,2,6,8]</span><br><span class="line">输出：[1,3,4]</span><br><span class="line">解释：一个可能的 original 数组为 [1,3,4] :</span><br><span class="line">- 将<span class="number"> 1 </span>乘以<span class="number"> 2 </span>，得到<span class="number"> 1 </span>*<span class="number"> 2 </span>=<span class="number"> 2 </span>。</span><br><span class="line">- 将<span class="number"> 3 </span>乘以<span class="number"> 2 </span>，得到<span class="number"> 3 </span>*<span class="number"> 2 </span>=<span class="number"> 6 </span>。</span><br><span class="line">- 将<span class="number"> 4 </span>乘以<span class="number"> 2 </span>，得到<span class="number"> 4 </span>*<span class="number"> 2 </span>=<span class="number"> 8 </span>。</span><br><span class="line">其他可能的原数组方案为 [4,3,1] 或者 [3,1,4] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：changed = <span class="comment">[6,3,0,1]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br><span class="line">解释：changed 不是一个双倍数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：changed = <span class="comment">[1]</span></span><br><span class="line">输出：<span class="comment">[]</span></span><br><span class="line">解释：changed 不是一个双倍数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= changed.length &lt;= 105</code></li><li><code>0 &lt;= changed[i] &lt;= 105</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOriginalArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; changed)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 首先进行排序，为了让原数能在倍数之前被遍历到</span></span><br><span class="line">      <span class="built_in">sort</span>(changed.<span class="built_in">begin</span>(),changed.<span class="built_in">end</span>());</span><br><span class="line">      <span class="comment">// 记录每一个数出现的次数</span></span><br><span class="line">      unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; count;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> c:changed)&#123;</span><br><span class="line">          count[c]++;</span><br><span class="line">      &#125;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">      <span class="comment">// 遍历寻找每一个单数，然后找到倍数是否存在</span></span><br><span class="line">      <span class="comment">// 如果存在，就将单数和倍数个数减一，并且将单数放入结果数组中</span></span><br><span class="line">      <span class="comment">// 如果遇见那个倍数不存在，就直接返回空数组</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> c:changed)&#123;</span><br><span class="line">         <span class="comment">// 检查当前数是否还存在</span></span><br><span class="line">         <span class="keyword">if</span>(count[c]==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         count[c]--;</span><br><span class="line">         <span class="keyword">if</span>(count[<span class="number">2</span>*c]==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">         &#125;</span><br><span class="line">         count[<span class="number">2</span>*c]--;</span><br><span class="line">         result.<span class="built_in">emplace_back</span>(c);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="39-组合总和"><a class="anchor" href="#39-组合总和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0v">39. 组合总和</span></h4><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和<span class="number"> 3 </span>可以形成一组候选，2 +<span class="number"> 2 </span>+<span class="number"> 3 </span>=<span class="number"> 7 </span>。注意<span class="number"> 2 </span>可以使用多次。</span><br><span class="line">7 也是一个候选，<span class="number"> 7 </span>=<span class="number"> 7 </span>。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2,3,5]</span>, target = 8</span><br><span class="line">输出: <span class="comment">[<span class="comment">[2,2,2,2]</span>,<span class="comment">[2,3,3]</span>,<span class="comment">[3,5]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = <span class="comment">[2]</span>, target = 1</span><br><span class="line">输出: <span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="comment">// 递归加回溯</span></span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;)&gt; dfs =[&amp;](<span class="type">int</span> sum,vector&lt;<span class="type">int</span>&gt; conList)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                result.<span class="built_in">emplace_back</span>(conList);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;can:candidates)&#123;</span><br><span class="line">                <span class="comment">// 为了不产生组合重复，保证每一个元素出现的次序</span></span><br><span class="line">                <span class="keyword">if</span>(conList.<span class="built_in">size</span>() == <span class="number">0</span> || can &gt;= conList[conList.<span class="built_in">size</span>() <span class="number">-1</span>])&#123;</span><br><span class="line">                conList.<span class="built_in">emplace_back</span>(can);</span><br><span class="line">                <span class="built_in">dfs</span>(sum + can , conList);</span><br><span class="line">                <span class="comment">// 回溯</span></span><br><span class="line">                conList.<span class="built_in">erase</span>(conList.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; conList;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,conList);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h4 id="216-组合总和-iii"><a class="anchor" href="#216-组合总和-iii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb21iaW5hdGlvbi1zdW0taWlpLw==">216. 组合总和 III</span></h4><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字 1 到 9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: k = <span class="number">3</span>, n = <span class="number">7</span></span><br><span class="line">输出: <span class="string">[[1,2,4]]</span></span><br><span class="line">解释:</span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> = <span class="number">7</span></span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: k = 3, n = 9</span><br><span class="line">输出: [[1,2,6], [1,3,5], [2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">1 +<span class="number"> 2 </span>+<span class="number"> 6 </span>= 9</span><br><span class="line">1 +<span class="number"> 3 </span>+<span class="number"> 5 </span>= 9</span><br><span class="line">2 +<span class="number"> 3 </span>+<span class="number"> 4 </span>= 9</span><br><span class="line">没有其他符合的组合了。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: k = 4, n = 1</span></span><br><span class="line"><span class="section">输出: []</span></span><br><span class="line"><span class="section">解释: 不存在有效的组合。</span></span><br><span class="line">在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>2 &lt;= k &lt;= 9</code></li><li><code>1 &lt;= n &lt;= 60</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">         vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">         <span class="comment">// 递归 加 回溯</span></span><br><span class="line">         function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;)&gt; dfs = [&amp;](<span class="type">int</span> conSum,<span class="type">int</span> i,vector&lt;<span class="type">int</span>&gt; conList)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;k || conSum&gt;n)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==k &amp;&amp; conSum == n)&#123;</span><br><span class="line">                result.<span class="built_in">emplace_back</span>(conList);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(conList.<span class="built_in">size</span>() == <span class="number">0</span> || j&gt;conList[conList.<span class="built_in">size</span>() - <span class="number">1</span>])&#123;</span><br><span class="line">                    conList.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">                    <span class="built_in">dfs</span>(conSum + j,i<span class="number">+1</span>,conList);</span><br><span class="line">                    <span class="comment">// 回溯</span></span><br><span class="line">                    conList.<span class="built_in">erase</span>(conList.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         vector&lt;<span class="type">int</span>&gt; conList;</span><br><span class="line">         <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,conList);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1052-爱生气的书店老板"><a class="anchor" href="#1052-爱生气的书店老板">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncnVtcHktYm9va3N0b3JlLW93bmVyLw==">1052. 爱生气的书店老板</span></h4><p>有一个书店老板，他的书店开了 <code>n</code> 分钟。每分钟都有一些顾客进入这家商店。给定一个长度为 <code>n</code> 的整数数组 <code>customers</code> ，其中 <code>customers[i]</code> 是在第 <code>i</code> 分钟开始时进入商店的顾客数量，所有这些顾客在第 <code>i</code> 分钟结束后离开。</p><p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code> ，否则 <code>grumpy[i] = 0</code> 。</p><p>当书店老板生气时，那一分钟的顾客就会不满意，若老板不生气则顾客是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>minutes</code> 分钟不生气，但却只能使用一次。</p><p>请你返回 <em>这一天营业下来，最多有多少客户能够感到满意</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3</span><br><span class="line">输出：16</span><br><span class="line">解释：书店老板在最后<span class="number"> 3 </span>分钟保持冷静。</span><br><span class="line">感到满意的最大客户数量 =<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 1 </span>+<span class="number"> 7 </span>+<span class="number"> 5 </span>= 16.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：customers = <span class="comment">[1]</span>, grumpy = <span class="comment">[0]</span>, minutes = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == customers.length == grumpy.length</code></li><li><code>1 &lt;= minutes &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= customers[i] &lt;= 1000</code></li><li><code>grumpy[i] == 0 or 1</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfied</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; customers, vector&lt;<span class="type">int</span>&gt;&amp; grumpy, <span class="type">int</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前缀和，将加和分成三部分</span></span><br><span class="line">        <span class="type">int</span> length = customers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left_anger_cunstomers</span><span class="params">(length)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right_anger_cunstomers</span><span class="params">(length)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">con_sum</span><span class="params">(length)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                con_sum[i] = customers[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                con_sum[i] = con_sum[i<span class="number">-1</span>] + customers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(minutes &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">return</span> con_sum[length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                left_anger_cunstomers[i] = customers[i];</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left_anger_cunstomers[i] = left_anger_cunstomers[i<span class="number">-1</span>] + customers[i];</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                left_anger_cunstomers[i] = <span class="number">0</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left_anger_cunstomers[i] = left_anger_cunstomers[i<span class="number">-1</span>];</span><br><span class="line">              &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[i] == <span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(i==length<span class="number">-1</span>)&#123;</span><br><span class="line">                right_anger_cunstomers[i] = customers[i];</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right_anger_cunstomers[i] = right_anger_cunstomers[i<span class="number">+1</span>] + customers[i];</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(i==length<span class="number">-1</span>)&#123;</span><br><span class="line">                right_anger_cunstomers[i] = <span class="number">0</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right_anger_cunstomers[i] = right_anger_cunstomers[i<span class="number">+1</span>];</span><br><span class="line">              &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=length-minutes;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">              result = <span class="built_in">max</span>(result,con_sum[minutes<span class="number">-1</span>]+right_anger_cunstomers[minutes]);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==length-minutes)&#123;</span><br><span class="line">              result = <span class="built_in">max</span>(result,left_anger_cunstomers[i<span class="number">-1</span>] + con_sum[i+minutes<span class="number">-1</span>]-con_sum[i<span class="number">-1</span>]);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              result = <span class="built_in">max</span>(result,left_anger_cunstomers[i<span class="number">-1</span>] + con_sum[i+minutes<span class="number">-1</span>]-con_sum[i<span class="number">-1</span>]+right_anger_cunstomers[i+minutes]);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2385-感染二叉树需要的总时间"><a class="anchor" href="#2385-感染二叉树需要的总时间">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hbW91bnQtb2YtdGltZS1mb3ItYmluYXJ5LXRyZWUtdG8tYmUtaW5mZWN0ZWQv">2385. 感染二叉树需要的总时间</span></h4><p>给你一棵二叉树的根节点 <code>root</code> ，二叉树中节点的值 <strong>互不相同</strong> 。另给你一个整数 <code>start</code> 。在第 <code>0</code> 分钟，<strong>感染</strong> 将会从值为 <code>start</code> 的节点开始爆发。</p><p>每分钟，如果节点满足以下全部条件，就会被感染：</p><ul><li>节点此前还没有感染。</li><li>节点与一个已感染节点相邻。</li></ul><p>返回感染整棵树需要的分钟数 *。*</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2022/06/25/image-20220625231744-1.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,5,3,null,4,10,6,9,2], start = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：节点按以下过程被感染：</span><br><span class="line">- 第<span class="number"> 0 </span>分钟：节点 3</span><br><span class="line">- 第<span class="number"> 1 </span>分钟：节点 1、10、6</span><br><span class="line">- 第<span class="number"> 2 </span>分钟：节点5</span><br><span class="line">- 第<span class="number"> 3 </span>分钟：节点 4</span><br><span class="line">- 第<span class="number"> 4 </span>分钟：节点<span class="number"> 9 </span>和 2</span><br><span class="line">感染整棵树需要<span class="number"> 4 </span>分钟，所以返回<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2022/06/25/image-20220625231812-2.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1], start = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：第<span class="number"> 0 </span>分钟，树中唯一一个节点处于感染状态，返回<span class="number"> 0 </span>。 </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目在范围 <code>[1, 105]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li>每个节点的值 <strong>互不相同</strong></li><li>树中必定存在值为 <code>start</code> 的节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">amountOfTime</span><span class="params">(TreeNode* root, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// int left_num = 0 ;</span></span><br><span class="line">        <span class="comment">// int right_num = 0;</span></span><br><span class="line">        <span class="comment">// int left_depth = 0;</span></span><br><span class="line">        <span class="comment">// int right_depth = 0;</span></span><br><span class="line">        <span class="comment">// function&lt;int(TreeNode*)&gt; depth = [&amp;](TreeNode* root)-&gt;int&#123;</span></span><br><span class="line">           </span><br><span class="line">        <span class="comment">//     if(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span></span><br><span class="line">        <span class="comment">//         return 1;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     int result = 0;</span></span><br><span class="line">        <span class="comment">//     if(root-&gt;left) result = max(result,depth(root-&gt;left));</span></span><br><span class="line">        <span class="comment">//     if(root-&gt;right) result = max(result,depth(root-&gt;right));</span></span><br><span class="line">        <span class="comment">//     return result + 1;</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">// function&lt;void(TreeNode*,int&amp;,int&amp;)&gt; cengxu = [&amp;](TreeNode * root,int&amp; con_depth,int&amp; depth)-&gt;void&#123;</span></span><br><span class="line">        <span class="comment">//     queue&lt;pair&lt;TreeNode*,int&gt;&gt; que;</span></span><br><span class="line">        <span class="comment">//     que.push(&#123;root,1&#125;);</span></span><br><span class="line">        <span class="comment">//     while(!que.empty())&#123;</span></span><br><span class="line">        <span class="comment">//       pair&lt;TreeNode*,int&gt; top = que.front();</span></span><br><span class="line">        <span class="comment">//       que.pop();</span></span><br><span class="line">        <span class="comment">//       depth = top.second;</span></span><br><span class="line">        <span class="comment">//       if(top.first-&gt;val == start)  con_depth = top.second ;</span></span><br><span class="line">        <span class="comment">//       if(top.first-&gt;left) que.push(&#123;top.first-&gt;left,top.second + 1&#125;);</span></span><br><span class="line">        <span class="comment">//       if(top.first-&gt;right) que.push(&#123;top.first-&gt;right,top.second + 1&#125;);</span></span><br><span class="line">        <span class="comment">//     &#125; </span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">// if(root-&gt;left) cengxu(root-&gt;left,left_num,left_depth);</span></span><br><span class="line">        <span class="comment">// if(root-&gt;right) cengxu(root-&gt;right,right_num,right_depth);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;depth:&quot; &lt;&lt; left_depth &lt;&lt; &quot; &quot; &lt;&lt; right_depth &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;num:&quot; &lt;&lt; left_num &lt;&lt; &quot; &quot; &lt;&lt; right_num &lt;&lt;endl; </span></span><br><span class="line">        <span class="comment">// return max(left_depth - left_num + right_num,right_depth-right_num + left_num);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 图结构</span></span><br><span class="line">        <span class="comment">// 深度优先搜索将二叉树构建成图结构，然后进行广度优先搜索</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; graph;</span><br><span class="line">        function&lt;<span class="type">void</span>(TreeNode *)&gt; dfs = [&amp;](TreeNode *node) &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode *child : vector&lt;TreeNode *&gt;&#123;node-&gt;left, node-&gt;right&#125;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    graph[node-&gt;val].<span class="built_in">push_back</span>(child-&gt;val);</span><br><span class="line">                    graph[child-&gt;val].<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                    <span class="built_in">dfs</span>(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 广度优先搜索</span></span><br><span class="line">        queue&lt;vector&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;start, <span class="number">0</span>&#125;);</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">        visited.<span class="built_in">insert</span>(start);</span><br><span class="line">        <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> arr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> nodeVal = arr[<span class="number">0</span>];</span><br><span class="line">            time = arr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> childVal: graph[nodeVal]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited.<span class="built_in">count</span>(childVal)) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;childVal, time + <span class="number">1</span>&#125;);</span><br><span class="line">                    visited.<span class="built_in">insert</span>(childVal);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="994-腐烂的橘子"><a class="anchor" href="#994-腐烂的橘子">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb3R0aW5nLW9yYW5nZXMv">994. 腐烂的橘子</span></h4><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p><p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code> </em>。</p><p><strong>示例 1：</strong></p><p><strong><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" alt="img"></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[2,1,1],[1,1,0],[0,1,1]]</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[2,1,1],[0,1,1],[1,0,1]]</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：左下角的橘子（第 <span class="number">2</span> 行， 第 <span class="number">0</span> 列）永远不会腐烂，因为腐烂只会发生在 <span class="number">4</span> 个方向上。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[0,2]]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：因为 <span class="number">0</span> 分钟时已经没有新鲜橘子了，所以答案就是 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>grid[i][j]</code> 仅为 <code>0</code> 、 <code>1</code> 或 <code>2</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//   观察到对于所有的腐烂橘子，其实它们在广度优先搜索上是等价于同一层的节点的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设这些腐烂橘子刚开始是新鲜的，而有一个腐烂橘子(我们令其为超级源点)会在下一秒把这些橘子都变腐烂，而这个腐烂橘子刚开始在的时间是 −1 ，那么按照广度优先搜索的算法，下一分钟也就是第 0 分钟的时候，这个腐烂橘子会把它们都变成腐烂橘子，然后继续向外拓展，所以其实这些腐烂橘子是同一层的节点。那么在广度优先搜索的时候，我们将这些腐烂橘子都放进队列里进行广度优先搜索即可，最后每个新鲜橘子被腐烂的最短时间 dis[x][y]其实是以这个超级源点的腐烂橘子为起点的广度优先搜索得到的结果。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了确认是否所有新鲜橘子都被腐烂，可以记录一个变量 cnt表示当前网格中的新鲜橘子数，广度优先搜索的时候如果有新鲜橘子被腐烂，则 cnt=cnt−1，最后搜索结束时如果 cnt大于 0 ，说明有新鲜橘子没被腐烂，返回 −1 ，否则返回所有新鲜橘子被腐烂的时间的最大值即可，也可以在广度优先搜索的过程中把已腐烂的新鲜橘子的值由 1 改为 2，最后看网格中是否由值为 1 即新鲜的橘子即可。</span></span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">      queue&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">      <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m= grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">      <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">      vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">used</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m,<span class="number">0</span>));</span><br><span class="line">      <span class="comment">// 首先将所有腐烂节点添加到队列中，相当于广度优先搜索中的同一层节点</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(&#123;i,j,<span class="number">0</span>&#125;);</span><br><span class="line">                used[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 记录正常节点的个数</span></span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; X = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; Y =&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">      <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 在指定层开始进行广度优先搜索</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; cnt&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; q = que.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">int</span> x = q[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> y = q[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> step = q[<span class="number">2</span>];</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> next_x = x + X[i];</span><br><span class="line">            <span class="type">int</span> next_y = y + Y[i];</span><br><span class="line">            <span class="keyword">if</span>(next_x &gt;=n || next_x &lt; <span class="number">0</span> || next_y &lt; <span class="number">0</span> || next_y&gt;=m || used[next_x][next_y] == <span class="number">1</span> || grid[next_x][next_y] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">push</span>(&#123;next_x,next_y,step + <span class="number">1</span>&#125;);</span><br><span class="line">            used[next_x][next_y] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(grid[next_x][next_y]==<span class="number">1</span>)&#123;</span><br><span class="line">                cnt--;</span><br><span class="line">                result = step + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; cnt &lt;&lt;endl;</span><br><span class="line">      <span class="keyword">return</span> cnt == <span class="number">0</span> ? result : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="1953-你可以工作的最大周数"><a class="anchor" href="#1953-你可以工作的最大周数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLW51bWJlci1vZi13ZWVrcy1mb3Itd2hpY2gteW91LWNhbi13b3JrLw==">1953. 你可以工作的最大周数</span></h4><p>给你 <code>n</code> 个项目，编号从 <code>0</code> 到 <code>n - 1</code> 。同时给你一个整数数组 <code>milestones</code> ，其中每个 <code>milestones[i]</code> 表示第 <code>i</code> 个项目中的阶段任务数量。</p><p>你可以按下面两个规则参与项目中的工作：</p><ul><li>每周，你将会完成 <strong>某一个</strong> 项目中的 <strong>恰好一个</strong> 阶段任务。你每周都 <strong>必须</strong> 工作。</li><li>在 <strong>连续的</strong> 两周中，你 <strong>不能</strong> 参与并完成同一个项目中的两个阶段任务。</li></ul><p>一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 <strong>停止工作</strong> 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</p><p>返回在不违反上面规则的情况下你 <strong>最多</strong> 能工作多少周。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：milestones = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">- 第<span class="number"> 1 </span>周，你参与并完成项目<span class="number"> 0 </span>中的一个阶段任务。</span><br><span class="line">- 第<span class="number"> 2 </span>周，你参与并完成项目<span class="number"> 2 </span>中的一个阶段任务。</span><br><span class="line">- 第<span class="number"> 3 </span>周，你参与并完成项目<span class="number"> 1 </span>中的一个阶段任务。</span><br><span class="line">- 第<span class="number"> 4 </span>周，你参与并完成项目<span class="number"> 2 </span>中的一个阶段任务。</span><br><span class="line">- 第<span class="number"> 5 </span>周，你参与并完成项目<span class="number"> 1 </span>中的一个阶段任务。</span><br><span class="line">- 第<span class="number"> 6 </span>周，你参与并完成项目<span class="number"> 2 </span>中的一个阶段任务。</span><br><span class="line">总周数是<span class="number"> 6 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：milestones = [5,2,1]</span><br><span class="line">输出：7</span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">- 第<span class="number"> 1 </span>周，你参与并完成项目<span class="number"> 0 </span>中的一个阶段任务。</span><br><span class="line">- 第<span class="number"> 2 </span>周，你参与并完成项目<span class="number"> 1 </span>中的一个阶段任务。</span><br><span class="line">- 第<span class="number"> 3 </span>周，你参与并完成项目<span class="number"> 0 </span>中的一个阶段任务。</span><br><span class="line">- 第<span class="number"> 4 </span>周，你参与并完成项目<span class="number"> 1 </span>中的一个阶段任务。</span><br><span class="line">- 第<span class="number"> 5 </span>周，你参与并完成项目<span class="number"> 0 </span>中的一个阶段任务。</span><br><span class="line">- 第<span class="number"> 6 </span>周，你参与并完成项目<span class="number"> 2 </span>中的一个阶段任务。</span><br><span class="line">- 第<span class="number"> 7 </span>周，你参与并完成项目<span class="number"> 0 </span>中的一个阶段任务。</span><br><span class="line">总周数是<span class="number"> 7 </span>。</span><br><span class="line">注意，你不能在第<span class="number"> 8 </span>周参与完成项目<span class="number"> 0 </span>中的最后一个阶段任务，因为这会违反规则。</span><br><span class="line">因此，项目<span class="number"> 0 </span>中会有一个阶段任务维持未完成状态。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == milestones.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= milestones[i] &lt;= 109</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">numberOfWeeks</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; milestones)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目的就是在一个有重复的数组中，找到一个最长的序列，并且要满足相同的值不能连续出现</span></span><br><span class="line">    <span class="comment">//    long long result = 0;</span></span><br><span class="line">    <span class="comment">// //    unordered_multiset&lt;int&gt;  data;</span></span><br><span class="line">    <span class="comment">//    int n =  milestones.size();</span></span><br><span class="line">    <span class="comment">//    unordered_set&lt;int&gt;  myset;</span></span><br><span class="line">    <span class="comment">//    int sum = accumulate(milestones.begin(),milestones.end(),0);</span></span><br><span class="line">    <span class="comment">//    for(int i = 0;i&lt;n;i++)&#123;</span></span><br><span class="line">    <span class="comment">//      myset.insert(i);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// //    for(int i = 0;i&lt;n;i++)&#123;</span></span><br><span class="line">    <span class="comment">// //        for(int j = 0;j&lt;milestones[i];j++)&#123;</span></span><br><span class="line">    <span class="comment">// //            data.insert(i);</span></span><br><span class="line">    <span class="comment">// //        &#125;</span></span><br><span class="line">    <span class="comment">// //    &#125;</span></span><br><span class="line">    <span class="comment">// //    vector&lt;int&gt;  meo( n + 1,-1);</span></span><br><span class="line">    <span class="comment">//    function&lt;long long (int)&gt;  dfs = [&amp;](int x)-&gt;long long&#123;</span></span><br><span class="line">    <span class="comment">//     //   if(x&gt;=0 &amp;&amp; meo[x]!=-1)&#123;</span></span><br><span class="line">    <span class="comment">//     //     return meo[x];</span></span><br><span class="line">    <span class="comment">//     //   &#125;</span></span><br><span class="line">    <span class="comment">//       if(myset.empty() || sum == 1 &amp;&amp; *myset.begin()==x)&#123;</span></span><br><span class="line">    <span class="comment">//           return 0;</span></span><br><span class="line">    <span class="comment">//       &#125;</span></span><br><span class="line">    <span class="comment">//       long long result = 0;</span></span><br><span class="line">    <span class="comment">//       for(int i = 0;i&lt;n;i++)&#123;</span></span><br><span class="line">    <span class="comment">//         // auto it = data.find(i);</span></span><br><span class="line">    <span class="comment">//         // if(it == data.end() || x==i)&#123;</span></span><br><span class="line">    <span class="comment">//         //     continue;</span></span><br><span class="line">    <span class="comment">//         //  &#125;</span></span><br><span class="line">    <span class="comment">//         if(milestones[i]==0 || i==x)&#123;</span></span><br><span class="line">    <span class="comment">//             continue;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         milestones[i]--;</span></span><br><span class="line">    <span class="comment">//         sum ++;</span></span><br><span class="line">    <span class="comment">//         if(milestones[i]==0)&#123;</span></span><br><span class="line">    <span class="comment">//             myset.erase(i);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         result = max(result, 1 + dfs(i));</span></span><br><span class="line">    <span class="comment">//         // data.insert(i);</span></span><br><span class="line">    <span class="comment">//         sum++;</span></span><br><span class="line">    <span class="comment">//         milestones[i]++;</span></span><br><span class="line">    <span class="comment">//         myset.insert(i);</span></span><br><span class="line">    <span class="comment">//       &#125;</span></span><br><span class="line">    <span class="comment">//     //   if(x&gt;=0)&#123;</span></span><br><span class="line">    <span class="comment">//     //     meo[x] = result;</span></span><br><span class="line">    <span class="comment">//     //   &#125;</span></span><br><span class="line">    <span class="comment">//       return result;</span></span><br><span class="line">    <span class="comment">//    &#125;;</span></span><br><span class="line">    <span class="comment">//    return dfs(-1);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 耗时最长工作所需周数</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> longest = *<span class="built_in">max_element</span>(milestones.<span class="built_in">begin</span>(), milestones.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 其余工作共计所需周数</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> rest = <span class="built_in">accumulate</span>(milestones.<span class="built_in">begin</span>(), milestones.<span class="built_in">end</span>(), <span class="number">0LL</span>) - longest;</span><br><span class="line">        <span class="keyword">if</span> (longest &gt; rest + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 此时无法完成所耗时最长的工作</span></span><br><span class="line">            <span class="keyword">return</span> rest * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时可以完成所有工作</span></span><br><span class="line">            <span class="keyword">return</span> longest + rest;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="826-安排工作以达到最大收益"><a class="anchor" href="#826-安排工作以达到最大收益">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tb3N0LXByb2ZpdC1hc3NpZ25pbmctd29yay8=">826. 安排工作以达到最大收益</span></h4><p>你有 <code>n</code> 个工作和 <code>m</code> 个工人。给定三个数组： <code>difficulty</code> , <code>profit</code> 和 <code>worker</code> ，其中:</p><ul><li><code>difficulty[i]</code> 表示第 <code>i</code> 个工作的难度， <code>profit[i]</code> 表示第 <code>i</code> 个工作的收益。</li><li><code>worker[i]</code> 是第 <code>i</code> 个工人的能力，即该工人只能完成难度小于等于 <code>worker[i]</code> 的工作。</li></ul><p>每个工人 <strong>最多</strong> 只能安排 <strong>一个</strong> 工作，但是一个工作可以 <strong>完成多次</strong> 。</p><ul><li>举个例子，如果 3 个工人都尝试完成一份报酬为 <code>$1</code> 的同样工作，那么总收益为 <code>$3</code> 。如果一个工人不能完成任何工作，他的收益为 <code>$0</code> 。</li></ul><p>返回 <em>在把工人分配到工作岗位后，我们所能获得的最大利润</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: difficulty = [<span class="number">2,4,6,8</span>,<span class="number">10</span>], profit = [<span class="number">10,20,30,40</span>,<span class="number">50</span>], worker = [<span class="number">4,5,6,7</span>]</span><br><span class="line">输出: <span class="number">100</span> </span><br><span class="line">解释: 工人被分配的工作难度是 [<span class="number">4,4,6,6</span>] ，分别获得 [<span class="number">20,20,30,30</span>] 的收益。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: difficulty = <span class="comment">[85,47,57]</span>, profit = <span class="comment">[24,66,99]</span>, worker = <span class="comment">[40,25,25]</span></span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>n == difficulty.length</code></li><li><code>n == profit.length</code></li><li><code>m == worker.length</code></li><li><code>1 &lt;= n, m &lt;= 104</code></li><li><code>1 &lt;= difficulty[i], profit[i], worker[i] &lt;= 105</code></li></ul><p>方法一：排序 + 双指针<br>思路与算法</p><p>我们首先对工人按照能力大小排序，对工作按照难度排序。</p><p>我们使用「双指针」的方法，一个指针指向工人数组，一个指向任务数组，从低难度的任务开始遍历。对于每个工人，我们继续遍历任务，直到难度大于其能力，并把可以完成任务中的最大利润更新到结果中。</p><p>最后返回所有工人能得到的利润总和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfitAssignment</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; difficulty, vector&lt;<span class="type">int</span>&gt;&amp; profit, vector&lt;<span class="type">int</span>&gt;&amp; worker)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// map&lt;int,int&gt; tasks;</span></span><br><span class="line">        <span class="comment">// int n = difficulty.size();</span></span><br><span class="line">        <span class="comment">// for(int i = 0;i&lt;n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     tasks[difficulty[i]] = profit[i];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// for(auto&amp;[key ,value]:tasks)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; key &lt;&lt;&quot; :&quot; &lt;&lt; value&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;------&quot;&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// int result = 0;</span></span><br><span class="line">        <span class="comment">// for(auto w:worker)&#123;</span></span><br><span class="line">        <span class="comment">//     auto it=tasks.find(w);</span></span><br><span class="line">        <span class="comment">//     int price = 0;</span></span><br><span class="line">        <span class="comment">//     if(it!=tasks.end())&#123;</span></span><br><span class="line">        <span class="comment">//         it++;</span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//          it = tasks.lower_bound(w);</span></span><br><span class="line">        <span class="comment">//          it;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//     for(auto i = tasks.begin();i!=it;i++)&#123;</span></span><br><span class="line">        <span class="comment">//         price = max(price,i-&gt;second);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; w &lt;&lt; &quot;|&quot;&lt;&lt; it-&gt;first &lt;&lt; &quot;:&quot;&lt;&lt;it-&gt;second &lt;&lt;&quot;   &quot;&lt;&lt; price &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//     result += price;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return result;</span></span><br><span class="line"></span><br><span class="line">         vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; jobs;</span><br><span class="line">        <span class="type">int</span> n = profit.<span class="built_in">size</span>(), res = <span class="number">0</span>, i = <span class="number">0</span>, best = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            jobs.<span class="built_in">emplace_back</span>(difficulty[j], profit[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(jobs.<span class="built_in">begin</span>(), jobs.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(worker.<span class="built_in">begin</span>(), worker.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w : worker) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; w &gt;= jobs[i].first) &#123;</span><br><span class="line">                best = <span class="built_in">max</span>(best, jobs[i].second);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += best;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1535-找出数组游戏的赢家"><a class="anchor" href="#1535-找出数组游戏的赢家">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS13aW5uZXItb2YtYW4tYXJyYXktZ2FtZS8=">1535. 找出数组游戏的赢家</span></h4><p>给你一个由 <strong>不同</strong> 整数组成的整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p><p>每回合游戏都在数组的前两个元素（即 <code>arr[0]</code> 和 <code>arr[1]</code> ）之间进行。比较 <code>arr[0]</code> 与 <code>arr[1]</code> 的大小，较大的整数将会取得这一回合的胜利并保留在位置 <code>0</code> ，较小的整数移至数组的末尾。当一个整数赢得 <code>k</code> 个连续回合时，游戏结束，该整数就是比赛的 <strong>赢家</strong> 。</p><p>返回赢得比赛的整数。</p><p>题目数据 <strong>保证</strong> 游戏存在赢家。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [2,1,3,5,4,6,7], k = 2</span><br><span class="line">输出：5</span><br><span class="line">解释：一起看一下本场游戏每回合的情况：</span><br><span class="line"></span><br><span class="line">因此将进行<span class="number"> 4 </span>回合比赛，其中<span class="number"> 5 </span>是赢家，因为它连胜<span class="number"> 2 </span>回合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：arr </span>=<span class="string"> [3,2,1], k = 10</span></span><br><span class="line"><span class="string">输出：3</span></span><br><span class="line"><span class="string">解释：3 将会在前 10 个回合中连续获胜。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1,9,8,2</span>,<span class="number">3,7,6,4</span>,<span class="number">5</span>], k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1,11,22,33</span>,<span class="number">44,55,66,77</span>,<span class="number">88</span>,<span class="number">99</span>], k = <span class="number">1000000000</span></span><br><span class="line">输出：<span class="number">99</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^6</code></li><li><code>arr</code> 所含的整数 <strong>各不相同</strong> 。</li><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getWinner</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 想法：遍历寻找并且记录当下连胜的回合数，并且</span></span><br><span class="line">        <span class="comment">// 根据判断结果，实时更新回合数</span></span><br><span class="line">        <span class="comment">// 可以认为一旦完全比完一组，就找到了最大值</span></span><br><span class="line">        <span class="comment">// 此时不管进行多少个轮回都是这个最大值，因此我们最多就进行一轮遍历就好了</span></span><br><span class="line">        <span class="comment">// 要么在一轮遍历之前就满足k 的条件，要么一轮结束后，num 就是最大值，之后</span></span><br><span class="line">        <span class="comment">// 不论怎么比，都是数组最大值，返回就行了</span></span><br><span class="line">        <span class="type">int</span>  num = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> index =<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> win = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; n)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[index]&gt;=num)&#123;</span><br><span class="line">              num = arr[index];</span><br><span class="line">              win = <span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              win++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(win&gt;=k)&#123;</span><br><span class="line">                  <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">           index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2831-找出最长等值子数组"><a class="anchor" href="#2831-找出最长等值子数组">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1sb25nZXN0LWVxdWFsLXN1YmFycmF5Lw==">2831. 找出最长等值子数组</span></h4><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>如果子数组中所有元素都相等，则认为子数组是一个 <strong>等值子数组</strong> 。注意，空数组是 <strong>等值子数组</strong> 。</p><p>从 <code>nums</code> 中删除最多 <code>k</code> 个元素后，返回可能的最长等值子数组的长度。</p><p><strong>子数组</strong> 是数组中一个连续且可能为空的元素序列。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,2,3,1,3], k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：最优的方案是删除下标<span class="number"> 2 </span>和下标<span class="number"> 4 </span>的元素。</span><br><span class="line">删除后，nums 等于 [1, 3, 3, 3] 。</span><br><span class="line">最长等值子数组从 i =<span class="number"> 1 </span>开始到 j =<span class="number"> 3 </span>结束，长度等于<span class="number"> 3 </span>。</span><br><span class="line">可以证明无法创建更长的等值子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2,2,1,1], k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：最优的方案是删除下标<span class="number"> 2 </span>和下标<span class="number"> 3 </span>的元素。 </span><br><span class="line">删除后，nums 等于 [1, 1, 1, 1] 。 </span><br><span class="line">数组自身就是等值子数组，长度等于<span class="number"> 4 </span>。 </span><br><span class="line">可以证明无法创建更长的等值子数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= nums.length</code></li><li><code>0 &lt;= k &lt;= nums.length</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestEqualSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本思路：就是区间[l,r]中，如果某一个等值元素的个数为 num </span></span><br><span class="line">    <span class="comment">// 如果在该区间能够满足最长子数组的长度为num的话，必须满足 r - l + 1 - num &lt;= k</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; statis;</span><br><span class="line">        <span class="comment">// 统计每一个不同的等值元素的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            statis[nums[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 统计完成之后，然后根据每一个等值元素，通过滑动窗口的方式</span></span><br><span class="line">        <span class="comment">// 从前到后遍历满足条件的窗口内的最长等值子数组的长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_,value]:statis)&#123;</span><br><span class="line">            <span class="comment">// 对每一个等值元素，进行遍历寻找最长等值子数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j=<span class="number">0</span>;i&lt;value.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="comment">//如果当前窗口不满足条件，即 r - l + 1 - num &gt; k</span></span><br><span class="line">                <span class="comment">// 此时应该调整左边界，使其刚好满足条件</span></span><br><span class="line">                <span class="keyword">while</span>(value[i] - value[j] - (i-j)&gt;k)&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此时这个窗口就是满足条件的窗口,就可以实时更新结果result的值</span></span><br><span class="line">                result = <span class="built_in">max</span>(result,i-j<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1673-找出最具竞争力的子序列"><a class="anchor" href="#1673-找出最具竞争力的子序列">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1tb3N0LWNvbXBldGl0aXZlLXN1YnNlcXVlbmNlLw==">1673. 找出最具竞争力的子序列</span></h4><p>给你一个整数数组 <code>nums</code> 和一个正整数 <code>k</code> ，返回长度为 <code>k</code> 且最具 <strong>竞争力</strong> 的 <code>nums</code> 子序列。</p><p>数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。</p><p>在子序列 <code>a</code> 和子序列 <code>b</code> 第一个不相同的位置上，如果 <code>a</code> 中的数字小于 <code>b</code> 中对应的数字，那么我们称子序列 <code>a</code> 比子序列 <code>b</code> （相同长度下）更具 <strong>竞争力</strong> 。 例如， <code>[1,3,4]</code> 比 <code>[1,3,5]</code> 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， <code>4</code> 小于 <code>5</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,5,2,6]</span>, k = 2</span><br><span class="line">输出：<span class="comment">[2,6]</span></span><br><span class="line">解释：在所有可能的子序列集合 &#123;<span class="comment">[3,5]</span>, <span class="comment">[3,2]</span>, <span class="comment">[3,6]</span>, <span class="comment">[5,2]</span>, <span class="comment">[5,6]</span>, <span class="comment">[2,6]</span>&#125; 中，<span class="comment">[2,6]</span> 最具竞争力。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2,4,3,3</span>,<span class="number">5,4,9,6</span>], k = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">2,3,3,4</span>]</span><br></pre></td></tr></table></figure><p>​</p><p>** 提示： **</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 109</code></li><li>`1 &lt;= k &lt;= nums.length</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mostCompetitive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自己的想法，就是保存每一个区间的最小值以及最靠近左边界的下标</span></span><br><span class="line">        <span class="comment">// 之后根据k，选择必须满足的区间，通过已经整理好的dp数组，进行取值</span></span><br><span class="line">        <span class="comment">// 不断地迭代更新满足条件的区间的左边界，进行解决</span></span><br><span class="line">        <span class="comment">// int n = nums.size();</span></span><br><span class="line">        <span class="comment">//   vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; dp(n,vector&lt;pair&lt;int,int&gt;&gt;(n));</span></span><br><span class="line">        <span class="comment">//   for(int i = 0;i&lt;n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = i;j&lt;n;j++)&#123;</span></span><br><span class="line">        <span class="comment">//         if(i==j)&#123;</span></span><br><span class="line">        <span class="comment">//             dp[i][j].first = nums[i];</span></span><br><span class="line">        <span class="comment">//             dp[i][j].second = i;</span></span><br><span class="line">        <span class="comment">//         &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//             if(dp[i][j-1].first &lt;= nums[j])&#123;</span></span><br><span class="line">        <span class="comment">//                 dp[i][j].first = dp[i][j-1].first;</span></span><br><span class="line">        <span class="comment">//                 dp[i][j].second = dp[i][j-1].second; </span></span><br><span class="line">        <span class="comment">//             &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//                 dp[i][j].first = nums[j];</span></span><br><span class="line">        <span class="comment">//                 dp[i][j].second = j; </span></span><br><span class="line">        <span class="comment">//             &#125;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">//   int index = 0;</span></span><br><span class="line">        <span class="comment">//   vector&lt;int&gt; result;</span></span><br><span class="line">        <span class="comment">//   while(k)&#123;</span></span><br><span class="line">        <span class="comment">//      result.emplace_back(dp[index][n-k].first);</span></span><br><span class="line">        <span class="comment">//      index = dp[index][n-k].second + 1;</span></span><br><span class="line">        <span class="comment">//      k--;</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">//   return result;</span></span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">// n - i + res.size() 解释： n - i 说明此时还有n - i 个数字能选</span></span><br><span class="line">            <span class="comment">// n - i + res.size() &gt;  k 说明栈中的元素加上还能选择的元素，多于要求的子序列的长度，即能够选的元素还够，就可以舍弃一些不优秀的</span></span><br><span class="line">            <span class="comment">// 说明此时如果有更好的（就是更小的），可以让更小的入栈</span></span><br><span class="line">            <span class="comment">// 而且还有一点，就是如果相等的话，就选更靠近左边界的（即下标更小的，这样能够覆盖所有可能，不会忽略掉中间的可能结果，就是让后续的选择更多一点）</span></span><br><span class="line">            <span class="keyword">while</span>(!res.<span class="built_in">empty</span>() &amp;&amp; n - i + res.<span class="built_in">size</span>() &gt; k &amp;&amp; res.<span class="built_in">back</span>() &gt; nums[i])&#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将此时的值，加入到栈中</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">resize</span>(k);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1738-找出第-k-大的异或坐标值"><a class="anchor" href="#1738-找出第-k-大的异或坐标值">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWt0aC1sYXJnZXN0LXhvci1jb29yZGluYXRlLXZhbHVlLw==">1738. 找出第 K 大的异或坐标值</span></h4><p>给你一个二维矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，矩阵大小为 <code>m x n</code> 由非负整数组成。</p><p>矩阵中坐标 <code>(a, b)</code> 的 <strong>值</strong> 可由对所有满足 <code>0 &lt;= i &lt;= a &lt; m</code> 且 <code>0 &lt;= j &lt;= b &lt; n</code> 的元素 <code>matrix[i][j]</code> （<strong>下标从 0 开始计数</strong>）执行异或运算得到。</p><p>请你找出 <code>matrix</code> 的所有坐标中第 <code>k</code> 大的值（<strong> <code>k</code> 的值从 1 开始计数</strong>）。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = <span class="string">[[5,2],[1,6]]</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：坐标 (<span class="number">0</span>,<span class="number">1</span>) 的值是 <span class="number">5</span> XOR <span class="number">2</span> = <span class="number">7</span> ，为最大的值。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = <span class="string">[[5,2],[1,6]]</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：坐标 (<span class="number">0</span>,<span class="number">0</span>) 的值是 <span class="number">5</span> = <span class="number">5</span> ，为第 <span class="number">2</span> 大的值。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = <span class="string">[[5,2],[1,6]]</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：坐标 (<span class="number">1</span>,<span class="number">0</span>) 的值是 <span class="number">5</span> XOR <span class="number">1</span> = <span class="number">4</span> ，为第 <span class="number">3</span> 大的值。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[5,2],[1,6]], k = 4</span><br><span class="line">输出：0</span><br><span class="line">解释：坐标 (1,1) 的值是<span class="number"> 5 </span>XOR<span class="number"> 2 </span>XOR<span class="number"> 1 </span>XOR<span class="number"> 6 </span>=<span class="number"> 0 </span>，为第<span class="number"> 4 </span>大的值。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 1000</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 106</code></li><li><code>1 &lt;= k &lt;= m * n</code></li></ul><h4 id="2028-找出缺失的观测数据"><a class="anchor" href="#2028-找出缺失的观测数据">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1pc3Npbmctb2JzZXJ2YXRpb25zLw==">2028. 找出缺失的观测数据</span></h4><p>现有一份 <code>n + m</code> 次投掷单个 <strong>六面</strong> 骰子的观测数据，骰子的每个面从 <code>1</code> 到 <code>6</code> 编号。观测数据中缺失了 <code>n</code> 份，你手上只拿到剩余 <code>m</code> 次投掷的数据。幸好你有之前计算过的这 <code>n + m</code> 次投掷数据的 <strong>平均值</strong> 。</p><p>给你一个长度为 <code>m</code> 的整数数组 <code>rolls</code> ，其中 <code>rolls[i]</code> 是第 <code>i</code> 次观测的值。同时给你两个整数 <code>mean</code> 和 <code>n</code> 。</p><p>返回一个长度为 <code>n</code> 的数组，包含所有缺失的观测数据，且满足这 <code>n + m</code> 次投掷的 <strong>平均值</strong> 是 <code>mean</code> 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。</p><p><code>k</code> 个数字的 <strong>平均值</strong> 为这些数字求和后再除以 <code>k</code> 。</p><p>注意 <code>mean</code> 是一个整数，所以 <code>n + m</code> 次投掷的总和需要被 <code>n + m</code> 整除。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [3,2,4,3], mean = 4, n = 2</span><br><span class="line">输出：[6,6]</span><br><span class="line">解释：所有 n + m 次投掷的平均值是 (3 +<span class="number"> 2 </span>+<span class="number"> 4 </span>+<span class="number"> 3 </span>+<span class="number"> 6 </span>+ 6) /<span class="number"> 6 </span>=<span class="number"> 4 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [1,5,6], mean = 3, n = 4</span><br><span class="line">输出：[2,3,2,2]</span><br><span class="line">解释：所有 n + m 次投掷的平均值是 (1 +<span class="number"> 5 </span>+<span class="number"> 6 </span>+<span class="number"> 2 </span>+<span class="number"> 3 </span>+<span class="number"> 2 </span>+ 2) /<span class="number"> 7 </span>=<span class="number"> 3 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = <span class="comment">[1,2,3,4]</span>, mean = 6, n = 4</span><br><span class="line">输出：<span class="comment">[]</span></span><br><span class="line">解释：无论丢失的 4 次数据是什么，平均值都不可能是 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">1</span>], mean = <span class="number">3</span>, <span class="built_in">n</span> = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">5</span>]</span><br><span class="line">解释：所有 <span class="built_in">n</span> + m 次投掷的平均值是 (<span class="number">1</span> + <span class="number">5</span>) / <span class="number">2</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == rolls.length</code></li><li><code>1 &lt;= n, m &lt;= 105</code></li><li><code>1 &lt;= rolls[i], mean &lt;= 6</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">missingRolls</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rolls, <span class="type">int</span> mean, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> m = rolls.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> sum = mean*(m + n) - <span class="built_in">accumulate</span>(rolls.<span class="built_in">begin</span>(),rolls.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">       <span class="comment">//  首先判断不可能的情况</span></span><br><span class="line">       <span class="keyword">if</span>(n*<span class="number">6</span> &lt; sum || n*<span class="number">1</span> &gt; sum)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">       result.<span class="built_in">resize</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 因为已经知道了有解，所以遍历固定为 n 的数组，然后通过轮番加一操作，找到一组解</span></span><br><span class="line">       <span class="keyword">while</span>(sum!=<span class="number">0</span>)&#123;</span><br><span class="line">          result[i]++;</span><br><span class="line">          sum--;</span><br><span class="line">          i = (i<span class="number">+1</span>)%n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    这么简单的题为什么会有递归回溯的思想，真是脑子瓦塔了</span></span><br><span class="line">    <span class="comment">//    bool tag = false;</span></span><br><span class="line">    <span class="comment">//    function&lt;void(int,int)&gt; dfs = [&amp;](int con_sum,int x)-&gt;void&#123;</span></span><br><span class="line">    <span class="comment">//        if(!tag)&#123;</span></span><br><span class="line">    <span class="comment">//         if(con_sum &lt; 0  || (x &lt;= 0 &amp;&amp; con_sum &gt; 0 ))&#123;</span></span><br><span class="line">    <span class="comment">//            return ;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if(con_sum == 0 &amp;&amp; x==0)&#123;</span></span><br><span class="line">    <span class="comment">//              tag = true;</span></span><br><span class="line">    <span class="comment">//              return;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         for(int i = 1;i&lt;=6;i++)&#123;</span></span><br><span class="line">    <span class="comment">//              result.emplace_back(i);</span></span><br><span class="line">    <span class="comment">//              dfs(con_sum - i,x-1);</span></span><br><span class="line">    <span class="comment">//              if(!tag)&#123;</span></span><br><span class="line">    <span class="comment">//                 result.pop_back();</span></span><br><span class="line">    <span class="comment">//              &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                 return;</span></span><br><span class="line">    <span class="comment">//              &#125;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;  </span></span><br><span class="line">    <span class="comment">//    &#125;;</span></span><br><span class="line">    <span class="comment">//    dfs(sum,n);</span></span><br><span class="line">    <span class="comment">//    return result;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2982-找出出现至少三次的最长特殊子字符串-ii"><a class="anchor" href="#2982-找出出现至少三次的最长特殊子字符串-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWxvbmdlc3Qtc3BlY2lhbC1zdWJzdHJpbmctdGhhdC1vY2N1cnMtdGhyaWNlLWlpLw==">2982. 找出出现至少三次的最长特殊子字符串 II</span></h4><p>给你一个仅由小写英文字母组成的字符串 <code>s</code> 。</p><p>如果一个字符串仅由单一字符组成，那么它被称为 <strong>特殊</strong> 字符串。例如，字符串 <code>&quot;abc&quot;</code> 不是特殊字符串，而字符串 <code>&quot;ddd&quot;</code> 、 <code>&quot;zz&quot;</code> 和 <code>&quot;f&quot;</code> 是特殊字符串。</p><p>返回在 <code>s</code> 中出现 <strong>至少三次</strong> 的 <strong>最长特殊子字符串</strong> 的长度，如果不存在出现至少三次的特殊子字符串，则返回 <code>-1</code> 。</p><p><strong>子字符串</strong> 是字符串中的一个连续 <strong>非空</strong> 字符序列。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;aaaa&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：出现三次的最长特殊子字符串是 <span class="string">&quot;aa&quot;</span> ：子字符串 <span class="string">&quot;aaaa&quot;</span>、<span class="string">&quot;aaaa&quot;</span> 和 <span class="string">&quot;aaaa&quot;</span>。</span><br><span class="line">可以证明最大长度是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;abcdef&quot;</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：不存在出现至少三次的特殊子字符串。因此返回 -<span class="number">1</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;abcaba&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：出现三次的最长特殊子字符串是 <span class="string">&quot;a&quot;</span> ：子字符串 <span class="string">&quot;abcaba&quot;</span>、<span class="string">&quot;abcaba&quot;</span> 和 <span class="string">&quot;abcaba&quot;</span>。</span><br><span class="line">可以证明最大长度是 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= s.length &lt;= 5 * 105</code></li><li><code>s</code> 仅由小写英文字母组成。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumLength</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">         <span class="comment">// 汇总每一个出现过的字符连续的部分的长度</span></span><br><span class="line">         unordered_map&lt;<span class="type">char</span>,vector&lt;<span class="type">int</span>&gt;&gt; summary; </span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i  = <span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i=j)&#123;</span><br><span class="line">             <span class="comment">// 尝试找到连续部分</span></span><br><span class="line">             <span class="keyword">while</span>(j&lt;n &amp;&amp; s[i] == s[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 此时  j - i 就是连续相同字符串的长度</span></span><br><span class="line">             summary[s[i]].<span class="built_in">emplace_back</span>(j-i);</span><br><span class="line">         &#125; </span><br><span class="line">         <span class="comment">//拿到这个汇总数据之后，因为针对于 连续相同字符串（特殊子字符串） 长度设为 k </span></span><br><span class="line">         <span class="comment">// 因为k越大，出现的次数肯定会越少，所以存在一个单调的性质，所以使用二分查找，来依次遍历，找到最大的能满足</span></span><br><span class="line">         <span class="comment">// 题中要求的 出现三次 的条件</span></span><br><span class="line"></span><br><span class="line">         <span class="type">int</span> result = <span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[_,vec]:summary)&#123;</span><br><span class="line">             <span class="type">int</span> low = <span class="number">1</span>;</span><br><span class="line">             <span class="type">int</span> high = n - <span class="number">2</span>;   <span class="comment">// 因为考虑到极端情况，字符串由相同的字符组成，则连续部分长度的最大值 n - high + 1 &gt;= 3;</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 累计所有连续部分的出现次数</span></span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> x:vec)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mid &lt;=x)&#123;</span><br><span class="line">                 sum += x - mid + <span class="number">1</span>;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断此时的累计次数结果是否满足题中所给条件，即满足大于等于 3 ，如果不满足就调小一点，置为high =  mid - 1;</span></span><br><span class="line">            <span class="comment">// 如果满足的话，还有更大的可能，置为low =  mid  + 1,并且更新 最长特殊子字符串的长度</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                result = <span class="built_in">max</span>(result,mid);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3067-在带权树网络中统计可连接服务器对数目"><a class="anchor" href="#3067-在带权树网络中统计可连接服务器对数目">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1wYWlycy1vZi1jb25uZWN0YWJsZS1zZXJ2ZXJzLWluLWEtd2VpZ2h0ZWQtdHJlZS1uZXR3b3JrLw==">3067. 在带权树网络中统计可连接服务器对数目</span></h4><p>给你一棵无根带权树，树中总共有 <code>n</code> 个节点，分别表示 <code>n</code> 个服务器，服务器从 <code>0</code> 到 <code>n - 1</code> 编号。同时给你一个数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi, weighti]</code> 表示节点 <code>ai</code> 和 <code>bi</code> 之间有一条双向边，边的权值为 <code>weighti</code> 。再给你一个整数 <code>signalSpeed</code> 。</p><p>如果两个服务器 <code>a</code> ， <code>b</code> 和 <code>c</code> 满足以下条件，那么我们称服务器 <code>a</code> 和 <code>b</code> 是通过服务器 <code>c</code> <strong>可连接的</strong> ：</p><ul><li><code>a &lt; b</code> ， <code>a != c</code> 且 <code>b != c</code> 。</li><li>从 <code>c</code> 到 <code>a</code> 的距离是可以被 <code>signalSpeed</code> 整除的。</li><li>从 <code>c</code> 到 <code>b</code> 的距离是可以被 <code>signalSpeed</code> 整除的。</li><li>从 <code>c</code> 到 <code>b</code> 的路径与从 <code>c</code> 到 <code>a</code> 的路径没有任何公共边。</li></ul><p>请你返回一个长度为 <code>n</code> 的整数数组 <code>count</code> ，其中 <code>count[i]</code> 表示通过服务器 <code>i</code> <strong>可连接</strong> 的服务器对的 <strong>数目</strong> 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2024/01/21/example22.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = <span class="comment">[<span class="comment">[0,1,1]</span>,<span class="comment">[1,2,5]</span>,<span class="comment">[2,3,13]</span>,<span class="comment">[3,4,9]</span>,<span class="comment">[4,5,2]</span>]</span>, signalSpeed = 1</span><br><span class="line">输出：<span class="comment">[0,4,6,6,4,0]</span></span><br><span class="line">解释：由于 signalSpeed 等于 1 ，count<span class="comment">[c]</span> 等于所有从 c 开始且没有公共边的路径对数目。</span><br><span class="line">在输入图中，count<span class="comment">[c]</span> 等于服务器 c 左边服务器数目乘以右边服务器数目。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2024/01/21/example11.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = <span class="comment">[<span class="comment">[0,6,3]</span>,<span class="comment">[6,5,3]</span>,<span class="comment">[0,3,1]</span>,<span class="comment">[3,2,7]</span>,<span class="comment">[3,1,6]</span>,<span class="comment">[3,4,2]</span>]</span>, signalSpeed = 3</span><br><span class="line">输出：<span class="comment">[2,0,0,0,0,0,2]</span></span><br><span class="line">解释：通过服务器 0 ，有 2 个可连接服务器对(4, 5) 和 (4, 6) 。</span><br><span class="line">通过服务器 6 ，有 2 个可连接服务器对 (4, 5) 和 (0, 5) 。</span><br><span class="line">所有服务器对都必须通过服务器 0 或 6 才可连接，所以其他服务器对应的可连接服务器对数目都为 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[i].length == 3</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>edges[i] = [ai, bi, weighti]</code></li><li><code>1 &lt;= weighti &lt;= 106</code></li><li><code>1 &lt;= signalSpeed &lt;= 106</code></li><li>输入保证 <code>edges</code> 构成一棵合法的树。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countPairsOfConnectableServers</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> signalSpeed)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 进行图结构的存储</span></span><br><span class="line">       <span class="comment">// 边的个数</span></span><br><span class="line">       <span class="type">int</span> n = edges.<span class="built_in">size</span>() + <span class="number">1</span>;   <span class="comment">// 因为是树结构，所以点的数目等于边数目加一</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 重新弄一个结构，方便遍历，无向图</span></span><br><span class="line">       vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> e:edges)&#123;</span><br><span class="line">        graph[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>],e[<span class="number">2</span>]);</span><br><span class="line">        graph[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>],e[<span class="number">2</span>]);  <span class="comment">// 可以知道emplace_back() 不是在原有的数组尾部，追加</span></span><br><span class="line">       &#125;</span><br><span class="line">       cout &lt;&lt; graph.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line">       <span class="comment">// 使用深度优先搜索，计算以 p 为根节点的子树中，有多少到达 x 的距离能被signalSpeed整除的节点         </span></span><br><span class="line">       function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> p ,<span class="type">int</span> root,<span class="type">int</span> curr)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">          <span class="comment">//遍历到某一个节点时，要做的事情都是一样的，</span></span><br><span class="line">          <span class="comment">// 记录此时节点到 x 节点的路径长度是否能被整除</span></span><br><span class="line">          <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>(curr==<span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 然后记录子节点中 到达x节点的路径长度能被整除的数目之和，然后加起来</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[v,cost]:graph[p])&#123;</span><br><span class="line">            <span class="comment">// 不能回头找，所以要不能等于父节点</span></span><br><span class="line">            <span class="keyword">if</span>(v!=root)&#123;</span><br><span class="line">                res += <span class="built_in">dfs</span>(v,p,(curr + cost)%signalSpeed);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 对于每一个节点，做完两件事之后，就返回给上一级节点，上一级节点也做同样的事</span></span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 接下来就是填写 ，每一个位置（节点）作为根节点，产生的整除对（到两者的距离都能被signalSpeed整除）</span></span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          <span class="comment">// 不断累加已经找到的子树中满足条件的节点数目</span></span><br><span class="line">          <span class="comment">// 以供新的子树中满足条件的节点数目进行相乘（随机组合的最终计算方式）</span></span><br><span class="line">          <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[v,cost]:graph[i])&#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">dfs</span>(v,i,cost%signalSpeed);</span><br><span class="line">            res[i] += pre*cnt;</span><br><span class="line">            pre +=cnt;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3040-相同分数的最大操作数目-ii"><a class="anchor" href="#3040-相同分数的最大操作数目-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLW51bWJlci1vZi1vcGVyYXRpb25zLXdpdGgtdGhlLXNhbWUtc2NvcmUtaWkv">3040. 相同分数的最大操作数目 II</span></h4><p>给你一个整数数组 <code>nums</code> ，如果 <code>nums</code> <strong>至少</strong> 包含 <code>2</code> 个元素，你可以执行以下操作中的 <strong>任意</strong> 一个：</p><ul><li>选择 <code>nums</code> 中最前面两个元素并且删除它们。</li><li>选择 <code>nums</code> 中最后两个元素并且删除它们。</li><li>选择 <code>nums</code> 中第一个和最后一个元素并且删除它们。</li></ul><p>一次操作的 <strong>分数</strong> 是被删除元素的和。</p><p>在确保 <strong>所有操作分数相同</strong> 的前提下，请你求出 <strong>最多</strong> 能进行多少次操作。</p><p>请你返回按照上述要求 <strong>最多</strong> 可以进行的操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,2,3,4]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们执行以下操作：</span><br><span class="line">- 删除前两个元素，分数为<span class="number"> 3 </span>+<span class="number"> 2 </span>=<span class="number"> 5 </span>，nums = [1,2,3,4] 。</span><br><span class="line">- 删除第一个元素和最后一个元素，分数为<span class="number"> 1 </span>+<span class="number"> 4 </span>=<span class="number"> 5 </span>，nums = [2,3] 。</span><br><span class="line">- 删除第一个元素和最后一个元素，分数为<span class="number"> 2 </span>+<span class="number"> 3 </span>=<span class="number"> 5 </span>，nums = [] 。</span><br><span class="line">由于 nums 为空，我们无法继续进行任何操作。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,6,1,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：我们执行以下操作：</span><br><span class="line">- 删除前两个元素，分数为<span class="number"> 3 </span>+<span class="number"> 2 </span>=<span class="number"> 5 </span>，nums = [6,1,4] 。</span><br><span class="line">- 删除最后两个元素，分数为<span class="number"> 1 </span>+<span class="number"> 4 </span>=<span class="number"> 5 </span>，nums = [6] 。</span><br><span class="line">至多进行<span class="number"> 2 </span>次操作。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 2000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 没有加记忆化搜索矩阵，没有通过，而加了记忆化搜索，就通过了，而且超过比列还很高</span></span><br><span class="line">        <span class="comment">// 原因应该是，自顶向下搜索，但是自底向上计算，有些情况的不止一次遇见，而遇见一次就要</span></span><br><span class="line">        <span class="comment">// 重新计算一次，就很耗费时间了，所以第一次碰见这种情况，就记录下来，下一次再碰到，就不用</span></span><br><span class="line">        <span class="comment">// 重新计算，做到了剪枝的效果</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">data</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> sum)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(data[left][right]!=<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> data[left][right];</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">if</span>(sum == <span class="number">-1</span> || nums[left] + nums[left<span class="number">+1</span>] == sum)&#123;</span><br><span class="line">                result = <span class="built_in">max</span>(result,<span class="number">1</span> + <span class="built_in">dfs</span>(left + <span class="number">2</span>,right,nums[left] + nums[left<span class="number">+1</span>]));</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(sum == <span class="number">-1</span> || nums[right] + nums[right<span class="number">-1</span>] == sum)&#123;</span><br><span class="line">                result = <span class="built_in">max</span>(result,<span class="number">1</span> + <span class="built_in">dfs</span>(left,right - <span class="number">2</span>,nums[right] + nums[right<span class="number">-1</span>]));</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(sum == <span class="number">-1</span> || nums[left] + nums[right] == sum)&#123;</span><br><span class="line">                result = <span class="built_in">max</span>(result,<span class="number">1</span> + <span class="built_in">dfs</span>(left + <span class="number">1</span>,right - <span class="number">1</span>,nums[left] + nums[right]));</span><br><span class="line">             &#125;</span><br><span class="line">             data[left][right] = result;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,n - <span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="312-戳气球"><a class="anchor" href="#312-戳气球">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idXJzdC1iYWxsb29ucy8=">312. 戳气球</span></h4><p>有 <code>n</code> 个气球，编号为 <code>0</code> 到 <code>n - 1</code> ，每个气球上都标有一个数字，这些数字存在数组 <code>nums</code> 中。</p><p>现在要求你戳破所有的气球。戳破第 <code>i</code> 个气球，你可以获得 <code>nums[i - 1] * nums[i] * nums[i + 1]</code> 枚硬币。 这里的 <code>i - 1</code> 和 <code>i + 1</code> 代表和 <code>i</code> 相邻的两个气球的序号。如果 <code>i - 1</code> 或 <code>i + 1</code> 超出了数组的边界，那么就当它是一个数字为 <code>1</code> 的气球。</p><p>求所能获得硬币的最大数量。</p><p><strong>示例 1：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,5,8]</span><br><span class="line">输出：167</span><br><span class="line">解释：</span><br><span class="line">nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []</span><br><span class="line">coins =  3<span class="number">*1</span><span class="number">*5</span>    +   3<span class="number">*5</span><span class="number">*8</span>   +  1<span class="number">*3</span><span class="number">*8</span>  + 1<span class="number">*8</span><span class="number">*1</span> = 167</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,5]</span></span><br><span class="line"><span class="string">输出：10</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// int n = nums.size();</span></span><br><span class="line">        <span class="comment">// vector&lt;&gt;</span></span><br><span class="line">        <span class="comment">// function&lt;int(set&lt;int&gt;,int)&gt; dfs = [&amp;](set&lt;int&gt; candidate,int con_result)-&gt;int&#123;</span></span><br><span class="line">        <span class="comment">//     if(candidate.size() == 0)&#123;</span></span><br><span class="line">        <span class="comment">//         return 0;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     int num = 0 ;</span></span><br><span class="line">        <span class="comment">//     int left = 1,right = 1;</span></span><br><span class="line">        <span class="comment">//     for(auto c:candidate)&#123;</span></span><br><span class="line">        <span class="comment">//         auto it = candidate.find(c);</span></span><br><span class="line">        <span class="comment">//         candidate.erase(c);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//         if(--it!=candidate.begin())&#123;</span></span><br><span class="line">        <span class="comment">//             left = nums[*it];</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         ++it;</span></span><br><span class="line">        <span class="comment">//         if(++it!=candidate.end())&#123;</span></span><br><span class="line">        <span class="comment">//             right = nums[*it];</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         num = max(num,dfs(candidate,con_result + left*nums[c]*right));</span></span><br><span class="line">        <span class="comment">//         // 回溯</span></span><br><span class="line">        <span class="comment">//         candidate.insert(c);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//     return con_result + num;</span></span><br><span class="line">        <span class="comment">// &#125;;</span></span><br><span class="line">        <span class="comment">// set&lt;int&gt; candidate;</span></span><br><span class="line">        <span class="comment">// for(int i = 0;i&lt;n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     candidate.insert(i);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return dfs(candidate,0);</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">val</span><span class="params">(n<span class="number">+2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i  = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            val[i] = nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        val[<span class="number">0</span>] = val[n<span class="number">+1</span>] = <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">rec</span>(n<span class="number">+2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+2</span>,<span class="number">-1</span>));</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; solve = [&amp;](<span class="type">int</span> left,<span class="type">int</span> right)-&gt;<span class="type">int</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rec[left][right] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left + <span class="number">1</span>; i &lt; right; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = val[left] * val[i] * val[right];</span><br><span class="line">            sum += <span class="built_in">solve</span>(left, i) + <span class="built_in">solve</span>(i, right);</span><br><span class="line">            rec[left][right] = <span class="built_in">max</span>(rec[left][right], sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rec[left][right];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">solve</span>(<span class="number">0</span>,n<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2786-访问数组中的位置使分数最大"><a class="anchor" href="#2786-访问数组中的位置使分数最大">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92aXNpdC1hcnJheS1wb3NpdGlvbnMtdG8tbWF4aW1pemUtc2NvcmUv">2786. 访问数组中的位置使分数最大</span></h4><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个正整数 <code>x</code> 。</p><p>你 <strong>一开始</strong> 在数组的位置 <code>0</code> 处，你可以按照下述规则访问数组中的其他位置：</p><ul><li>如果你当前在位置 <code>i</code> ，那么你可以移动到满足 <code>i &lt; j</code> 的 <strong>任意</strong> 位置 <code>j</code> 。</li><li>对于你访问的位置 <code>i</code> ，你可以获得分数 <code>nums[i]</code> 。</li><li>如果你从位置 <code>i</code> 移动到位置 <code>j</code> 且 <code>nums[i]</code> 和 <code>nums[j]</code> 的 <strong>奇偶性</strong> 不同，那么你将失去分数 <code>x</code> 。</li></ul><p>请你返回你能得到的 <strong>最大</strong> 得分之和。</p><p><strong>注意</strong> ，你一开始的分数为 <code>nums[0]</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,6,1,9,2], x = 5</span><br><span class="line">输出：13</span><br><span class="line">解释：我们可以按顺序访问数组中的位置：0 -&gt;<span class="number"> 2 </span>-&gt;<span class="number"> 3 </span>-&gt;<span class="number"> 4 </span>。</span><br><span class="line">对应位置的值为<span class="number"> 2 </span>，6 ，1 和<span class="number"> 9 </span>。因为<span class="number"> 6 </span>和<span class="number"> 1 </span>的奇偶性不同，所以下标从<span class="number"> 2 </span>-&gt;<span class="number"> 3 </span>让你失去 x =<span class="number"> 5 </span>分。</span><br><span class="line">总得分为：2 +<span class="number"> 6 </span>+<span class="number"> 1 </span>+<span class="number"> 9 </span>-<span class="number"> 5 </span>=<span class="number"> 13 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,4,6,8], x = 3</span><br><span class="line">输出：20</span><br><span class="line">解释：数组中的所有元素奇偶性都一样，所以我们可以将每个元素都访问一次，而且不会失去任何分数。</span><br><span class="line">总得分为：2 +<span class="number"> 4 </span>+<span class="number"> 6 </span>+<span class="number"> 8 </span>=<span class="number"> 20 </span>。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i], x &lt;= 106</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自己的想法，只通过了 736 / 744 ，</span></span><br><span class="line">        <span class="comment">// dp[i] 表示以i位置开头，最多的分数</span></span><br><span class="line">        <span class="comment">// dp[i] = max(dp[j] + nums[i] - x ,dp[j] +nums[i] ,nums[i]) (j&gt;i) 按照给出的奇偶性规则，进行操作就行了</span></span><br><span class="line">        <span class="comment">// int n = nums.size();</span></span><br><span class="line">        <span class="comment">// vector&lt;long long&gt; dp(n);</span></span><br><span class="line">        <span class="comment">// for(int i = n-1;i&gt;=0;i--)&#123;</span></span><br><span class="line">        <span class="comment">//     if(i==n-1)&#123;</span></span><br><span class="line">        <span class="comment">//           dp[i] = nums[i];   </span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//          dp[i] = nums[i];</span></span><br><span class="line">        <span class="comment">//          for(int j = i+1;j&lt;n;j++)&#123;</span></span><br><span class="line">        <span class="comment">//           if((nums[j] + nums[i])%2 == 1)&#123;</span></span><br><span class="line">        <span class="comment">//               dp[i] = max(dp[i],dp[j] + nums[i] - x);</span></span><br><span class="line">        <span class="comment">//           &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//              dp[i] = max(dp[i],dp[j] + nums[i]);</span></span><br><span class="line">        <span class="comment">//           &#125;</span></span><br><span class="line">        <span class="comment">//      &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">           </span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return dp[0];</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 官方的题解方法</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>, INT_MIN)</span></span>;</span><br><span class="line">        <span class="comment">// 遍历到目前为止，奇数位置最大分数，和偶数位置的最大分数</span></span><br><span class="line">        dp[nums[<span class="number">0</span>] % <span class="number">2</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 表示当前位置的nums[i] 的奇偶性</span></span><br><span class="line">            <span class="type">int</span> parity = nums[i] % <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 比较出到底是之前偶数位置来的最大，还是奇数位置来的最大</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> cur = <span class="built_in">max</span>(dp[parity] + nums[i], dp[<span class="number">1</span> - parity] - x + nums[i]);</span><br><span class="line">            <span class="comment">// 更新结果</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, cur);</span><br><span class="line">            <span class="comment">// 更新奇偶最大分数的值，以供之后的使用</span></span><br><span class="line">            dp[parity] = <span class="built_in">max</span>(dp[parity], cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2779-数组的最大美丽值"><a class="anchor" href="#2779-数组的最大美丽值">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWJlYXV0eS1vZi1hbi1hcnJheS1hZnRlci1hcHBseWluZy1vcGVyYXRpb24v">2779. 数组的最大美丽值</span></h4><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个 <strong>非负</strong> 整数 <code>k</code> 。</p><p>在一步操作中，你可以执行下述指令：</p><ul><li>在范围 <code>[0, nums.length - 1]</code> 中选择一个 <strong>此前没有选过</strong> 的下标 <code>i</code> 。</li><li>将 <code>nums[i]</code> 替换为范围 <code>[nums[i] - k, nums[i] + k]</code> 内的任一整数。</li></ul><p>数组的 <strong>美丽值</strong> 定义为数组中由相等元素组成的最长子序列的长度。</p><p>对数组 <code>nums</code> 执行上述操作任意次后，返回数组可能取得的 <strong>最大</strong> 美丽值。</p><p>** 注意：** 你 <strong>只</strong> 能对每个下标执行 <strong>一次</strong> 此操作。</p><p>数组的 <strong>子序列</strong> 定义是：经由原数组删除一些元素（也可能不删除）得到的一个新数组，且在此过程中剩余元素的顺序不发生改变。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[4,6,1,2]</span>, k = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：在这个示例中，我们执行下述操作：</span><br><span class="line">- 选择下标 1 ，将其替换为 4（从范围 <span class="comment">[4,8]</span> 中选出），此时 nums = <span class="comment">[4,4,1,2]</span> 。</span><br><span class="line">- 选择下标 3 ，将其替换为 4（从范围 <span class="comment">[0,4]</span> 中选出），此时 nums = <span class="comment">[4,4,1,4]</span> 。</span><br><span class="line">执行上述操作后，数组的美丽值是 3（子序列由下标 0 、1 、3 对应的元素组成）。</span><br><span class="line">可以证明 3 是我们可以得到的由相等元素组成的最长子序列长度。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1,1,1,1</span>], k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：在这个示例中，我们无需执行任何操作。</span><br><span class="line">数组 nums 的美丽值是 <span class="number">4</span>（整个数组）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i], k &lt;= 105</code></li></ul><p><img data-src="E:%5Ctypora%E5%9B%BE%E7%89%87%5Cimage-20240615110704339.png" alt="image-20240615110704339"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumBeauty</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己的思路，通过  500 / 620 </span></span><br><span class="line">        <span class="comment">// 存在问题，但是无法解决</span></span><br><span class="line">        <span class="comment">// int n = nums.size();</span></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; dp(n,1);</span></span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;int&gt;&gt; interval(n,vector&lt;int&gt;(2,-1));</span></span><br><span class="line">        <span class="comment">// interval[0] = &#123;nums[0] - k,nums[0] + k&#125;;</span></span><br><span class="line">        <span class="comment">// int result = 1;</span></span><br><span class="line">        <span class="comment">//  for(int i = 1;i&lt;n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//      interval[i][0] = nums[i] - k;</span></span><br><span class="line">        <span class="comment">//      interval[i][1] = nums[i] + k;</span></span><br><span class="line">        <span class="comment">//      for(int j = 0;j&lt;i;j++)&#123;</span></span><br><span class="line">        <span class="comment">//         if(interval[i][0] &gt; interval[j][1] || interval[i][1] &lt; interval[j][0])&#123; </span></span><br><span class="line">        <span class="comment">//             continue;</span></span><br><span class="line">        <span class="comment">//         &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//             if(dp[i] &lt;= dp[j] + 1)&#123;</span></span><br><span class="line">        <span class="comment">//                 // 更新dp数组，和interval数组</span></span><br><span class="line">        <span class="comment">//                 dp[i] = dp[j] + 1;</span></span><br><span class="line">        <span class="comment">//                 interval[i][0] = max(interval[j][0], interval[i][0]);</span></span><br><span class="line">        <span class="comment">//                 interval[i][1] = min(interval[j][1],interval[i][1]);</span></span><br><span class="line">        <span class="comment">//             &#125;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//      &#125;</span></span><br><span class="line">        <span class="comment">//      result = max(result,dp[i]);              </span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">        <span class="comment">//  return result;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] - <span class="number">2</span> * k &gt; nums[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 20 66     20 66  1</span></span><br><span class="line"><span class="comment">// -23 23    20 23  2</span></span><br><span class="line"><span class="comment">// 60 106    60 66  2</span></span><br><span class="line"><span class="comment">// 76 122    76 122 1</span></span><br><span class="line"><span class="comment">// 70 116    76 116 2</span></span><br></pre></td></tr></table></figure><h4 id="2288-价格减免"><a class="anchor" href="#2288-价格减免">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hcHBseS1kaXNjb3VudC10by1wcmljZXMv">2288. 价格减免</span></h4><p><strong>句子</strong> 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 <code>'$'</code> 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个 <strong>价格</strong> 。</p><ul><li>例如 <code>&quot;$100&quot;</code> 、 <code>&quot;$23&quot;</code> 和 <code>&quot;$6&quot;</code> 表示价格，而 <code>&quot;100&quot;</code> 、 <code>&quot;$&quot;</code> 和 <code>&quot;$1e5</code> 不是。</li></ul><p>给你一个字符串 <code>sentence</code> 表示一个句子和一个整数 <code>discount</code> 。对于每个表示价格的单词，都在价格的基础上减免 <code>discount%</code> ，并 <strong>更新</strong> 该单词到句子中。所有更新后的价格应该表示为一个 <strong>恰好保留小数点后两位</strong> 的数字。</p><p>返回表示修改后句子的字符串。</p><p>注意：所有价格 <strong>最多</strong> 为 <code>10</code> 位数字。</p><p><strong>示例 1：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence = <span class="string">&quot;there are <span class="variable">$1</span> <span class="variable">$2</span> and 5<span class="variable">$</span> candies in the shop&quot;</span>, discount = <span class="number">50</span></span><br><span class="line">输出：<span class="string">&quot;there are <span class="variable">$0</span>.50 <span class="variable">$1</span>.00 and 5<span class="variable">$</span> candies in the shop&quot;</span></span><br><span class="line">解释：</span><br><span class="line">表示价格的单词是 <span class="string">&quot;<span class="variable">$1</span>&quot;</span> 和 <span class="string">&quot;<span class="variable">$2</span>&quot;</span> 。 </span><br><span class="line">- <span class="string">&quot;<span class="variable">$1</span>&quot;</span> 减免 <span class="number">50</span>% 为 <span class="string">&quot;<span class="variable">$0</span>.50&quot;</span> ，所以 <span class="string">&quot;<span class="variable">$1</span>&quot;</span> 替换为 <span class="string">&quot;<span class="variable">$0</span>.50&quot;</span> 。</span><br><span class="line">- <span class="string">&quot;<span class="variable">$2</span>&quot;</span> 减免 <span class="number">50</span>% 为 <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ，所以 <span class="string">&quot;<span class="variable">$1</span>&quot;</span> 替换为 <span class="string">&quot;<span class="variable">$1</span>.00&quot;</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence = <span class="string">&quot;1 2 <span class="variable">$3</span> 4 <span class="variable">$5</span> <span class="variable">$6</span> 7 8<span class="variable">$</span> <span class="variable">$9</span> <span class="variable">$10</span><span class="variable">$</span>&quot;</span>, discount = <span class="number">100</span></span><br><span class="line">输出：<span class="string">&quot;1 2 <span class="variable">$0</span>.00 4 <span class="variable">$0</span>.00 <span class="variable">$0</span>.00 7 8<span class="variable">$</span> <span class="variable">$0</span>.00 <span class="variable">$10</span><span class="variable">$</span>&quot;</span></span><br><span class="line">解释：</span><br><span class="line">任何价格减免 <span class="number">100</span>% 都会得到 <span class="number">0</span> 。</span><br><span class="line">表示价格的单词分别是 <span class="string">&quot;<span class="variable">$3</span>&quot;</span>、<span class="string">&quot;<span class="variable">$5</span>&quot;</span>、<span class="string">&quot;<span class="variable">$6</span>&quot;</span> 和 <span class="string">&quot;<span class="variable">$9</span>&quot;</span>。</span><br><span class="line">每个单词都替换为 <span class="string">&quot;<span class="variable">$0</span>.00&quot;</span>。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= sentence.length &lt;= 105</code></li><li><code>sentence</code> 由小写英文字母、数字、 <code>' '</code> 和 <code>'$'</code> 组成</li><li><code>sentence</code> 不含前导和尾随空格</li><li><code>sentence</code> 的所有单词都用单个空格分隔</li><li>所有价格都是 <strong>正</strong> 整数且不含前导零</li><li>所有价格 <strong>最多</strong> 为 <code>10</code> 位数字</li><li><code>0 &lt;= discount &lt;= 100</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">discountPrices</span><span class="params">(string sentence, <span class="type">int</span> discount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过 87 / 151  </span></span><br><span class="line">        <span class="comment">//  int n = sentence.size();</span></span><br><span class="line">        <span class="comment">//  stringstream ss;</span></span><br><span class="line">        <span class="comment">//  ss &lt;&lt; fixed &lt;&lt; setprecision(2); // 设置小数点后保留2位</span></span><br><span class="line">        <span class="comment">//  for(int i = 0;i&lt;n;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(sentence[i]==&#x27;$&#x27;&amp;&amp; i &lt; n-1 &amp;&amp; sentence[i+1] &gt; &#x27;0&#x27; &amp;&amp; sentence[i+1] &lt;= &#x27;9&#x27;)&#123;</span></span><br><span class="line">        <span class="comment">//         int j = i+1;</span></span><br><span class="line">        <span class="comment">//         double num = 0;</span></span><br><span class="line">        <span class="comment">//         while(j &lt; n &amp;&amp; sentence[j]&gt;=&#x27;0&#x27; &amp;&amp; sentence[j] &lt;=&#x27;9&#x27;)&#123;</span></span><br><span class="line">        <span class="comment">//            num = num*10 + (sentence[j]-&#x27;0&#x27;);  </span></span><br><span class="line">        <span class="comment">//            j++;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         if(j &lt; n &amp;&amp; sentence[j]!=&#x27; &#x27;)&#123;</span></span><br><span class="line">        <span class="comment">//             continue;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         num = num*(1.0-discount/100.0);</span></span><br><span class="line">        <span class="comment">//         ss.str(&quot;&quot;);</span></span><br><span class="line">        <span class="comment">//         ss&lt;&lt;num;</span></span><br><span class="line">        <span class="comment">//         string str =  ss.str();</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//         // num  = (floor(num * 100)) / 100.0; // 直接保留两位小数</span></span><br><span class="line">        <span class="comment">//         // cout &lt;&lt; num &lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//         // cout &lt;&lt; to_string(num) &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//         sentence.replace(i,j-i,&quot;$&quot; + str);</span></span><br><span class="line">        <span class="comment">//         n += (str.size() - j + i);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">     </span><br><span class="line">        <span class="comment">//  return sentence;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这种写法，之前没有见过，而且这方面的语法知识欠缺，之后再看一下</span></span><br><span class="line">        <span class="function">stringstream <span class="title">sin</span><span class="params">(sentence)</span>, sout</span>;</span><br><span class="line">        sout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        vector&lt;string&gt; words;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">while</span> (sin &gt;&gt; word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word[<span class="number">0</span>] == <span class="string">&#x27;$&#x27;</span> &amp;&amp; word.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">all_of</span>(word.<span class="built_in">begin</span>() + <span class="number">1</span>, word.<span class="built_in">end</span>(), ::isdigit)) &#123;</span><br><span class="line">                <span class="type">double</span> price = <span class="built_in">stoll</span>(word.<span class="built_in">substr</span>(<span class="number">1</span>, word.<span class="built_in">size</span>() - <span class="number">1</span>)) * (<span class="number">1.0</span> - discount / <span class="number">100.0</span>);</span><br><span class="line">                sout &lt;&lt; <span class="string">&#x27;$&#x27;</span> &lt;&lt; price;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sout &lt;&lt; word;</span><br><span class="line">            &#125;</span><br><span class="line">            sout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = sout.<span class="built_in">str</span>();</span><br><span class="line">        ans.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="503-下一个更大元素-ii"><a class="anchor" href="#503-下一个更大元素-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9uZXh0LWdyZWF0ZXItZWxlbWVudC1paS8=">503. 下一个更大元素 II</span></h4><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <em><code>nums</code> 中每个元素的 <strong>下一个更大元素</strong></em> 。</p><p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [1,2,1]</span></span><br><span class="line"><span class="section">输出: [2,-1,2]</span></span><br><span class="line"><span class="section">解释: 第一个 1 的下一个更大的数是 2；</span></span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = <span class="string">[1,2,3,4,3]</span></span><br><span class="line">输出: <span class="string">[2,3,4,-1,4]</span></span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 单调栈(维护一个单调不升的单调栈)</span></span><br><span class="line">         <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">         <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">         stack&lt;<span class="type">int</span>&gt; mystack;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; <span class="number">2</span>*n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果不满足单调不升的条件，就依次弹出栈顶元素</span></span><br><span class="line">            <span class="keyword">while</span>(!mystack.<span class="built_in">empty</span>() &amp;&amp; nums[mystack.<span class="built_in">top</span>()] &lt; nums[i%n])&#123;</span><br><span class="line">                <span class="comment">// 记录此时的记过（即，弹出的元素的最近的大于自己的数，就是将要入栈的元素）</span></span><br><span class="line">                result[mystack.<span class="built_in">top</span>()] = nums[i%n];</span><br><span class="line">                mystack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            mystack.<span class="built_in">push</span>(i%n);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2734-执行子串操作后的字典序最小字符串"><a class="anchor" href="#2734-执行子串操作后的字典序最小字符串">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZXhpY29ncmFwaGljYWxseS1zbWFsbGVzdC1zdHJpbmctYWZ0ZXItc3Vic3RyaW5nLW9wZXJhdGlvbi8=">2734. 执行子串操作后的字典序最小字符串</span></h4><p>给你一个仅由小写英文字母组成的字符串 <code>s</code> 。在一步操作中，你可以完成以下行为：</p><ul><li>选择 <code>s</code> 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，‘b’ 用 ‘a’ 替换，‘a’ 用 ‘z’ 替换。</li></ul><p>返回执行上述操作 <strong>恰好一次</strong> 后可以获得的 <strong>字典序最小</strong> 的字符串。</p><p><strong>子字符串</strong> 是字符串中的一个连续字符序列。</p><p>现有长度相同的两个字符串 <code>x</code> 和 字符串 <code>y</code> ，在满足 <code>x[i] != y[i]</code> 的第一个位置 <code>i</code> 上，如果 <code>x[i]</code> 在字母表中先于 <code>y[i]</code> 出现，则认为字符串 <code>x</code> 比字符串 <code>y</code> <strong>字典序更小</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;cbabc&quot;</span></span><br><span class="line">输出：<span class="string">&quot;baabc&quot;</span></span><br><span class="line">解释：我们选择从下标 <span class="number">0</span> 开始、到下标 <span class="number">1</span> 结束的子字符串执行操作。 </span><br><span class="line">可以证明最终得到的字符串是字典序最小的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;acbbc&quot;</span></span><br><span class="line">输出：<span class="string">&quot;abaab&quot;</span></span><br><span class="line">解释：我们选择从下标 <span class="number">1</span> 开始、到下标 <span class="number">4</span> 结束的子字符串执行操作。</span><br><span class="line">可以证明最终得到的字符串是字典序最小的。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;leetcode&quot;</span></span><br><span class="line">输出：<span class="string">&quot;kddsbncd&quot;</span></span><br><span class="line">解释：我们选择整个字符串执行操作。</span><br><span class="line">可以证明最终得到的字符串是字典序最小的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 3 * 105</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span> ,right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; n &amp;&amp; s[left]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">            left ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        right = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right &lt; n &amp;&amp; s[right]!=<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                s[right] = s[right] - <span class="number">1</span>;</span><br><span class="line">                right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left == n)&#123;</span><br><span class="line">            s[n<span class="number">-1</span>] = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="困难-2"><a class="anchor" href="#困难-2">#</a> 困难</h3><h4 id="1883-准时抵达会议现场的最小跳过休息次数"><a class="anchor" href="#1883-准时抵达会议现场的最小跳过休息次数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXNraXBzLXRvLWFycml2ZS1hdC1tZWV0aW5nLW9uLXRpbWUv">1883. 准时抵达会议现场的最小跳过休息次数</span></h4><p>给你一个整数 <code>hoursBefore</code> ，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经 <code>n</code> 条道路。道路的长度用一个长度为 <code>n</code> 的整数数组 <code>dist</code> 表示，其中 <code>dist[i]</code> 表示第 <code>i</code> 条道路的长度（单位：<strong>千米</strong>）。另给你一个整数 <code>speed</code> ，表示你在道路上前进的速度（单位：<strong>千米每小时</strong>）。</p><p>当你通过第 <code>i</code> 条路之后，就必须休息并等待，直到 <strong>下一个整数小时</strong> 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。</p><ul><li>例如，如果你通过一条道路用去 <code>1.4</code> 小时，那你必须停下来等待，到 <code>2</code> 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 <code>2</code> 小时，就无需等待，可以直接继续。</li></ul><p>然而，为了能准时到达，你可以选择 <strong>跳过</strong> 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。</p><ul><li>例如，假设通过第 <code>1</code> 条道路用去 <code>1.4</code> 小时，且通过第 <code>2</code> 条道路用去 <code>0.6</code> 小时。跳过第 <code>1</code> 条道路的休息时间意味着你将会在恰好 <code>2</code> 小时完成通过第 <code>2</code> 条道路，且你能够立即开始通过第 <code>3</code> 条道路。</li></ul><p>返回准时抵达会议现场所需要的 <strong>最小跳过次数</strong> ，如果 <strong>无法准时参会</strong> ，返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], speed = <span class="number">4</span>, hoursBefore = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">不跳过任何休息时间，你将用 <span class="comment">(1/4 + 3/4)</span> + <span class="comment">(3/4 + 1/4)</span> + <span class="comment">(2/4)</span> = <span class="number">2.5</span> 小时才能抵达会议现场。</span><br><span class="line">可以跳过第 <span class="number">1</span> 次休息时间，共用 <span class="comment">((1/4 + 0)</span> + <span class="comment">(3/4 + 0)</span>) + <span class="comment">(2/4)</span> = <span class="number">1.5</span> 小时抵达会议现场。</span><br><span class="line">注意，第 <span class="number">2</span> 次休息时间缩短为 <span class="number">0</span> ，由于跳过第 <span class="number">1</span> 次休息时间，你是在整数小时处完成通过第 <span class="number">2</span> 条道路。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>], speed = <span class="number">2</span>, hoursBefore = <span class="number">10</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">不跳过任何休息时间，你将用 <span class="comment">(7/2 + 1/2)</span> + <span class="comment">(3/2 + 1/2)</span> + <span class="comment">(5/2 + 1/2)</span> + <span class="comment">(5/2)</span> = <span class="number">11.5</span> 小时才能抵达会议现场。</span><br><span class="line">可以跳过第 <span class="number">1</span> 次和第 <span class="number">3</span> 次休息时间，共用 <span class="comment">((7/2 + 0)</span> + <span class="comment">(3/2 + 0)</span>) + <span class="comment">((5/2 + 0)</span> + <span class="comment">(5/2)</span>) = <span class="number">10</span> 小时抵达会议现场。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">7,3,5,5</span>], speed = <span class="number">1</span>, hoursBefore = <span class="number">10</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：即使跳过所有的休息时间，也无法准时参加会议。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == dist.length</code></li><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= dist[i] &lt;= 105</code></li><li><code>1 &lt;= speed &lt;= 106</code></li><li><code>1 &lt;= hoursBefore &lt;= 107</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 可忽略误差</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> EPS = <span class="number">1e-7</span>;</span><br><span class="line">    <span class="comment">// 极大值</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">double</span> INFTY = <span class="number">1e20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSkips</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; dist, <span class="type">int</span> speed, <span class="type">int</span> hoursBefore)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = dist.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(n + <span class="number">1</span>, INFTY));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], <span class="built_in">ceil</span>(f[i - <span class="number">1</span>][j] + (<span class="type">double</span>)dist[i - <span class="number">1</span>] / speed - EPS));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (<span class="type">double</span>)dist[i - <span class="number">1</span>] / speed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[n][j] &lt; hoursBefore + EPS) &#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="924-尽量减少恶意软件的传播"><a class="anchor" href="#924-尽量减少恶意软件的传播">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbWl6ZS1tYWx3YXJlLXNwcmVhZC8=">924. 尽量减少恶意软件的传播</span></h4><p>给出了一个由 <code>n</code> 个节点组成的网络，用 <code>n × n</code> 个邻接矩阵图 <code>graph</code> 表示。在节点网络中，当 <code>graph[i][j] = 1</code> 时，表示节点 <code>i</code> 能够直接连接到另一个节点 <code>j</code> 。</p><p>一些节点 <code>initial</code> 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p><p>假设 <code>M(initial)</code> 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p><p>如果从 <code>initial</code> 中<strong>移除某一节点</strong>能够最小化 <code>M(initial)</code> ， 返回该节点。如果有多个节点满足条件，就返回<strong>索引最小</strong>的节点。</p><p>请注意，如果某个节点已从受感染节点的列表 <code>initial</code> 中删除，它以后仍有可能因恶意软件传播而受到感染。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = <span class="comment">[<span class="comment">[1,1,0]</span>,<span class="comment">[1,1,0]</span>,<span class="comment">[0,0,1]</span>]</span>, initial = <span class="comment">[0,1]</span></span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = <span class="comment">[<span class="comment">[1,0,0]</span>,<span class="comment">[0,1,0]</span>,<span class="comment">[0,0,1]</span>]</span>, initial = <span class="comment">[0,2]</span></span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = <span class="comment">[<span class="comment">[1,1,1]</span>,<span class="comment">[1,1,1]</span>,<span class="comment">[1,1,1]</span>]</span>, initial = <span class="comment">[1,2]</span></span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == graph.length</code></li><li><code>n == graph[i].length</code></li><li><code>2 &lt;= n &lt;= 300</code></li><li><code>graph[i][j] == 0</code> 或 <code>1</code> .</li><li><code>graph[i][j] == graph[j][i]</code></li><li><code>graph[i][i] == 1</code></li><li><code>1 &lt;= initial.length &lt;= n</code></li><li><code>0 &lt;= initial[i] &lt;= n - 1</code></li><li><code>initial</code> 中所有整数均<strong>不重复</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMalwareSpread</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="type">int</span>&gt;&amp; initial)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ids</span><span class="params">(n)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; id_to_size;</span><br><span class="line">        <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ids[i]) &#123;</span><br><span class="line">                ++id;</span><br><span class="line">                <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">                queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                ids[i] = id;</span><br><span class="line">                <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; ++v) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!ids[v] &amp;&amp; graph[u][v] == <span class="number">1</span>) &#123;</span><br><span class="line">                            ++size;</span><br><span class="line">                            q.<span class="built_in">push</span>(v);</span><br><span class="line">                            ids[v] = id;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                id_to_size[id] = size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; id_to_initials;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u: initial) &#123;</span><br><span class="line">            ++id_to_initials[ids[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = n + <span class="number">1</span>, ans_removed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u: initial) &#123;</span><br><span class="line">            <span class="type">int</span> removed = (id_to_initials[ids[u]] == <span class="number">1</span> ? id_to_size[ids[u]] : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (removed &gt; ans_removed || (removed == ans_removed &amp;&amp; u &lt; ans)) &#123;</span><br><span class="line">                ans = u;</span><br><span class="line">                ans_removed = removed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    int n = graph.size();</span></span><br><span class="line">    <span class="comment">//    vector&lt;int&gt; visit(n);</span></span><br><span class="line">    <span class="comment">//    vector&lt;int&gt; result(2,n + 1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    function&lt;void(int,vector&lt;int&gt;&amp;)&gt; dfs = [&amp;](int v,vector&lt;int&gt;&amp; d)-&gt;void&#123;</span></span><br><span class="line">    <span class="comment">//       visit[v]  = 1;</span></span><br><span class="line">    <span class="comment">//       if(find(initial.begin(),initial.end(),d[0])!=initial.end())&#123;</span></span><br><span class="line">    <span class="comment">//         d.emplace_back(v);</span></span><br><span class="line">    <span class="comment">//       &#125;</span></span><br><span class="line">    <span class="comment">//       for(int i = 0;i&lt;n;i++)&#123;</span></span><br><span class="line">    <span class="comment">//         if(i!=v &amp;&amp; graph[v][i] &amp;&amp; !visit[i])&#123;</span></span><br><span class="line">    <span class="comment">//             dfs(i,d);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//       &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;;</span></span><br><span class="line">       </span><br><span class="line">    <span class="comment">//    for(int i = 0;i&lt;n;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     if(!visit[i])&#123;</span></span><br><span class="line">    <span class="comment">//         vector&lt;int&gt; d;</span></span><br><span class="line">    <span class="comment">//         dfs(i,d);</span></span><br><span class="line">    <span class="comment">//         if(d.size()  == 1)&#123;</span></span><br><span class="line">    <span class="comment">//            if(result[1] == 1)&#123;</span></span><br><span class="line">    <span class="comment">//               result[0] = min(result[0],d[0]);</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//            else&#123;</span></span><br><span class="line">    <span class="comment">//               result[0] = d[0];</span></span><br><span class="line">    <span class="comment">//            &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;else if(d.size() &gt; 1&amp;&amp;result[1]!=1)&#123;</span></span><br><span class="line">    <span class="comment">//              for(int j =0;j&lt;d.size();j++)&#123;</span></span><br><span class="line">    <span class="comment">//                 result[0] = min(result[0],d[j]);</span></span><br><span class="line">    <span class="comment">//              &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    <span class="comment">//   return result[0];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 - 1  2 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0  1  2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 - 1 - 2</span></span><br></pre></td></tr></table></figure><h4 id="928-尽量减少恶意软件的传播-ii"><a class="anchor" href="#928-尽量减少恶意软件的传播-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbWl6ZS1tYWx3YXJlLXNwcmVhZC1paS8=">928. 尽量减少恶意软件的传播 II</span></h4><p>给定一个由 <code>n</code> 个节点组成的网络，用 <code>n x n</code> 个邻接矩阵 <code>graph</code> 表示。在节点网络中，只有当 <code>graph[i][j] = 1</code> 时，节点 <code>i</code> 能够直接连接到另一个节点 <code>j</code> 。</p><p>一些节点 <code>initial</code> 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p><p>假设 <code>M(initial)</code> 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p><p>我们可以从 <code>initial</code> 中<strong>删除一个节点</strong>，<strong>并完全移除该节点以及从该节点到任何其他节点的任何连接。</strong></p><p>请返回移除后能够使 <code>M(initial)</code> 最小化的节点。如果有多个节点满足条件，返回索引 <strong>最小的节点</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = <span class="comment">[<span class="comment">[1,1,0]</span>,<span class="comment">[1,1,0]</span>,<span class="comment">[0,0,1]</span>]</span>, initial = <span class="comment">[0,1]</span></span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = <span class="comment">[<span class="comment">[1,1,0]</span>,<span class="comment">[1,1,1]</span>,<span class="comment">[0,1,1]</span>]</span>, initial = <span class="comment">[0,1]</span></span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = <span class="comment">[<span class="comment">[1,1,0,0]</span>,<span class="comment">[1,1,1,0]</span>,<span class="comment">[0,1,1,1]</span>,<span class="comment">[0,0,1,1]</span>]</span>, initial = <span class="comment">[0,1]</span></span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == graph.length</code></li><li><code>n == graph[i].length</code></li><li><code>2 &lt;= n &lt;= 300</code></li><li><code>graph[i][j]</code> 是 <code>0</code> 或 <code>1</code> .</li><li><code>graph[i][j] == graph[j][i]</code></li><li><code>graph[i][i] == 1</code></li><li><code>1 &lt;= initial.length &lt; n</code></li><li><code>0 &lt;= initial[i] &lt;= n - 1</code></li><li><code>initial</code> 中每个整数都<strong>不同</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMalwareSpread</span>(<span class="params">self, graph, initial</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :type initial: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment">## 首先筛选出不是initial中的节点，即正常节点</span></span><br><span class="line">        N = <span class="built_in">len</span>(graph)</span><br><span class="line">        clean = <span class="built_in">set</span>(<span class="built_in">range</span>(N)) - <span class="built_in">set</span>(initial)</span><br><span class="line">        <span class="comment"># 深度优先搜索，并且将其他initial节点都扣除，即不当做图中节点看待</span></span><br><span class="line">        <span class="comment"># 进行深度优先搜索，并在搜索的同时记录能够到达的节点( 因为做了筛选)</span></span><br><span class="line">        <span class="comment"># 所以能够到达的节点都是正常节点的集合</span></span><br><span class="line">        <span class="comment"># 即该函数的目的就是为了找到从某一个顶点出发，所能到达的所有正常节点（在扣除其他initial节点的条件下）</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">u, seen</span>):</span><br><span class="line">            <span class="keyword">for</span> v, adj <span class="keyword">in</span> <span class="built_in">enumerate</span>(graph[u]):</span><br><span class="line">                <span class="keyword">if</span> adj <span class="keyword">and</span> v <span class="keyword">in</span> clean <span class="keyword">and</span> v <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    seen.add(v)</span><br><span class="line">                    dfs(v, seen)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录每一个正常节点可以被那些initial节点所感染</span></span><br><span class="line">        infected_by = &#123;v: [] <span class="keyword">for</span> v <span class="keyword">in</span> clean&#125;</span><br><span class="line">        <span class="comment"># 从initial节点集合中任意一个节点出发，利用dfs 寻找所能到达的正常节点集合</span></span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> initial:</span><br><span class="line">            seen = <span class="built_in">set</span>()</span><br><span class="line">            <span class="comment"># 而且是扣除其他所有initial节点的条件下</span></span><br><span class="line">            dfs(u, seen)</span><br><span class="line"></span><br><span class="line">           <span class="comment"># 对于每一个正常节点，记录每一次遍历后，能够被该initial节点感染</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> seen:</span><br><span class="line">                infected_by[v].append(u)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历寻找只能被一个initial节点感染的正常节点</span></span><br><span class="line">        <span class="comment"># 并且每找到一个只能被该initial节点感染的正常节点，就将该initial节点的sorce 加一（也就是表示删除该initial节点所能减少的被感染节点个数）</span></span><br><span class="line">        contribution = collections.Counter()</span><br><span class="line">        <span class="keyword">for</span> v, neighbors <span class="keyword">in</span> infected_by.iteritems():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(neighbors) == <span class="number">1</span>:</span><br><span class="line">                contribution[neighbors[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 遍历更新最终的结果</span></span><br><span class="line">               <span class="comment"># sorce    节点的值的大小</span></span><br><span class="line">        best = (-<span class="number">1</span>, <span class="built_in">min</span>(initial))</span><br><span class="line">        <span class="keyword">for</span> u, score <span class="keyword">in</span> contribution.iteritems():</span><br><span class="line">            <span class="comment"># 原则就是，如果去掉该initial节点，所能减少的被感染节点个数比之前的更大，那就直接更新之前的值，</span></span><br><span class="line">            <span class="comment"># 或者是减少的被感染的节点的个数和之前一样大，但是当前initial节点的索引值比之前的小</span></span><br><span class="line">            <span class="keyword">if</span> score &gt; best[<span class="number">0</span>] <span class="keyword">or</span> score == best[<span class="number">0</span>] <span class="keyword">and</span> u &lt; best[<span class="number">1</span>]:</span><br><span class="line">                best = score, u</span><br><span class="line">        <span class="keyword">return</span> best[<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2009-使数组连续的最少操作数"><a class="anchor" href="#2009-使数组连续的最少操作数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLW51bWJlci1vZi1vcGVyYXRpb25zLXRvLW1ha2UtYXJyYXktY29udGludW91cy8=">2009. 使数组连续的最少操作数</span></h4><p>给你一个整数数组 <code>nums</code> 。每一次操作中，你可以将 <code>nums</code> 中 <strong>任意</strong> 一个元素替换成 <strong>任意</strong> 整数。</p><p>如果 <code>nums</code> 满足以下条件，那么它是 <strong>连续的</strong> ：</p><ul><li><code>nums</code> 中所有元素都是 <strong>互不相同</strong> 的。</li><li><code>nums</code> 中 <strong>最大</strong> 元素与 <strong>最小</strong> 元素的差等于 <code>nums.length - 1</code> 。</li></ul><p>比方说， <code>nums = [4, 2, 5, 3]</code> 是 <strong>连续的</strong> ，但是 <code>nums = [1, 2, 3, 5, 6]</code> <strong>不是连续的</strong> 。</p><p>请你返回使 <code>nums</code> <strong>连续</strong> 的 <strong>最少</strong> 操作次数。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4,2,5,3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums 已经是连续的了。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[1,2,3,5,6]</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：一个可能的解是将最后一个元素变为 <span class="number">4</span> 。</span><br><span class="line">结果数组为 <span class="string">[1,2,3,5,4]</span> ，是连续数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,10,100,1000]</span><br><span class="line">输出：3</span><br><span class="line">解释：一个可能的解是：</span><br><span class="line"><span class="bullet">- </span>将第二个元素变为 2 。</span><br><span class="line"><span class="bullet">- </span>将第三个元素变为 3 。</span><br><span class="line"><span class="bullet">- </span>将第四个元素变为 4 。</span><br><span class="line">结果数组为 [1,2,3,4] ，是连续数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 109</code></li></ul><p>方法一：去重 + 排序 + 滑动窗口<br>思路</p><p>记数组 nums 的长度为 n。经过若干次操作后，若数组变为连续的，那么数组的长度不会改变，仍然为 n，且数组最大值与最小值之差为 n−1，所有元素均不相同。可以反向考虑，假设最后连续的数组的最小值为 left，则最大值 right=left+n−1。原数组 nums 中，如果有位于 [left,right] 中的，如果只出现一次，我们可以对其进行保留；多次出现时，我们则需要对其进行操作；不在这个区间的数字，我们也需要对其进行操作，将它们变成其他数字来对这个区间进行补足。因此，我们需要统计原数组 nums 中，位于区间 [left,right] 内不同的数字个数 k，而 n−k 就是我们需要进行的操作数。</p><p>接下来就是需要确定 left，我们可以将原数组 nums 所有不同的数字作为 left 的候选值，分别计算出 n−k，然后求出最小值。这样的话，我们可以先将原数字进行去重后排序，然后利用滑动窗口。滑动窗口左端点的值作为 left，然后向右扩展右端点，窗口的长度即为 k，求出所有可能性下最小的 n−k 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">myset</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedUniqueNums</span><span class="params">(myset.begin(),myset.end())</span></span>;</span><br><span class="line">    <span class="built_in">sort</span>(sortedUniqueNums.<span class="built_in">begin</span>(),sortedUniqueNums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> result = length , j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;sortedUniqueNums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">       <span class="comment">// 确定最大值，即在确定左边界时，如果连续的话，右边最大的值</span></span><br><span class="line">       <span class="type">int</span> right = sortedUniqueNums[i] + length - <span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 因为数组是已经排好序的了，所以确定好左边界，依次去遍历之后的</span></span><br><span class="line">       <span class="comment">// 找到数组中存在于[left,right] 之间的数到底有几个，如果有 k 个</span></span><br><span class="line">       <span class="comment">// 那么该确定的区间，就有 n - k 个需要修改的值</span></span><br><span class="line">       <span class="comment">// 而且不用每次都从 left 开始，因为数组时递增的，相对于后面较大的left ，肯定对应较大的right </span></span><br><span class="line">       <span class="comment">// 所以后面的right 只会让受限制的最大的 j 更靠右，而不会更靠左 </span></span><br><span class="line">       <span class="keyword">while</span>(j &lt; sortedUniqueNums.<span class="built_in">size</span>() &amp;&amp; sortedUniqueNums[j] &lt;=right)&#123;</span><br><span class="line">           <span class="comment">// 不断更新维护最大值</span></span><br><span class="line">           result = <span class="built_in">min</span>(result, length - (j - i + <span class="number">1</span>));</span><br><span class="line">           j ++;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="42-接雨水"><a class="anchor" href="#42-接雨水">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90cmFwcGluZy1yYWluLXdhdGVyLw==">42. 接雨水</span></h4><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：height = [<span class="number">0,1,0,2</span>,<span class="number">1,0,1,3</span>,<span class="number">2,1,2,1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上面是由数组 [<span class="number">0,1,0,2</span>,<span class="number">1,0,1,3</span>,<span class="number">2,1,2,1</span>] 表示的高度图，在这种情况下，可以接 <span class="number">6</span> 个单位的雨水（蓝色部分表示雨水）。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：height = <span class="string">[4,2,0,3,2,5]</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == height.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 105</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 遍历寻找每一个山谷</span></span><br><span class="line">    <span class="comment">// 两次遍历，相当于左边遍历，记录每一个位置左边的最大高度</span></span><br><span class="line">    <span class="comment">// 第二次从右往左的遍历，记录每一个位置上右边的最大高度</span></span><br><span class="line">    <span class="comment">// 然后根据每一个位置上，左右两边的最大高度中的最小值（短板效应）来作为能盛下的水的最大高度</span></span><br><span class="line">    <span class="comment">// 然后每一个位置上能容下的水的最大高度减去原有的高度，再乘以宽（宽为1）就是每一个位置上最多能够容下的水量</span></span><br><span class="line">       <span class="type">int</span> length = height.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(length)</span>,<span class="title">right</span><span class="params">(length)</span></span>;</span><br><span class="line">       left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">           left[i] = <span class="built_in">max</span>(height[i] ,left[i<span class="number">-1</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       right[length<span class="number">-1</span>] = height[length<span class="number">-1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = length - <span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">         right[i] = <span class="built_in">max</span>(height[i] , right[i<span class="number">+1</span>]);</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">          result += <span class="built_in">min</span>(left[i] ,right[i]) - height[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="135-分发糖果"><a class="anchor" href="#135-分发糖果">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW5keS8=">135. 分发糖果</span></h4><p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p><p>你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：ratings </span>=<span class="string"> [1,0,2]</span></span><br><span class="line"><span class="string">输出：5</span></span><br><span class="line"><span class="string">解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：ratings </span>=<span class="string"> [1,2,2]</span></span><br><span class="line"><span class="string">输出：4</span></span><br><span class="line"><span class="string">解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。</span></span><br><span class="line"><span class="string">     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == ratings.length</code></li><li><code>1 &lt;= n &lt;= 2 * 104</code></li><li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 属于是两次遍历，第一次遍历检索递增部分，第二次检索递减部分</span></span><br><span class="line"> <span class="comment">// 然后将两者合并,就可以了</span></span><br><span class="line"> <span class="type">int</span> length = ratings.<span class="built_in">size</span>();</span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt;  <span class="title">left</span><span class="params">(length)</span></span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; ratings[i] &gt; ratings[i<span class="number">-1</span>])&#123;</span><br><span class="line">       <span class="comment">// 因为要满足旁边大的要多</span></span><br><span class="line">       left[i] = left[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">// 第二次遍历，检索递减部分的，可以逆序遍历，递增的部分</span></span><br><span class="line">  <span class="comment">// 在遍历的同时不断合并两个部分的结果,并整合最终的结果</span></span><br><span class="line">  <span class="type">int</span> right  = <span class="number">0</span> ,result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = length - <span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; length - <span class="number">1</span> &amp;&amp; ratings[j]  &gt; ratings[j + <span class="number">1</span>])&#123;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        right = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result += <span class="built_in">max</span>(left[j] ,right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2642-设计可以求最短路径的图类"><a class="anchor" href="#2642-设计可以求最短路径的图类">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZXNpZ24tZ3JhcGgtd2l0aC1zaG9ydGVzdC1wYXRoLWNhbGN1bGF0b3Iv">2642. 设计可以求最短路径的图类</span></h4><p>给你一个有 <code>n</code> 个节点的 <strong>有向带权</strong> 图，节点编号为 <code>0</code> 到 <code>n - 1</code> 。图中的初始边用数组 <code>edges</code> 表示，其中 <code>edges[i] = [fromi, toi, edgeCosti]</code> 表示从 <code>fromi</code> 到 <code>toi</code> 有一条代价为 <code>edgeCosti</code> 的边。</p><p>请你实现一个 <code>Graph</code> 类：</p><ul><li><code>Graph(int n, int[][] edges)</code> 初始化图有 <code>n</code> 个节点，并输入初始边。</li><li><code>addEdge(int[] edge)</code> 向边集中添加一条边，其中 <code>edge = [from, to, edgeCost]</code> 。数据保证添加这条边之前对应的两个节点之间没有有向边。</li><li><code>int shortestPath(int node1, int node2)</code> 返回从节点 <code>node1</code> 到 <code>node2</code> 的路径 <strong>最小</strong> 代价。如果路径不存在，返回 <code>-1</code> 。一条路径的代价是路径中所有边代价之和。</li></ul><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;Graph&quot;</span>, <span class="string">&quot;shortestPath&quot;</span>, <span class="string">&quot;shortestPath&quot;</span>, <span class="string">&quot;addEdge&quot;</span>, <span class="string">&quot;shortestPath&quot;</span>]</span><br><span class="line">[[<span class="number">4</span>, [[<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>]]], [<span class="number">3</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>], [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]], [<span class="number">0</span>, <span class="number">3</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">6</span>, <span class="number">-1</span>, null, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"><span class="symbol">Graph</span> g = new <span class="symbol">Graph</span>(<span class="number">4</span>, [[<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>]]);</span><br><span class="line">g.shortestPath(<span class="number">3</span>, <span class="number">2</span>); // 返回 <span class="number">6</span> 。从 <span class="number">3</span> 到 <span class="number">2</span> 的最短路径如第一幅图所示：<span class="number">3</span> -&gt; <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> ，总代价为 <span class="number">3</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">6</span> 。</span><br><span class="line">g.shortestPath(<span class="number">0</span>, <span class="number">3</span>); // 返回 <span class="number">-1</span> 。没有从 <span class="number">0</span> 到 <span class="number">3</span> 的路径。</span><br><span class="line">g.addEdge([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]); // 添加一条节点 <span class="number">1</span> 到节点 <span class="number">3</span> 的边，得到第二幅图。</span><br><span class="line">g.shortestPath(<span class="number">0</span>, <span class="number">3</span>); // 返回 <span class="number">6</span> 。从 <span class="number">0</span> 到 <span class="number">3</span> 的最短路径为 <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">3</span> ，总代价为 <span class="number">2</span> + <span class="number">4</span> = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= edges.length &lt;= n * (n - 1)</code></li><li><code>edges[i].length == edge.length == 3</code></li><li><code>0 &lt;= fromi, toi, from, to, node1, node2 &lt;= n - 1</code></li><li><code>1 &lt;= edgeCosti, edgeCost &lt;= 106</code></li><li>图中任何时候都不会有重边和自环。</li><li>调用 <code>addEdge</code> 至多 <code>100</code> 次。</li><li>调用 <code>shortestPath</code> 至多 <code>100</code> 次。</li></ul><p><strong>迪杰斯特拉算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graph</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;edg.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:<span class="keyword">this</span>-&gt;edg)&#123;</span><br><span class="line">            e.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;n,<span class="keyword">this</span>-&gt;inf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>-&gt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;edg[i][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;e:edges)&#123;</span><br><span class="line">           <span class="keyword">this</span>-&gt;edg[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = e[<span class="number">2</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// for(auto &amp;ed:this-&gt;edg)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto &amp; e:ed)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; edge)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>-&gt;edg[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestPath</span><span class="params">(<span class="type">int</span> node1, <span class="type">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(<span class="keyword">this</span>-&gt;n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt;  <span class="title">dis</span><span class="params">(<span class="keyword">this</span>-&gt;n,<span class="keyword">this</span>-&gt;inf)</span></span>;</span><br><span class="line">        dis[node1] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> node = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; <span class="keyword">this</span>-&gt;n - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">// 找到最短距离的点</span></span><br><span class="line">            node = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;<span class="keyword">this</span>-&gt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[j] &amp;&amp; (node ==<span class="number">-1</span> || dis[j]  &lt; dis[node]))&#123;</span><br><span class="line">                    node = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 更新松弛</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;<span class="keyword">this</span>-&gt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[j]) </span><br><span class="line">                     dis[j] = <span class="built_in">min</span>(dis[j],dis[node] + <span class="keyword">this</span>-&gt;edg[node][j] );</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">               vis[node] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[node2]&lt;<span class="keyword">this</span>-&gt;inf ? dis[node2] : <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       <span class="type">int</span> n;</span><br><span class="line">       <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">       vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Graph object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Graph* obj = new Graph(n, edges);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addEdge(edge);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;shortestPath(node1,node2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="lcp-24-数字游戏"><a class="anchor" href="#lcp-24-数字游戏">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy81VHhLZUsv">LCP 24. 数字游戏</span></h4><p>小扣在秋日市集入口处发现了一个数字游戏。主办方共有 <code>N</code> 个计数器，计数器编号为 <code>0 ~ N-1</code> 。每个计数器上分别显示了一个数字，小扣按计数器编号升序将所显示的数字记于数组 <code>nums</code> 。每个计数器上有两个按钮，分别可以实现将显示数字加一或减一。小扣每一次操作可以选择一个计数器，按下加一或减一按钮。</p><p>主办方请小扣回答出一个长度为 <code>N</code> 的数组，第 <code>i</code> 个元素 (0 &lt;= i &lt; N) 表示将 <code>0~i</code> 号计数器 <strong>初始</strong> 所示数字操作成满足所有条件 <code>nums[a]+1 == nums[a+1],(0 &lt;= a &lt; i)</code> 的最小操作数。回答正确方可进入秋日市集。</p><p>由于答案可能很大，请将每个最小操作数对 <code>1,000,000,007</code> 取余。</p><p><strong>示例 1：</strong></p><blockquote><p>输入： <code>nums = [3,4,5,1,6,7]</code></p><p>输出： <code>[0,0,0,5,6,7]</code></p><p>解释： i = 0，[3] 无需操作 i = 1，[3,4] 无需操作； i = 2，[3,4,5] 无需操作； i = 3，将 [3,4,5,1] 操作成 [3,4,5,6], 最少 5 次操作； i = 4，将 [3,4,5,1,6] 操作成 [3,4,5,6,7], 最少 6 次操作； i = 5，将 [3,4,5,1,6,7] 操作成 [3,4,5,6,7,8]，最少 7 次操作； 返回 [0,0,0,5,6,7]。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入： <code>nums = [1,2,3,4,5]</code></p><p>输出： <code>[0,0,0,0,0]</code></p><p>解释：对于任意计数器编号 i 都无需操作。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入： <code>nums = [1,1,1,2,3,4]</code></p><p>输出： <code>[0,1,2,3,3,3]</code></p><p>解释： i = 0，无需操作； i = 1，将 [1,1] 操作成 [1,2] 或 [0,1] 最少 1 次操作； i = 2，将 [1,1,1] 操作成 [1,2,3] 或 [0,1,2]，最少 2 次操作； i = 3，将 [1,1,1,2] 操作成 [1,2,3,4] 或 [0,1,2,3]，最少 3 次操作； i = 4，将 [1,1,1,2,3] 操作成 [-1,0,1,2,3]，最少 3 次操作； i = 5，将 [1,1,1,2,3,4] 操作成 [-1,0,1,2,3,4]，最少 3 次操作； 返回 [0,1,2,3,3,3]。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^3</code></li></ul><p>方法一：双优先队列</p><p>将 [0,i] 范围内的计数器初始所示数字操作成满足所有条件 nums [j] + 1 == nums [j+1] , 等价于将 nums [j] - j ，操作成相同的数字，因此先对 nums 做预处理，即令 nums [i] = nums [i] - i, 将区间 [0,i][0, i][0,i] 范围内的数字操作成相同的数字的最小操作数，等于将区间 [0,i] 范围内的数字操作成它们的中位数所需要的操作数。证明过程可以参考题目 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLW1vdmVzLXRvLWVxdWFsLWFycmF5LWVsZW1lbnRzLWlpL3NvbHV0aW9ucy8xNTAxMjMwL3p1aS1zaGFvLXlpLWRvbmctY2ktc2h1LXNoaS1zaHUtenUteXVhbi14dDNyMi8=">462. 最小操作次数使数组元素相等 II</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numsGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; lower;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; upper;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> lowerSum = <span class="number">0</span>, upperSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i] - i;</span><br><span class="line">            <span class="keyword">if</span> (lower.<span class="built_in">empty</span>() || lower.<span class="built_in">top</span>() &gt;= x) &#123;</span><br><span class="line">                lowerSum += x;</span><br><span class="line">                lower.<span class="built_in">push</span>(x);</span><br><span class="line">                <span class="keyword">if</span> (lower.<span class="built_in">size</span>() &gt; upper.<span class="built_in">size</span>() + <span class="number">1</span>) &#123;</span><br><span class="line">                    upperSum += lower.<span class="built_in">top</span>();</span><br><span class="line">                    upper.<span class="built_in">push</span>(lower.<span class="built_in">top</span>());</span><br><span class="line">                    lowerSum -= lower.<span class="built_in">top</span>();</span><br><span class="line">                    lower.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                upperSum += x;</span><br><span class="line">                upper.<span class="built_in">push</span>(x);</span><br><span class="line">                <span class="keyword">if</span> (lower.<span class="built_in">size</span>() &lt; upper.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    lowerSum += upper.<span class="built_in">top</span>();</span><br><span class="line">                    lower.<span class="built_in">push</span>(upper.<span class="built_in">top</span>());</span><br><span class="line">                    upperSum -= upper.<span class="built_in">top</span>();</span><br><span class="line">                    upper.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                res[i] = (upperSum - lowerSum) % mod;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = (upperSum - lowerSum + lower.<span class="built_in">top</span>()) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2617-网格图中最少访问的格子数"><a class="anchor" href="#2617-网格图中最少访问的格子数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLW51bWJlci1vZi12aXNpdGVkLWNlbGxzLWluLWEtZ3JpZC8=">2617. 网格图中最少访问的格子数</span></h4><p>给你一个下标从 <strong>0</strong> 开始的 <code>m x n</code> 整数矩阵 <code>grid</code> 。你一开始的位置在 <strong>左上角</strong> 格子 <code>(0, 0)</code> 。</p><p>当你在格子 <code>(i, j)</code> 的时候，你可以移动到以下格子之一：</p><ul><li>满足 <code>j &lt; k &lt;= grid[i][j] + j</code> 的格子 <code>(i, k)</code> （向右移动），或者</li><li>满足 <code>i &lt; k &lt;= grid[i][j] + i</code> 的格子 <code>(k, j)</code> （向下移动）。</li></ul><p>请你返回到达 <strong>右下角</strong> 格子 <code>(m - 1, n - 1)</code> 需要经过的最少移动格子数，如果无法到达右下角格子，请你返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2023/01/25/ex1.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="comment">[<span class="comment">[3,4,2,1]</span>,<span class="comment">[4,2,3,1]</span>,<span class="comment">[2,1,0,0]</span>,<span class="comment">[2,4,0,0]</span>]</span></span><br><span class="line">输出：4</span><br><span class="line">解释：上图展示了到达右下角格子经过的 4 个格子。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2023/01/25/ex2.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="comment">[<span class="comment">[3,4,2,1]</span>,<span class="comment">[4,2,1,1]</span>,<span class="comment">[2,1,1,0]</span>,<span class="comment">[3,4,1,0]</span>]</span></span><br><span class="line">输出：3</span><br><span class="line">解释：上图展示了到达右下角格子经过的 3 个格子。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2023/01/26/ex3.png" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[2,1,0],[1,0,0]]</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：无法到达右下角格子。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>0 &lt;= grid[i][j] &lt; m * n</code></li><li><code>grid[m - 1][n - 1] == 0</code></li></ul><p>一般思路：深度优先搜索 (但超时了)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ISreach</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> a + b &gt;= c;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">minimumVisitedCells</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 判断是否能够到达这个点</span></span><br><span class="line">       <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> result = m + n;</span><br><span class="line">       function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x ,<span class="type">int</span> y,<span class="type">int</span> step)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(x==m<span class="number">-1</span> &amp;&amp; y==n<span class="number">-1</span>) &#123;</span><br><span class="line">               result = <span class="built_in">min</span>(result,step);</span><br><span class="line">               <span class="keyword">return</span> ;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 循环遍历后续能到达的节点</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i = x<span class="number">+1</span>;i&lt;m;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="built_in">ISreach</span>(grid[x][y],x,i))&#123;</span><br><span class="line">                   <span class="built_in">dfs</span>(i,y,step + <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j = y<span class="number">+1</span>;j&lt;n;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="built_in">ISreach</span>(grid[x][y],y,j))&#123;</span><br><span class="line">                   <span class="built_in">dfs</span>(x,j,step + <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span>(result &lt; m + n)&#123;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>优先队列方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumVisitedCells</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为每一个行和每一列都构造一个对应的优先队列</span></span><br><span class="line">        vector&lt;priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt;&gt; <span class="built_in">row</span>(m), <span class="built_in">col</span>(n);</span><br><span class="line">        <span class="comment">// 更新函数</span></span><br><span class="line">        <span class="keyword">auto</span> update = [](<span class="type">int</span>&amp; x, <span class="type">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">-1</span> || y &lt; x) &#123;</span><br><span class="line">                x = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 二重遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="comment">// 如果队列非空，并且此时堆顶元素（即该行最小步数位置）不能直接一步到达该位置，就弹出，直到找到</span></span><br><span class="line">                <span class="comment">// 能够一步到达该位置的最小步数位置</span></span><br><span class="line">                <span class="keyword">while</span> (!row[i].<span class="built_in">empty</span>() &amp;&amp; row[i].<span class="built_in">top</span>().second + grid[i][row[i].<span class="built_in">top</span>().second] &lt; j) &#123;</span><br><span class="line">                    row[i].<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断一下是否找到，如果没有找到，说明此时的优先队列已经为空</span></span><br><span class="line">                <span class="comment">// 反之，如果找到了，说明此时队列肯定非空，此时就更新该位置的最小步数</span></span><br><span class="line">                <span class="keyword">if</span> (!row[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="built_in">update</span>(dist[i][j], dist[i][row[i].<span class="built_in">top</span>().second] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 同理，每一列也这么处理</span></span><br><span class="line">                <span class="keyword">while</span> (!col[j].<span class="built_in">empty</span>() &amp;&amp; col[j].<span class="built_in">top</span>().second + grid[col[j].<span class="built_in">top</span>().second][j] &lt; i) &#123;</span><br><span class="line">                    col[j].<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!col[j].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="built_in">update</span>(dist[i][j], dist[col[j].<span class="built_in">top</span>().second][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理完之后，判断该位置是否能到达</span></span><br><span class="line">                <span class="comment">// 如果能够到达，就不等于初始设置的-1</span></span><br><span class="line">                <span class="comment">// 将此时的经过（综合左边来的，和上边来的）得出的最小值</span></span><br><span class="line">                <span class="comment">// 更新在该行和该列的优先队列中，以便下一个点使用</span></span><br><span class="line">                <span class="keyword">if</span> (dist[i][j] != <span class="number">-1</span>) &#123;</span><br><span class="line">                    row[i].<span class="built_in">emplace</span>(dist[i][j], j);</span><br><span class="line">                    col[j].<span class="built_in">emplace</span>(dist[i][j], i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后就返回到达右下角的最小步数</span></span><br><span class="line">        <span class="keyword">return</span> dist[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">auto</span> bijiao = [](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; x ,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">     &#125;;</span><br><span class="line">     function&lt;<span class="type">bool</span>(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;)&gt; bijiao2 = [](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; x,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; y)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">     &#125;;</span><br><span class="line">     priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,<span class="keyword">decltype</span>(bijiao2)&gt; <span class="built_in">que</span>(bijiao2);</span><br><span class="line">     que.<span class="built_in">emplace</span>(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">     que.<span class="built_in">emplace</span>(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">     que.<span class="built_in">emplace</span>(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">     <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; que.<span class="built_in">top</span>().first &lt;&lt; que.<span class="built_in">top</span>().second &lt;&lt; endl;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1793-好子数组的最大分数"><a class="anchor" href="#1793-好子数组的最大分数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXNjb3JlLW9mLWEtZ29vZC1zdWJhcnJheS8=">1793. 好子数组的最大分数</span></h4><p>给你一个整数数组 <code>nums</code> **（下标从 0 开始）** 和一个整数 <code>k</code> 。</p><p>一个子数组 <code>(i, j)</code> 的 <strong>分数</strong> 定义为 <code>min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1)</code> 。一个 <strong>好</strong> 子数组的两个端点下标需要满足 <code>i &lt;= k &lt;= j</code> 。</p><p>请你返回 <strong>好</strong> 子数组的最大可能 <strong>分数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,4,3,7,4,5], k = 3</span><br><span class="line">输出：15</span><br><span class="line">解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) =<span class="number"> 3 </span>*<span class="number"> 5 </span>=<span class="number"> 15 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5,5,4,5</span>,<span class="number">4,1,1,1</span>], k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：最优子数组的左右端点下标是 (<span class="number">0</span>, <span class="number">4</span>) ，分数为 min(<span class="number">5,5,4,5</span>,<span class="number">4</span>) * (<span class="number">4</span>-<span class="number">0</span>+<span class="number">1</span>) = <span class="number">4</span> * <span class="number">5</span> = <span class="number">20</span> 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 2 * 104</code></li><li>`0 &lt;= k &lt; nums.length</li></ul><p>双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maximumScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 因为满足条件的好子数组必须得包含nums[k]</span></span><br><span class="line">   <span class="comment">// 所以以nums[k]为中心，两边不断更新不断降低</span></span><br><span class="line">   <span class="comment">// 最小值的标准，然后维护每一步中的最大值</span></span><br><span class="line">   <span class="type">int</span> left = k - <span class="number">1</span>,right = k<span class="number">+1</span>;</span><br><span class="line">   <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">   <span class="type">int</span> result = <span class="number">0</span> ; <span class="comment">// 结果</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i= nums[k];;i--)&#123;</span><br><span class="line">    <span class="comment">// 找到第一个区间，以nums[k]为最小值，不断扩大区间，因为求的是最大值</span></span><br><span class="line">    <span class="comment">// 所以在确定区间最小值之后，应尽可能扩大区间长度，使得数组分数极大</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.确定区间最小值之后，走到最左边的点</span></span><br><span class="line">    <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; nums[left]&gt;=i)&#123;</span><br><span class="line">        left --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; length &amp;&amp; nums[right]&gt;=i)&#123;</span><br><span class="line">        right ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算此时的对于确定的区间最小值，所能得到的最大值，并且更新并维护最大值、</span></span><br><span class="line">    result = <span class="built_in">max</span>(result,(right-left <span class="number">-1</span>)*i);</span><br><span class="line">    <span class="comment">// 因为按照区间最小值从大到小来遍历的，所以如果要想得到最大值，必须递增遍历</span></span><br><span class="line">    <span class="comment">// 所以区间长度必须是越来越大，这样才合理，直到不能继续，才算遍历完全</span></span><br><span class="line">    <span class="comment">// 退出循环</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; <span class="number">0</span> &amp;&amp; right &gt;=length)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line">    <span class="type">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">maximumScore</span>(nums,k);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2312-卖木头块"><a class="anchor" href="#2312-卖木头块">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWxsaW5nLXBpZWNlcy1vZi13b29kLw==">2312. 卖木头块</span></h4><p>给你两个整数 <code>m</code> 和 <code>n</code> ，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组 <code>prices</code> ，其中 <code>prices[i] = [hi, wi, pricei]</code> 表示你可以以 <code>pricei</code> 元的价格卖一块高为 <code>hi</code> 宽为 <code>wi</code> 的矩形木块。</p><p>每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：</p><ul><li>沿垂直方向按高度 <strong>完全</strong> 切割木块，或</li><li>沿水平方向按宽度 <strong>完全</strong> 切割木块</li></ul><p>在将一块木块切成若干小木块后，你可以根据 <code>prices</code> 卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 <strong>不能</strong> 旋转切好后木块的高和宽。</p><p>请你返回切割一块大小为 <code>m x n</code> 的木块后，能得到的 <strong>最多</strong> 钱数。</p><p>注意你可以切割木块任意次。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2022/04/27/ex1.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]</span><br><span class="line">输出：19</span><br><span class="line">解释：上图展示了一个可行的方案。包括：</span><br><span class="line">-<span class="number"> 2 </span>块<span class="number"> 2 </span>x<span class="number"> 2 </span>的小木块，售出<span class="number"> 2 </span>*<span class="number"> 7 </span>=<span class="number"> 14 </span>元。</span><br><span class="line">-<span class="number"> 1 </span>块<span class="number"> 2 </span>x<span class="number"> 1 </span>的小木块，售出<span class="number"> 1 </span>*<span class="number"> 3 </span>=<span class="number"> 3 </span>元。</span><br><span class="line">-<span class="number"> 1 </span>块<span class="number"> 1 </span>x<span class="number"> 4 </span>的小木块，售出<span class="number"> 1 </span>*<span class="number"> 2 </span>=<span class="number"> 2 </span>元。</span><br><span class="line">总共售出<span class="number"> 14 </span>+<span class="number"> 3 </span>+<span class="number"> 2 </span>=<span class="number"> 19 </span>元。</span><br><span class="line">19 元是最多能得到的钱数。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2022/04/27/ex2new.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]</span><br><span class="line">输出：32</span><br><span class="line">解释：上图展示了一个可行的方案。包括：</span><br><span class="line">-<span class="number"> 3 </span>块<span class="number"> 3 </span>x<span class="number"> 2 </span>的小木块，售出<span class="number"> 3 </span>*<span class="number"> 10 </span>=<span class="number"> 30 </span>元。</span><br><span class="line">-<span class="number"> 1 </span>块<span class="number"> 1 </span>x<span class="number"> 4 </span>的小木块，售出<span class="number"> 1 </span>*<span class="number"> 2 </span>=<span class="number"> 2 </span>元。</span><br><span class="line">总共售出<span class="number"> 30 </span>+<span class="number"> 2 </span>=<span class="number"> 32 </span>元。</span><br><span class="line">32 元是最多能得到的钱数。</span><br><span class="line">注意我们不能旋转<span class="number"> 1 </span>x<span class="number"> 4 </span>的木块来得到<span class="number"> 4 </span>x<span class="number"> 1 </span>的木块。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= prices.length &lt;= 2 * 104</code></li><li><code>prices[i].length == 3</code></li><li><code>1 &lt;= hi &lt;= m</code></li><li><code>1 &lt;= wi &lt;= n</code></li><li><code>1 &lt;= pricei &lt;= 106</code></li><li>所有 <code>(hi, wi)</code> <strong>互不相同</strong> 。</li></ul><p><strong>记忆化搜索</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 官方题解，主要思路：动态规划+记忆化搜索</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sellingWood_memorySearch</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自定义计算哈希值（默认哈希方式是乘法哈希）</span></span><br><span class="line">        <span class="keyword">auto</span> pair_hash = [fn = <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; o) -&gt; <span class="type">size_t</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">fn</span>(o.first) &lt;&lt; <span class="number">16</span>) ^ <span class="built_in">fn</span>(o.second);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据自定义的哈希函数 （指定桶的数量为0，就是根据负载因子自动调整桶的数量） </span></span><br><span class="line">        unordered_map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>, <span class="keyword">decltype</span>(pair_hash)&gt; <span class="built_in">value</span>(<span class="number">0</span>, pair_hash);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 记忆存储器</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">memo</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">long</span> <span class="type">long</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">long</span> <span class="type">long</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果此时遍历的位置之前已经遍历过，并且得到了结果，就可以直接返回</span></span><br><span class="line">            <span class="comment">// 这也是记忆化搜索的核心思想</span></span><br><span class="line">            <span class="keyword">if</span> (memo[x][y] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[x][y];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> ret = value.<span class="built_in">count</span>(&#123;x, y&#125;) ? value[&#123;x, y&#125;] : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果x大于1，说明可以继续分割</span></span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 在(0，x)找到合适的分隔点，使得dfs(i, y) + dfs(x - i, y)最大</span></span><br><span class="line">                <span class="comment">// 即分成的两块价值和最大</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; x; ++i) &#123;</span><br><span class="line">                    ret = <span class="built_in">max</span>(ret, <span class="built_in">dfs</span>(i, y) + <span class="built_in">dfs</span>(x - i, y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 如果y大于1，说明可以继续分割</span></span><br><span class="line">            <span class="keyword">if</span> (y &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在(0，y)找到合适的分隔点，使得dfs(x, j) + dfs(x, y - j)最大</span></span><br><span class="line">                <span class="comment">// 即分成的两块价值和最大</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; y; ++j) &#123;</span><br><span class="line">                    ret = <span class="built_in">max</span>(ret, <span class="built_in">dfs</span>(x, j) + <span class="built_in">dfs</span>(x, y - j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> memo[x][y] = ret;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 利用prices数组，构建map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            value[&#123;prices[i][<span class="number">0</span>], prices[i][<span class="number">1</span>]&#125;] = prices[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用函数，返回结果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(m, n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 官方题解，主要思路：动态规划+记忆化搜索</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sellingWood_dp</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 根据题目要求 确定最大dp数组</span></span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> dp[<span class="number">201</span>][<span class="number">201</span>] = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 将已经存在的木块大小，以及价格提前初始化</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> &amp;v : prices ) &#123;</span><br><span class="line">            dp[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = v[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从上到下，从左到右进行打表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 在(0,i)中间选择合适的切割点，使得两部分的价值和最大（因为两边对称所以只用遍历到一半就行）</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> cut = <span class="number">1</span>; cut &lt;= i / <span class="number">2</span>; cut++) dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[cut][j] + dp[i - cut][j]);</span><br><span class="line">                <span class="comment">// 在(0,j)中间选择合适的切割点，使得两部分的价值和最大 （因为两边对称所以只用遍历到一半就行）</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> cut = <span class="number">1</span>; cut &lt;= j / <span class="number">2</span>; cut++) dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][cut] + dp[i][j - cut]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>动态规划</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sellingWood_dp</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 根据题目要求 确定最大dp数组</span></span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> dp[<span class="number">201</span>][<span class="number">201</span>] = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 将已经存在的木块大小，以及价格提前初始化</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> &amp;v : prices ) &#123;</span><br><span class="line">            dp[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = v[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从上到下，从左到右进行打表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 在(0,i)中间选择合适的切割点，使得两部分的价值和最大（因为两边对称所以只用遍历到一半就行）</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> cut = <span class="number">1</span>; cut &lt;= i / <span class="number">2</span>; cut++) dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[cut][j] + dp[i - cut][j]);</span><br><span class="line">                <span class="comment">// 在(0,j)中间选择合适的切割点，使得两部分的价值和最大 （因为两边对称所以只用遍历到一半就行）</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> cut = <span class="number">1</span>; cut &lt;= j / <span class="number">2</span>; cut++) dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][cut] + dp[i][j - cut]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="564-寻找最近的回文数"><a class="anchor" href="#564-寻找最近的回文数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC10aGUtY2xvc2VzdC1wYWxpbmRyb21lLw==">564. 寻找最近的回文数</span></h4><p>给定一个表示整数的字符串 <code>n</code> ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。</p><p>“最近的” 定义为两个整数<strong>差的绝对值</strong>最小。</p><p><strong>示例 1:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="symbol">:</span> <span class="built_in">n</span> = <span class="string">&quot;123&quot;</span></span><br><span class="line">输出<span class="symbol">:</span> <span class="string">&quot;121&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入<span class="symbol">:</span> <span class="built_in">n</span> = <span class="string">&quot;1&quot;</span></span><br><span class="line">输出<span class="symbol">:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">解释<span class="symbol">:</span> <span class="number">0</span> 和 <span class="number">2</span>是最近的回文，但我们返回最小的，也就是 <span class="number">0</span>。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nearestPalindromic</span>(<span class="params">self, n: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment">#计算出字符串的长度</span></span><br><span class="line">        m = <span class="built_in">len</span>(n)</span><br><span class="line">        <span class="comment">#构造出位数发生变化的那两种可能</span></span><br><span class="line">        candidates = [<span class="number">10</span> ** (m - <span class="number">1</span>) - <span class="number">1</span>, <span class="number">10</span> ** m + <span class="number">1</span>]</span><br><span class="line">        <span class="comment">#取出前半部分的数字</span></span><br><span class="line">        selfPrefix = <span class="built_in">int</span>(n[:(m + <span class="number">1</span>) // <span class="number">2</span>])</span><br><span class="line">        <span class="comment">#构造三种回文数字</span></span><br><span class="line">        <span class="comment">#用原数的前半部分替换后半部分得到的回文整数。</span></span><br><span class="line">        <span class="comment">#用原数的前半部分加一后的结果替换后半部分得到的回文整数。</span></span><br><span class="line">        <span class="comment">#用原数的前半部分减一后的结果替换后半部分得到的回文整数。</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(selfPrefix - <span class="number">1</span>, selfPrefix + <span class="number">2</span>):</span><br><span class="line">            y = x <span class="keyword">if</span> m % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> x // <span class="number">10</span></span><br><span class="line">            <span class="keyword">while</span> y:</span><br><span class="line">                x = x * <span class="number">10</span> + y % <span class="number">10</span></span><br><span class="line">                y //= <span class="number">10</span></span><br><span class="line">            candidates.append(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#从构造的回文数字中找到符合题意的最好的</span></span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        selfNumber = <span class="built_in">int</span>(n)</span><br><span class="line">        <span class="keyword">for</span> candidate <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="keyword">if</span> candidate != selfNumber:</span><br><span class="line">                <span class="keyword">if</span> ans == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(candidate - selfNumber) &lt; <span class="built_in">abs</span>(ans - selfNumber) <span class="keyword">or</span> <span class="built_in">abs</span>(candidate - selfNumber) == <span class="built_in">abs</span>(ans - selfNumber) <span class="keyword">and</span> candidate &lt; ans:</span><br><span class="line">                    ans = candidate</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-无重复字符的最长子串"><a class="anchor" href="#3-无重复字符的最长子串">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy8=">3. 无重复字符的最长子串</span></h4><p>难度中等 7232</p><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="section">输出: 3 </span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="section">输出: 1</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: s = &quot;pwwkew&quot;</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span></span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h5 id="分析"><a class="anchor" href="#分析">#</a> 分析</h5><p>具体还是一种滑动窗口思路，窗口边界只允许向右移动，当左边界向右移动的时候，有两种情况</p><ul><li>窗口内不存在重复的字符，则继续向右进行移动，边移动，边记录当前的字符出现过的次数，并且检查出现过的字符是否有重复的</li><li>窗口内因为新加入的字符导致拥有重复的字符，刷新最大不重复子串的长度；此时，左边界开始向右移动，直到窗口不存在重复字符为止</li></ul><p>最终的长度的就是所要的最大不重复子串长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//定义数组用来存储字符第一次出现的位置</span></span><br><span class="line">      <span class="type">int</span>  loads[<span class="number">128</span>];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">128</span>;i++)</span><br><span class="line">          loads[i]=<span class="number">-1</span>;</span><br><span class="line">      <span class="type">int</span>  start=<span class="number">0</span>,result=<span class="number">0</span>,len = s.<span class="built_in">length</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        </span><br><span class="line">          <span class="comment">//字符在之前出现过,就将最长子串的开口移到该子串中第一个出现的字符的位置的下一个,</span></span><br><span class="line">          start = loads[s[i]]&gt;=start ? loads[s[i]]<span class="number">+1</span> :start;</span><br><span class="line">          <span class="comment">//比较现在的子串长度和之前的子串的长度的大小，选择最大的</span></span><br><span class="line">          result = result&gt;=i-start<span class="number">+1</span> ? result :i-start<span class="number">+1</span>;</span><br><span class="line">          <span class="comment">//把位置存放进数组中</span></span><br><span class="line">          loads[s[i]] = i;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2024-考试的最大困扰度"><a class="anchor" href="#2024-考试的最大困扰度">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWF4aW1pemUtdGhlLWNvbmZ1c2lvbi1vZi1hbi1leGFtLw==">2024. 考试的最大困扰度</span></h4><p>难度中等 66</p><p>一位老师正在出一场由 <code>n</code> 道判断题构成的考试，每道题的答案为 true （用 <code>'T'</code> 表示）或者 false （用 <code>'F'</code> 表示）。老师想增加学生对自己做出答案的不确定性，方法是 <strong>最大化</strong> 有 <strong>连续相同</strong> 结果的题数。（也就是连续出现 true 或者连续出现 false）。</p><p>给你一个字符串 <code>answerKey</code> ，其中 <code>answerKey[i]</code> 是第 <code>i</code> 个问题的正确结果。除此以外，还给你一个整数 <code>k</code> ，表示你能进行以下操作的最多次数：</p><ul><li>每次操作中，将问题的正确答案改为 <code>'T'</code> 或者 <code>'F'</code> （也就是将 <code>answerKey[i]</code> 改为 <code>'T'</code> 或者 <code>'F'</code> ）。</li></ul><p>请你返回在不超过 <code>k</code> 次操作的情况下，<strong>最大</strong> 连续 <code>'T'</code> 或者 <code>'F'</code> 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：answerKey <span class="punctuation">=</span> <span class="string">&quot;TTFF&quot;</span><span class="punctuation">,</span> k <span class="punctuation">=</span> <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：我们可以将两个 &#x27;F&#x27; 都变为 &#x27;T&#x27; ，得到 answerKey <span class="punctuation">=</span> <span class="string">&quot;TTTT&quot;</span> 。</span><br><span class="line">总共有四个连续的 &#x27;T&#x27; 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：answerKey <span class="punctuation">=</span> <span class="string">&quot;TFFT&quot;</span><span class="punctuation">,</span> k <span class="punctuation">=</span> <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们可以将最前面的 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey <span class="punctuation">=</span> <span class="string">&quot;FFFT&quot;</span> 。</span><br><span class="line">或者，我们可以将第二个 &#x27;T&#x27; 换成 &#x27;F&#x27; ，得到 answerKey <span class="punctuation">=</span> <span class="string">&quot;TFFF&quot;</span> 。</span><br><span class="line">两种情况下，都有三个连续的 &#x27;F&#x27; 。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxConsecutiveAnswers</span>(<span class="params">self, answerKey: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#滑动窗口问题</span></span><br><span class="line">        left,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        lenght = <span class="built_in">len</span>(answerKey)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="comment">#寻找最长的可以替换掉的F字符而形成的字符串</span></span><br><span class="line">        <span class="keyword">while</span> right &lt;= lenght <span class="keyword">and</span> left&lt;=right:</span><br><span class="line">            <span class="keyword">if</span> right&lt;lenght <span class="keyword">and</span> answerKey[right]!=<span class="string">&quot;T&quot;</span> :</span><br><span class="line">                ans+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> ans == k+<span class="number">1</span> <span class="keyword">or</span> right==lenght:</span><br><span class="line">                result = result <span class="keyword">if</span> result &gt; (right-left) <span class="keyword">else</span> (right-left)</span><br><span class="line">                <span class="keyword">while</span> ans &gt;k <span class="keyword">and</span> left&lt;=right:</span><br><span class="line">                    <span class="keyword">if</span> answerKey[left]!=<span class="string">&quot;T&quot;</span>:</span><br><span class="line">                        ans-=<span class="number">1</span></span><br><span class="line">                    left+=<span class="number">1</span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">        left,right,ans = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">         <span class="comment">#寻找最长的可以替换掉的T字符而形成的字符串</span></span><br><span class="line">        <span class="keyword">while</span> right &lt;= lenght <span class="keyword">and</span> left&lt;=right:</span><br><span class="line">            <span class="keyword">if</span> right&lt;lenght <span class="keyword">and</span>  answerKey[right]!=<span class="string">&quot;F&quot;</span>:</span><br><span class="line">                ans+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> ans == k+<span class="number">1</span> <span class="keyword">or</span> right == lenght:</span><br><span class="line">                result = result <span class="keyword">if</span> result &gt; (right-left) <span class="keyword">else</span> (right-left)</span><br><span class="line">                <span class="keyword">while</span> ans &gt;k <span class="keyword">and</span> left&lt;=right:</span><br><span class="line">                    <span class="keyword">if</span> answerKey[left]!=<span class="string">&quot;F&quot;</span>:</span><br><span class="line">                        ans-=<span class="number">1</span></span><br><span class="line">                    left+=<span class="number">1</span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    </span><br></pre></td></tr></table></figure><h4 id="1606-找到处理最多请求的服务器"><a class="anchor" href="#1606-找到处理最多请求的服务器">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmluZC1zZXJ2ZXJzLXRoYXQtaGFuZGxlZC1tb3N0LW51bWJlci1vZi1yZXF1ZXN0cy8=">1606. 找到处理最多请求的服务器</span></h4><p>你有 <code>k</code> 个服务器，编号为 <code>0</code> 到 <code>k-1</code> ，它们可以同时处理多个请求组。每个服务器有无穷的计算能力但是 <strong>不能同时处理超过一个请求</strong> 。请求分配到服务器的规则如下：</p><ul><li>第 <code>i</code> （序号从 0 开始）个请求到达。</li><li>如果所有服务器都已被占据，那么该请求被舍弃（完全不处理）。</li><li>如果第 <code>(i % k)</code> 个服务器空闲，那么对应服务器会处理该请求。</li><li>否则，将请求安排给下一个空闲的服务器（服务器构成一个环，必要的话可能从第 0 个服务器开始继续找下一个空闲的服务器）。比方说，如果第 <code>i</code> 个服务器在忙，那么会查看第 <code>(i+1)</code> 个服务器，第 <code>(i+2)</code> 个服务器等等。</li></ul><p>给你一个 <strong>严格递增</strong> 的正整数数组 <code>arrival</code> ，表示第 <code>i</code> 个任务的到达时间，和另一个数组 <code>load</code> ，其中 <code>load[i]</code> 表示第 <code>i</code> 个请求的工作量（也就是服务器完成它所需要的时间）。你的任务是找到 <strong>最繁忙的服务器</strong> 。最繁忙定义为一个服务器处理的请求数是所有服务器里最多的。</p><p>请你返回包含所有 <strong>最繁忙服务器</strong> 序号的列表，你可以以任意顺序返回这个列表。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/03/load-1.png" alt="img"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] </span><br><span class="line">输出：[1] </span><br><span class="line">解释：</span><br><span class="line">所有服务器一开始都是空闲的。</span><br><span class="line">前<span class="number"> 3 </span>个请求分别由前<span class="number"> 3 </span>台服务器依次处理。</span><br><span class="line">请求<span class="number"> 3 </span>进来的时候，服务器<span class="number"> 0 </span>被占据，所以它被安排到下一台空闲的服务器，也就是服务器<span class="number"> 1 </span>。</span><br><span class="line">请求<span class="number"> 4 </span>进来的时候，由于所有服务器都被占据，该请求被舍弃。</span><br><span class="line">服务器<span class="number"> 0 </span>和<span class="number"> 2 </span>分别都处理了一个请求，服务器<span class="number"> 1 </span>处理了两个请求。所以服务器<span class="number"> 1 </span>是最忙的服务器。</span><br></pre></td></tr></table></figure><ul><li>模拟算法，但是复杂度太高，达到了 O (n*k)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 维护两个表，一个表记录此时每个服务器的停止服务时间，另一个表记录该服务器服务的请求个数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">EndTime</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 遍历所有请求进行模拟服务器工作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arrival.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 如果当前服务器正在忙就循环找下一个服务器</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j =i%k,m = <span class="number">0</span>;m&lt;k;j=(++j)%k,m++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(EndTime[j]&lt;=arrival[i])</span><br><span class="line">                &#123;</span><br><span class="line">                 EndTime[j] = arrival[i] + load[i];</span><br><span class="line">                 sum[j]++;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">          max = max&gt;sum[i]?max:sum[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[i]==max)&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><ul><li>模拟 + 有序集合 + 优先队列，</li><li>时间复杂度：O ((k+n) logk)，其中 kk 为服务器的数目，n 为请求的数目。开始时 available 放入所有的服务器的时间复杂度为 O (klogk)；在处理请求时，busy 最多执行 n 次放入和移除操作，available 最多执行 n 次放入、移除和查找操作， 因此时间复杂度为 O (nlogk)；获取最繁忙服务器列表的时间复杂度为 O (k)。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> set&lt;<span class="type">int</span>&gt; available;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    available.<span class="built_in">insert</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;&gt;&gt; busy;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">requests</span><span class="params">(k)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrival.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!busy.<span class="built_in">empty</span>() &amp;&amp; busy.<span class="built_in">top</span>().first &lt;= arrival[i]) &#123;</span><br><span class="line">        available.<span class="built_in">insert</span>(busy.<span class="built_in">top</span>().second);</span><br><span class="line">        busy.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (available.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> p = available.<span class="built_in">lower_bound</span>(i % k);</span><br><span class="line">    <span class="keyword">if</span> (p == available.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        p = available.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    requests[*p]++;</span><br><span class="line">    busy.<span class="built_in">emplace</span>(arrival[i] + load[i], *p);</span><br><span class="line">    available.<span class="built_in">erase</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxRequest = *<span class="built_in">max_element</span>(requests.<span class="built_in">begin</span>(), requests.<span class="built_in">end</span>());</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (requests[i] == maxRequest) &#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sortedcontainers <span class="keyword">import</span> SortedList</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">busiestServers</span>(<span class="params">self, k: <span class="built_in">int</span>, arrival: <span class="type">List</span>[<span class="built_in">int</span>], load: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        available = SortedList(<span class="built_in">range</span>(k))</span><br><span class="line">        busy = []</span><br><span class="line">        requests = [<span class="number">0</span>] * k</span><br><span class="line">        <span class="keyword">for</span> i, (start, t) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(arrival, load)):</span><br><span class="line">            <span class="keyword">while</span> busy <span class="keyword">and</span> busy[<span class="number">0</span>][<span class="number">0</span>] &lt;= start:</span><br><span class="line">                available.add(busy[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">                heappop(busy)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(available) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            j = available.bisect_left(i % k)</span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(available):</span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">            <span class="built_in">id</span> = available[j]</span><br><span class="line">            requests[<span class="built_in">id</span>] += <span class="number">1</span></span><br><span class="line">            heappush(busy, (start + t, <span class="built_in">id</span>))</span><br><span class="line">            available.remove(<span class="built_in">id</span>)</span><br><span class="line">        maxRequest = <span class="built_in">max</span>(requests)</span><br><span class="line">        <span class="keyword">return</span> [i <span class="keyword">for</span> i, req <span class="keyword">in</span> <span class="built_in">enumerate</span>(requests) <span class="keyword">if</span> req == maxRequest]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="728-自除数"><a class="anchor" href="#728-自除数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2VsZi1kaXZpZGluZy1udW1iZXJzLw==">728. 自除数</span></h4><p>难度简单 171</p><p><strong>自除数</strong> 是指可以被它包含的每一位数整除的数。</p><ul><li>例如， <code>128</code> 是一个 <strong>自除数</strong> ，因为 <code>128 % 1 == 0</code> ， <code>128 % 2 == 0</code> ， <code>128 % 8 == 0</code> 。</li></ul><p><strong>自除数</strong> 不允许包含 0 。</p><p>给定两个整数 <code>left</code> 和 <code>right</code> ，返回一个列表，<em>列表的元素是范围 <code>[left, right]</code> 内所有的 <strong>自除数</strong></em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">left</span> = <span class="number">1</span>, <span class="built_in">right</span> = <span class="number">22</span></span><br><span class="line">输出：[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">22</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">left</span> = <span class="number">47</span>, <span class="built_in">right</span> = <span class="number">85</span></span><br><span class="line">输出：[<span class="number">48</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">selfDividingNumbers</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result =[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left,right+<span class="number">1</span>):</span><br><span class="line">            data = <span class="built_in">set</span>(<span class="built_in">str</span>(i))</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;0&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> data:</span><br><span class="line">                <span class="keyword">if</span> i%<span class="built_in">int</span>(d)!=<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(i)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="307-区域和检索-数组可修改"><a class="anchor" href="#307-区域和检索-数组可修改">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcmFuZ2Utc3VtLXF1ZXJ5LW11dGFibGUv">307. 区域和检索 - 数组可修改</span></h4><p>难度中等 365</p><p>给你一个数组 <code>nums</code> ，请你完成两类查询。</p><ol><li>其中一类查询要求 <strong>更新</strong> 数组 <code>nums</code> 下标对应的值</li><li>另一类查询要求返回数组 <code>nums</code> 中索引 <code>left</code> 和索引 <code>right</code> 之间（ <strong>包含</strong> ）的 nums 元素的 <strong>和</strong> ，其中 <code>left &lt;= right</code></li></ol><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 用整数数组 <code>nums</code> 初始化对象</li><li><code>void update(int index, int val)</code> 将 <code>nums[index]</code> 的值 <strong>更新</strong> 为 <code>val</code></li><li><code>int sumRange(int left, int right)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和索引 <code>right</code> 之间（ <strong>包含</strong> ）的 nums 元素的 <strong>和</strong> （即， <code>nums[left] + nums[left + 1], ..., nums[right]</code> ）</li></ul><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">&quot;NumArray&quot;</span>, <span class="string">&quot;sumRange&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;sumRange&quot;</span>]</span><br><span class="line">[[[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]], [<span class="number">0</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">2</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null, <span class="number">9</span>, null, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"><span class="symbol">NumArray</span> numArray = new <span class="symbol">NumArray</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]);</span><br><span class="line">numArray.sumRange(<span class="number">0</span>, <span class="number">2</span>); // 返回 <span class="number">1</span> + <span class="number">3</span> + <span class="number">5</span> = <span class="number">9</span></span><br><span class="line">numArray.update(<span class="number">1</span>, <span class="number">2</span>);   // nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">numArray.sumRange(<span class="number">0</span>, <span class="number">2</span>); // 返回 <span class="number">1</span> + <span class="number">2</span> + <span class="number">5</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure><h5 id="题解"><a class="anchor" href="#题解">#</a> 题解</h5><h6 id="解法一线段树"><a class="anchor" href="#解法一线段树">#</a> 解法一：线段树</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">       <span class="variable language_">self</span>.length = <span class="built_in">len</span>(nums)</span><br><span class="line">       <span class="variable language_">self</span>.<span class="built_in">sum</span> = [<span class="number">0</span>]*(<span class="variable language_">self</span>.length&lt;&lt;<span class="number">2</span>)</span><br><span class="line">       <span class="variable language_">self</span>.build(nums,<span class="number">1</span>,<span class="number">0</span>,<span class="variable language_">self</span>.length-<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#创建函数,保存每段的区间和</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self,nums:<span class="built_in">list</span>,k:<span class="built_in">int</span>,left:<span class="built_in">int</span> ,right:<span class="built_in">int</span></span>):</span><br><span class="line">           <span class="comment">#如果区间内只剩一个值的话，也就是left==right时，就直接让其区间和等于该值</span></span><br><span class="line">           <span class="keyword">if</span> left==right:</span><br><span class="line">               <span class="variable language_">self</span>.<span class="built_in">sum</span>[k] = nums[left]</span><br><span class="line">            <span class="comment">#如果区间长度超过了一个，就将区间一分为二，继续递归建立</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               mid = left + (right-left)//<span class="number">2</span></span><br><span class="line">               <span class="variable language_">self</span>.build(nums,k&lt;&lt;<span class="number">1</span>,left,mid)</span><br><span class="line">               <span class="variable language_">self</span>.build(nums,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,right)</span><br><span class="line">               <span class="comment">#更新父节点</span></span><br><span class="line">               <span class="variable language_">self</span>.<span class="built_in">sum</span>[k] = <span class="variable language_">self</span>.<span class="built_in">sum</span>[k&lt;&lt;<span class="number">1</span>] + <span class="variable language_">self</span>.<span class="built_in">sum</span>[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_G</span>(<span class="params">self,i,val:<span class="built_in">int</span>,left:<span class="built_in">int</span>,right:<span class="built_in">int</span>,k:<span class="built_in">int</span></span>):</span><br><span class="line">        <span class="comment">#如果区间长度为1时，就直接更新该值</span></span><br><span class="line">        <span class="keyword">if</span> left == right :</span><br><span class="line">            <span class="variable language_">self</span>.<span class="built_in">sum</span>[k] = val</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment">#否则就递归更新孩子节点，更新完成后，再更新父节点</span></span><br><span class="line">        mid = left + (right-left)//<span class="number">2</span></span><br><span class="line">        <span class="comment">#如果需要更新的下标，小于中间节点，则在左侧区域中寻找</span></span><br><span class="line">        <span class="keyword">if</span> i&lt;=mid:</span><br><span class="line">            <span class="variable language_">self</span>.update_G(i,val,left,mid,k&lt;&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.update_G(i,val,mid+<span class="number">1</span>,right,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#更新父节点</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">sum</span>[k] = <span class="variable language_">self</span>.<span class="built_in">sum</span>[k&lt;&lt;<span class="number">1</span>] + <span class="variable language_">self</span>.<span class="built_in">sum</span>[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.update_G(index,val,<span class="number">0</span>,<span class="variable language_">self</span>.length-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self,L:<span class="built_in">int</span>,R:<span class="built_in">int</span>,left:<span class="built_in">int</span>,right:<span class="built_in">int</span>,k:<span class="built_in">int</span></span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#如果当前节点的区间真包含于要查询的区间内，则返回节点信息且不需要往下递归</span></span><br><span class="line">        <span class="keyword">if</span> L ==left <span class="keyword">and</span> right == R:</span><br><span class="line">           <span class="keyword">return</span> <span class="variable language_">self</span>.<span class="built_in">sum</span>[k]</span><br><span class="line">        mid = left + (right-left)//<span class="number">2</span></span><br><span class="line">        <span class="comment">#判断区间是在哪一边，如果在左边，就在左边，就在在左边找</span></span><br><span class="line">        <span class="keyword">if</span> R&lt;=mid:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.query(L,R,left,mid,k&lt;&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> L&gt;mid:</span><br><span class="line">            <span class="keyword">return</span>  <span class="variable language_">self</span>.query(L,R,mid+<span class="number">1</span>,right,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.query(L,mid,left,mid,k&lt;&lt;<span class="number">1</span>) + <span class="variable language_">self</span>.query(mid+<span class="number">1</span>,R,mid+<span class="number">1</span>,right,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">         <span class="keyword">return</span>  <span class="variable language_">self</span>.query(left,right,<span class="number">0</span>,<span class="variable language_">self</span>.length-<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h6 id="解法二分块"><a class="anchor" href="#解法二分块">#</a> 解法二：分块</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        size = <span class="built_in">int</span>(n ** <span class="number">0.5</span>)</span><br><span class="line">        sums = [<span class="number">0</span>] * ((n + size - <span class="number">1</span>) // size)  <span class="comment"># n/size 向上取整</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            sums[i // size] += num</span><br><span class="line">        <span class="variable language_">self</span>.nums = nums</span><br><span class="line">        <span class="variable language_">self</span>.sums = sums</span><br><span class="line">        <span class="variable language_">self</span>.size = size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, index: <span class="built_in">int</span>, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.sums[index // <span class="variable language_">self</span>.size] += val - <span class="variable language_">self</span>.nums[index]</span><br><span class="line">        <span class="variable language_">self</span>.nums[index] = val</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="variable language_">self</span>.size</span><br><span class="line">        b1, b2 = left // m, right // m</span><br><span class="line">        <span class="keyword">if</span> b1 == b2:  <span class="comment"># 区间 [left, right] 在同一块中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.nums[left:right + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.nums[left:(b1 + <span class="number">1</span>) * m]) + <span class="built_in">sum</span>(<span class="variable language_">self</span>.sums[b1 + <span class="number">1</span>:b2]) + <span class="built_in">sum</span>(<span class="variable language_">self</span>.nums[b2 * m:right + <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h4 id="55-跳跃游戏"><a class="anchor" href="#55-跳跃游戏">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvanVtcC1nYW1lLw==">55. 跳跃游戏</span></h4><p>难度中等</p><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳<span class="number"> 1 </span>步，从下标<span class="number"> 0 </span>到达下标 1, 然后再从下标<span class="number"> 1 </span>跳<span class="number"> 3 </span>步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为<span class="number"> 3 </span>的位置。但该下标的最大跳跃长度是<span class="number"> 0 </span>， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//   int len = nums.size();</span></span><br><span class="line">    <span class="comment">//   int ** dp = new int*[len];</span></span><br><span class="line">    <span class="comment">//   for(int i=0;i&lt;len;i++)&#123;</span></span><br><span class="line">    <span class="comment">//       dp[i] = new int[len];</span></span><br><span class="line">    <span class="comment">//       dp[i][i] = 1;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">//   for(int k = 1;k&lt;len;k++)&#123;</span></span><br><span class="line">    <span class="comment">//       for(int i=0;i&lt;len-k;i++)&#123;</span></span><br><span class="line">    <span class="comment">//           if(nums[i]&gt;=k||(dp[i][i+k-1]&amp;&amp;dp[i+1][i+k]&amp;&amp;k&gt;1))&#123;</span></span><br><span class="line">    <span class="comment">//               dp[i][i+k]=1;</span></span><br><span class="line">    <span class="comment">//           &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//               dp[i][i+k]=0;</span></span><br><span class="line">    <span class="comment">//           &#125;</span></span><br><span class="line">    <span class="comment">//       &#125;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">//   return dp[0][len-1]==1? true : false;</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 方法二</span></span><br><span class="line">        <span class="comment">//   int len = nums.size();</span></span><br><span class="line">        <span class="comment">//   if(len == 0)  return true;</span></span><br><span class="line">        <span class="comment">//   int result = nums[0] ,i=1;</span></span><br><span class="line">        <span class="comment">//   while(result&amp;&amp;i&lt;len)&#123;</span></span><br><span class="line">        <span class="comment">//       //每走一步消耗一点能量 </span></span><br><span class="line">        <span class="comment">//       result--;</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//       if(result&lt;nums[i])</span></span><br><span class="line">        <span class="comment">//           result=nums[i];</span></span><br><span class="line">        <span class="comment">//       i++;</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">//   return i == len;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//方法三</span></span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//从后往前遍历，如果有哪一个位置能够到达最后一一个位置，就把它作为现在的最后一个位置，重复上述操作</span></span><br><span class="line">        <span class="type">int</span> max = len<span class="number">-1</span> , i=len<span class="number">-2</span>;</span><br><span class="line">         <span class="keyword">while</span>(max&gt;=<span class="number">0</span>&amp;&amp;i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(nums[i]&gt;=max-i)&#123;</span><br><span class="line">                  max = i;</span><br><span class="line">                  i--;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  i--;</span><br><span class="line">              &#125;</span><br><span class="line">              </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> max ==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="56-合并区间"><a class="anchor" href="#56-合并区间">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWVyZ2UtaW50ZXJ2YWxzLw==">56. 合并区间</span></h4><p>难度中等</p><p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">10</span>],[<span class="number">15</span>,<span class="number">18</span>]]</span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">6</span>] 重叠, 将它们合并为 [<span class="number">1</span>,<span class="number">6</span>].</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[1,4],[4,5]]</span></span><br><span class="line">输出：<span class="string">[[1,5]]</span></span><br><span class="line">解释：区间 [<span class="number">1</span>,<span class="number">4</span>] 和 [<span class="number">4</span>,<span class="number">5</span>] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><p>方法一：排序<br>思路</p><p>如果我们按照区间的左端点排序，那么在排完序的列表中，可以合并的区间一定是连续的。如下图所示，标记为蓝色、黄色和绿色的区间分别可以合并成一个大区间，它们在排完序的列表中是连续的：</p><p>算法</p><p>我们用数组 merged 存储最终的答案。</p><p>首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：</p><p>如果当前区间的左端点在数组 merged 中最后一个区间的右端点之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；</p><p>否则，它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        intervals = <span class="built_in">sorted</span>(intervals,key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>])</span><br><span class="line">        length = <span class="built_in">len</span>(intervals)</span><br><span class="line">        result = []</span><br><span class="line">        result.append(intervals[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">            <span class="comment">#如果新添加的这个区间的左边界大于result中最后一个区间的右边界，说明此时两个区间是不重叠的</span></span><br><span class="line">            <span class="comment">#直接添加进去</span></span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;result[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">                result.append(intervals[i])</span><br><span class="line">            <span class="comment">#否则，说明该区间与result中最后一个区间是重叠的，然后找到他们右边界的最大值，作为新区间</span></span><br><span class="line">            <span class="comment">#再进行添加</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(result[-<span class="number">1</span>][<span class="number">1</span>],intervals[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="57-插入区间"><a class="anchor" href="#57-插入区间">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvaW5zZXJ0LWludGVydmFsLw==">57. 插入区间</span></h4><p>难度中等 567 收藏分享切换为英文接收动态反馈</p><p>给你一个 <strong>无重叠的</strong> *，* 按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[1,3],[6,9]]</span>, newInterval = [<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="string">[[1,5],[6,9]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = <span class="comment">[<span class="comment">[1,2]</span>,<span class="comment">[3,5]</span>,<span class="comment">[6,7]</span>,<span class="comment">[8,10]</span>,<span class="comment">[12,16]</span>]</span>, newInterval = <span class="comment">[4,8]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[1,2]</span>,<span class="comment">[3,10]</span>,<span class="comment">[12,16]</span>]</span></span><br><span class="line">解释：这是因为新的区间 <span class="comment">[4,8]</span> 与 <span class="comment">[3,5]</span>,<span class="comment">[6,7]</span>,<span class="comment">[8,10]</span> 重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [], newInterval = [<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="string">[[5,7]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[1,5]]</span>, newInterval = [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="string">[[1,5]]</span></span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = <span class="string">[[1,5]]</span>, newInterval = [<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="string">[[1,7]]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], newInterval: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        length = <span class="built_in">len</span>(intervals)</span><br><span class="line">        <span class="comment">#二分法寻找左边界</span></span><br><span class="line">        <span class="comment">#针对于该序列就是大于等于该数的第一个值</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = length</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left + (right -left)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> intervals[mid][<span class="number">0</span>] &gt;= newInterval[<span class="number">0</span>]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="comment">#找到之后该区间数组就成了以左边界为标准的非递减区间序列</span></span><br><span class="line">        <span class="comment">#在这种特征的序列中，可能发生重叠的区间肯定是连续的，因此可以从前到后</span></span><br><span class="line">        <span class="comment">#依次进行遍历判断</span></span><br><span class="line">        intervals.insert(left,newInterval)</span><br><span class="line">        result = []</span><br><span class="line">        result.append(intervals[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> result[-<span class="number">1</span>][<span class="number">1</span>] &lt; intervals[i][<span class="number">0</span>]:</span><br><span class="line">                result.append(intervals[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result[-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(result[-<span class="number">1</span>][<span class="number">1</span>],intervals[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="763-划分字母区间"><a class="anchor" href="#763-划分字母区间">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWxhYmVscy8=">763. 划分字母区间</span></h4><p>难度中等</p><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="symbol">S</span> = <span class="string">&quot;ababcbacadefegdehijhklij&quot;</span></span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 <span class="string">&quot;ababcbaca&quot;</span>, <span class="string">&quot;defegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span>。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 <span class="string">&quot;ababcbacadefegde&quot;</span>, <span class="string">&quot;hijhklij&quot;</span> 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure><p>方法一：贪心<br>由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。</p><p>在得到每个字母最后一次出现的下标位置之后，可以使用贪心的方法将字符串划分为尽可能多的片段，具体做法如下。</p><p>从左到右遍历字符串，遍历的同时维护当前片段的开始下标 \textit {start} start 和结束下标 \textit {end} end，初始时 start=end=0。</p><p>对于每个访问到的字母 cc，得到当前字母的最后一次出现的下标位置 end ，则当前片段的结束下标一定不会小于 end ，因此令 end=max (end,end 当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 [start,end]，长度为 end−start+1，将当前片段的长度添加到返回值，然后令 start=end+1，继续寻找下一个片段。</p><p>重复上述过程，直到遍历完字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partitionLabels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        last = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            last[<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)] = i</span><br><span class="line">        </span><br><span class="line">        partition = <span class="built_in">list</span>()</span><br><span class="line">        start = end = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            end = <span class="built_in">max</span>(end, last[<span class="built_in">ord</span>(ch) - <span class="built_in">ord</span>(<span class="string">&quot;a&quot;</span>)])</span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                partition.append(end - start + <span class="number">1</span>)</span><br><span class="line">                start = end + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> partition</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partitionLabels</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        end = <span class="built_in">dict</span>.fromkeys(s,<span class="number">0</span>)</span><br><span class="line">        length  = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment">#记录每个字母最后一次出现的位置</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">           end[s[i]] = i</span><br><span class="line">        <span class="comment">#从前到后遍历，遍历到当前位置，可以分成一个满足条件的最短的子串的右端大于等于当前字母的最后一次出现的位置</span></span><br><span class="line">        result = []</span><br><span class="line">        end_max = <span class="number">0</span></span><br><span class="line">        left ,right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            end_max = <span class="built_in">max</span>(end_max,end[s[i]])</span><br><span class="line">            <span class="comment">#如果当前字母的位置就到了这个阶段的最有边界，说明已经可以分成满足条件的子串了，要保证到最短，所以现在就可以截取</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i == end_max:</span><br><span class="line">                 result.append(right-left+<span class="number">1</span>)</span><br><span class="line">                 left = right+<span class="number">1</span></span><br><span class="line">            right+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="45-跳跃游戏-ii"><a class="anchor" href="#45-跳跃游戏-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvanVtcC1nYW1lLWlpLw==">45. 跳跃游戏 II</span></h4><p>难度中等</p><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。假设你总是可以到达数组的最后一个位置。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为<span class="number"> 0 </span>跳到下标为<span class="number"> 1 </span>的位置，跳<span class="number"> 1 </span>步，然后跳<span class="number"> 3 </span>步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [2,3,0,1,4]</span></span><br><span class="line"><span class="section">输出: 2</span></span><br></pre></td></tr></table></figure><p>解题思路<br>这道题是典型的贪心算法，通过局部最优解得到全局最优解。以下两种方法都是使用贪心算法实现，只是贪心的策略不同。</p><p>方法一：反向查找出发位置<br>我们的目标是到达数组的最后一个位置，因此我们可以考虑最后一步跳跃前所在的位置，该位置通过跳跃能够到达最后一个位置。</p><p>如果有多个位置通过跳跃都能够到达最后一个位置，那么我们应该如何进行选择呢？直观上来看，我们可以「贪心」地选择距离最后一个位置最远的那个位置，也就是对应下标最小的那个位置。因此，我们可以从左到右遍历数组，选择第一个满足要求的位置。</p><p>找到最后一步跳跃前所在的位置之后，我们继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置</p><p>方法二：动态规划</p><p>如果该位置能够到达最后一个位置，直接这个位置步数就为 1</p><p>如果该位置不能够直接到达最后一个位置，那么就应该在该位置所能到达的范围内寻找到达最后一个位置中最小步数加一就等于该位置到达最后一个位置的最小步数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#动态规划问题</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        ls = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">            ls.append(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#大致思路就是：检索当前位置的值，有两种可能，一种就是该位置的值足以直接到达最后，即num&gt;=len-1-i</span></span><br><span class="line">        <span class="comment">#另一种可能就是不能达到，那就以这个位置为起点，以该值为总长度，进行检索找到最小的一个，然后加一，就是该位置的最小步数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;=l-<span class="number">1</span>-i:</span><br><span class="line">                ls[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">min</span> = ls[i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,i+nums[i]+<span class="number">1</span>):</span><br><span class="line">                     <span class="keyword">if</span> <span class="built_in">min</span> &gt; ls[j] <span class="keyword">and</span> nums[j]&gt;<span class="number">0</span>:</span><br><span class="line">                          <span class="built_in">min</span> = ls[j]</span><br><span class="line">                ls[i]= <span class="built_in">min</span> +<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ls[<span class="number">0</span>]</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>如果我们「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。</p><p>例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。</p><p>从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。</p><p><img data-src="https://assets.leetcode-cn.com/solution-static/45/45_fig1.png" alt="fig1"></p><p>在具体的实现中，我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。</p><p>在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        maxPos, end, step = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> maxPos &gt;= i:</span><br><span class="line">                maxPos = <span class="built_in">max</span>(maxPos, i + nums[i])</span><br><span class="line">                <span class="keyword">if</span> i == end:</span><br><span class="line">                    end = maxPos</span><br><span class="line">                    step += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> step</span><br></pre></td></tr></table></figure><h4 id="1306-跳跃游戏-iii"><a class="anchor" href="#1306-跳跃游戏-iii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvanVtcC1nYW1lLWlpaS8=">1306. 跳跃游戏 III</span></h4><p>难度中等 1</p><p>这里有一个非负整数数组 <code>arr</code> ，你最开始位于该数组的起始下标 <code>start</code> 处。当你位于下标 <code>i</code> 处时，你可以跳到 <code>i + arr[i]</code> 或者 <code>i - arr[i]</code> 。请你判断自己是否能够跳到对应元素值为 0 的 <strong>任一</strong> 下标处。</p><p>注意，不管是什么情况下，你都无法跳到数组之外。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [4,2,3,0,3,1,2], start = 5</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">到达值为<span class="number"> 0 </span>的下标<span class="number"> 3 </span>有以下可能方案： </span><br><span class="line">下标<span class="number"> 5 </span>-&gt; 下标<span class="number"> 4 </span>-&gt; 下标<span class="number"> 1 </span>-&gt; 下标<span class="number"> 3 </span></span><br><span class="line">下标<span class="number"> 5 </span>-&gt; 下标<span class="number"> 6 </span>-&gt; 下标<span class="number"> 4 </span>-&gt; 下标<span class="number"> 1 </span>-&gt; 下标<span class="number"> 3 </span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [4,2,3,0,3,1,2], start = 0</span><br><span class="line">输出：true </span><br><span class="line">解释：</span><br><span class="line">到达值为<span class="number"> 0 </span>的下标<span class="number"> 3 </span>有以下可能方案： </span><br><span class="line">下标<span class="number"> 0 </span>-&gt; 下标<span class="number"> 4 </span>-&gt; 下标<span class="number"> 1 </span>-&gt; 下标 3</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>], <span class="literal">start</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法到达值为 <span class="number">0</span> 的下标 <span class="number">1</span> 处。 </span><br></pre></td></tr></table></figure><p>题目解析：首先从起始位置开始，判断起始位置是否值为零，如果不为零，则就将从该位置所能到达的两个位置入队；</p><p>之后在队列不空的前提之下，依次弹出队头元素，然后检查该位置的值是否为零，如果为零的话，就返回 True；否则就将它所能到达的位置（满足条件没有被检查过，因为检查过再次检查就会走相同的路，进入死循环；其次该位置不能跳出边界）加入到队尾。</p><p>按照此流程进行循环操作，如果结束之后，仍没有找到符合条件的结果，就返回 False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canReach</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], start: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">       <span class="comment">#尝试一下广度优先遍历</span></span><br><span class="line">        length = <span class="built_in">len</span>(arr)</span><br><span class="line">        que = deque()</span><br><span class="line">        <span class="keyword">if</span> arr[start] == <span class="number">0</span> :</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        S = [<span class="literal">False</span>]*length</span><br><span class="line">        S[start] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> start + arr[start] &lt; length:</span><br><span class="line">           S[start + arr[start]]=<span class="literal">True</span></span><br><span class="line">           que.appendleft(start + arr[start])</span><br><span class="line">        <span class="keyword">if</span> start - arr[start] &gt;= <span class="number">0</span>:</span><br><span class="line">           S[start - arr[start]]=<span class="literal">True</span></span><br><span class="line">           que.appendleft(start - arr[start])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(que):</span><br><span class="line">            t = que.pop()</span><br><span class="line">            <span class="keyword">if</span>  arr[t] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span>  t + arr[t] &lt; length <span class="keyword">and</span> <span class="keyword">not</span> S[t+arr[t]] :</span><br><span class="line">                S[t + arr[t]] = <span class="literal">True</span></span><br><span class="line">                que.appendleft(t + arr[t])</span><br><span class="line">            <span class="keyword">if</span>  t - arr[t] &gt;= <span class="number">0</span>  <span class="keyword">and</span> <span class="keyword">not</span> S[t-arr[t]]:</span><br><span class="line">                S[t - arr[t]] = <span class="literal">True</span></span><br><span class="line">                que.appendleft(t - arr[t]) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="310-最小高度树-2"><a class="anchor" href="#310-最小高度树-2">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbWluaW11bS1oZWlnaHQtdHJlZXMv">310. 最小高度树</span></h4><p>难度中等 517</p><p>树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</p><p>给你一棵包含 <code>n</code> 个节点的树，标记为 <code>0</code> 到 <code>n - 1</code> 。给定数字 <code>n</code> 和一个有 <code>n - 1</code> 条无向边的 <code>edges</code> 列表（每一个边都是一对标签），其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条无向边。</p><p>可选择树中任何一个节点作为根。当选择节点 <code>x</code> 作为根节点时，设结果树的高度为 <code>h</code> 。在所有可能的树中，具有最小高度的树（即， <code>min(h)</code> ）被称为 <strong>最小高度树</strong> 。</p><p>请你找到所有的 <strong>最小高度树</strong> 并按 <strong>任意顺序</strong> 返回它们的根节点标签列表。</p><p>树的 <strong>高度</strong> 是指根节点和叶子节点之间最长向下路径上边的数量。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/09/01/e1.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, edges = <span class="comment">[<span class="comment">[1,0]</span>,<span class="comment">[1,2]</span>,<span class="comment">[1,3]</span>]</span></span><br><span class="line">输出：<span class="comment">[1]</span></span><br><span class="line">解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/09/01/e2.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 6, edges = <span class="comment">[<span class="comment">[3,0]</span>,<span class="comment">[3,1]</span>,<span class="comment">[3,2]</span>,<span class="comment">[3,4]</span>,<span class="comment">[5,4]</span>]</span></span><br><span class="line">输出：<span class="comment">[3,4]</span></span><br></pre></td></tr></table></figure><p>简单分析过程：</p><ul><li><p>首先，我们看了样例，发现这个树并不是二叉树，是多叉树。然后，我们可能想到的解法是：根据题目的意思，就挨个节点遍历 bfs，统计下每个节点的高度，然后用 map 存储起来，后面查询这个高度的集合里最小的就可以了。但是这样会超时的。</p></li><li><p>于是我们看图（题目介绍里面的图）分析一下，发现，越是靠里面的节点越有可能是最小高度树。所以，我们可以这样想，我们可以倒着来。我们从边缘开始，先找到所有出度为 1 的节点，然后把所有出度为 1 的节点进队列，然后不断地 bfs，最后找到的就是两边同时向中间靠近的节点，那么这个中间节点就相当于把整个距离二分了，那么它当然就是到两边距离最小的点啦，也就是到其他叶子节点最近的节点了。然后，就可以写代码了</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMinHeightTrees</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment">#如果只有一个节点，就返回零节点，就是最小高度的根节点</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#拥有最小高度的树根，肯定是整棵树最大距离的中间节点，因为此时根节点道两侧的距离最小</span></span><br><span class="line">        <span class="comment">#先创建一个所有节点的度表</span></span><br><span class="line">        degree = [<span class="number">0</span>]*n</span><br><span class="line">        <span class="comment">#其次，再来一个邻接表（即每个节点相邻的节点，该表用字典来表示）</span></span><br><span class="line">        <span class="comment">#Adj_table = dict.fromkeys([i for i in range(n)],[])</span></span><br><span class="line">        <span class="comment">## #当字典中的值是字典或者是列表的话，只能一个一个初始化</span></span><br><span class="line">        <span class="comment">#不能使用 fromkeys()进行初始化</span></span><br><span class="line">        Adj_table = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            Adj_table[i]=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">             degree[edges[i][<span class="number">0</span>]]+=<span class="number">1</span></span><br><span class="line">             degree[edges[i][<span class="number">1</span>]]+=<span class="number">1</span></span><br><span class="line">             Adj_table[edges[i][<span class="number">0</span>]].append(edges[i][<span class="number">1</span>])</span><br><span class="line">             Adj_table[edges[i][<span class="number">1</span>]].append(edges[i][<span class="number">0</span>])</span><br><span class="line">        <span class="comment">#开始广度优先遍历</span></span><br><span class="line">        <span class="comment">#首先创建一个队列</span></span><br><span class="line">        que = deque()</span><br><span class="line">        <span class="comment">#将最外围的叶子结点入队</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> degree[i] == <span class="number">1</span>:</span><br><span class="line">                que.appendleft(i)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment">#队列非空就执行</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(que):</span><br><span class="line">            res.clear()</span><br><span class="line">            <span class="comment">#对叶子节点采用一层一层处理</span></span><br><span class="line">            size = <span class="built_in">len</span>(que)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">                <span class="comment">#首先弹出此时第一个叶子结点，并且将它所有邻接的节点的度数都减一</span></span><br><span class="line">                cur = que.pop()</span><br><span class="line">                <span class="comment">#将弹出的叶子结点加入到结果数组中</span></span><br><span class="line">                res.append(cur)</span><br><span class="line">                Adj_point = Adj_table[cur]</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> Adj_point:</span><br><span class="line">                    degree[i]-=<span class="number">1</span></span><br><span class="line">                    <span class="comment">#如果哪一个邻接点因为度数减一导致成为了叶子结点，就将节点加入到队列</span></span><br><span class="line">                    <span class="keyword">if</span> degree[i]==<span class="number">1</span>:</span><br><span class="line">                        que.appendleft(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="357-统计各位数字都不同的数字个数"><a class="anchor" href="#357-统计各位数字都不同的数字个数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvY291bnQtbnVtYmVycy13aXRoLXVuaXF1ZS1kaWdpdHMv">357. 统计各位数字都不同的数字个数</span></h4><p>难度中等 192</p><p>给你一个整数 <code>n</code> ，统计并返回各位数字都不同的数字 <code>x</code> 的个数，其中 <code>0 &lt;= x &lt; 10n</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">91</span></span><br><span class="line">解释：答案应为除去 <span class="number">11、22、33、44</span>、<span class="number">55、66、77、88</span>、<span class="number">99</span> 外，在 <span class="number">0</span> ≤ x &lt; <span class="number">100</span> 范围内的所有数字。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p>乘法原理<br>对于 n = 0n=0 的情况较为特殊，特判一下，返回 11。</p><p>对于其他情况，由于不能含有前导 00，最高位可选择的数值个数为 99，而从次高位开始到最低位，可选的个数从 99 开始逐一递减。</p><p>利用乘法原理，每位数可选的数值个数相乘即是长度为 nn 的数的可能方案数 curcur，而所有长度 [1,n] 的方案数累加即是答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNumbersWithUniqueDigits</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">        res, cur = <span class="number">10</span>, <span class="number">9</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            cur *= <span class="number">9</span> - i</span><br><span class="line">            res += cur</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="479-最大回文数乘积"><a class="anchor" href="#479-最大回文数乘积">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGFyZ2VzdC1wYWxpbmRyb21lLXByb2R1Y3Qv">479. 最大回文数乘积</span></h4><p>难度困难 55</p><p>给定一个整数 n ，返回 <em>可表示为两个 <code>n</code> 位整数乘积的 <strong>最大回文整数</strong></em> 。因为答案可能非常大，所以返回它对 <code>1337</code> <strong>取余</strong> 。</p><p><strong>示例 1:</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">输入：n</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">输出：987</span></span><br><span class="line"><span class="string">解释：99</span> <span class="string">x</span> <span class="number">91</span> <span class="string">=</span> <span class="number">9009</span><span class="string">,</span> <span class="number">9009</span> <span class="string">%</span> <span class="number">1337</span> <span class="string">=</span> <span class="number">987</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： n <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">输出： <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><p>题解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestPalindrome</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#如果n等于1，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">9</span></span><br><span class="line">        end = <span class="number">10</span>**n - <span class="number">1</span></span><br><span class="line">        <span class="comment">#先从大到小构造回文数，然后判断该回文数是否符合条件，如果符合条件此时返回的就是最大的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(end,end//<span class="number">10</span>,-<span class="number">1</span>):</span><br><span class="line">            result,left = i,i</span><br><span class="line">            <span class="keyword">while</span> left:</span><br><span class="line">                result = result*<span class="number">10</span> + left%<span class="number">10</span></span><br><span class="line">                left //=<span class="number">10</span></span><br><span class="line">            <span class="comment">#每次找到一个回文数之后，就看一下是否符合有两个n位数的因数</span></span><br><span class="line">            <span class="comment">#找因数，默认认为其中一个因数比另一个因数大，可以是寻找半径缩短一半</span></span><br><span class="line">            x = end</span><br><span class="line">            <span class="keyword">while</span> x*x &gt;= result:</span><br><span class="line">                <span class="keyword">if</span> result % x==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> result%<span class="number">1337</span></span><br><span class="line">                x-=<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="386-字典序排数"><a class="anchor" href="#386-字典序排数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbGV4aWNvZ3JhcGhpY2FsLW51bWJlcnMv">386. 字典序排数</span></h4><p>难度中等 262</p><p>给你一个整数 <code>n</code> ，按字典序返回范围 <code>[1, n]</code> 内所有整数。</p><p>你必须设计一个时间复杂度为 <code>O(n)</code> 且使用 <code>O(1)</code> 额外空间的算法。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">13</span></span><br><span class="line">输出：[<span class="number">1,10,11,12</span>,<span class="number">13,2,3,4</span>,<span class="number">5,6,7,8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 5 * 104</code></li></ul><img data-src="https://github.com/zhihao-a/blog-img\image-20220418083933398.png" alt="image-20220418083933398" style="zoom:50%"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lexicalOrder</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment">#变成字符串不就按字典序返回了吗</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            result.append(<span class="built_in">str</span>(i))</span><br><span class="line">        result.sort()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,result)</span><br></pre></td></tr></table></figure><h4 id="821-字符的最短距离"><a class="anchor" href="#821-字符的最短距离">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc2hvcnRlc3QtZGlzdGFuY2UtdG8tYS1jaGFyYWN0ZXIv">821. 字符的最短距离</span></h4><p>难度简单</p><p>给你一个字符串 <code>s</code> 和一个字符 <code>c</code> ，且 <code>c</code> 是 <code>s</code> 中出现过的字符。</p><p>返回一个整数数组 <code>answer</code> ，其中 <code>answer.length == s.length</code> 且 <code>answer[i]</code> 是 <code>s</code> 中从下标 <code>i</code> 到离它 <strong>最近</strong> 的字符 <code>c</code> 的 <strong>距离</strong> 。</p><p>两个下标 <code>i</code> 和 <code>j</code> 之间的 <strong>距离</strong> 为 <code>abs(i - j)</code> ，其中 <code>abs</code> 是绝对值函数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;loveleetcode&quot;, c = &quot;e&quot;</span><br><span class="line">输出：[3,2,1,0,1,0,0,1,2,2,1,0]</span><br><span class="line">解释：字符 &#x27;e&#x27; 出现在下标 3、5、6 和<span class="number"> 11 </span>处（下标从<span class="number"> 0 </span>开始计数）。</span><br><span class="line">距下标<span class="number"> 0 </span>最近的 &#x27;e&#x27; 出现在下标<span class="number"> 3 </span>，所以距离为 abs(0 - 3) =<span class="number"> 3 </span>。</span><br><span class="line">距下标<span class="number"> 1 </span>最近的 &#x27;e&#x27; 出现在下标<span class="number"> 3 </span>，所以距离为 abs(1 - 3) =<span class="number"> 2 </span>。</span><br><span class="line">对于下标<span class="number"> 4 </span>，出现在下标<span class="number"> 3 </span>和下标<span class="number"> 5 </span>处的 &#x27;e&#x27; 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) =<span class="number"> 1 </span>。</span><br><span class="line">距下标<span class="number"> 8 </span>最近的 &#x27;e&#x27; 出现在下标<span class="number"> 6 </span>，所以距离为 abs(8 - 6) =<span class="number"> 2 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;aaab&quot;</span><span class="punctuation">,</span> <span class="keyword">c</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span></span><br><span class="line">输出：[<span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>解法一：双向遍历</p><p>​ 得到到两侧最近的距离，然后求最小值，直接返回，比较直观</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shortestToChar</span>(<span class="params">self, s: <span class="built_in">str</span>, c: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        inf = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        result =[inf]*<span class="built_in">len</span>(s)</span><br><span class="line">        c_index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == c:</span><br><span class="line">                c_index=i</span><br><span class="line">                result[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> c_index !=-<span class="number">1</span>:</span><br><span class="line">                result[i] = i-c_index</span><br><span class="line">        c_index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[i] == c:</span><br><span class="line">                c_index = i</span><br><span class="line">            <span class="keyword">if</span> c_index!=-<span class="number">1</span>:</span><br><span class="line">                result[i] = <span class="built_in">min</span>(result[i],c_index - i)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>解法二：BFS</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">起始令所有的 ans[i] = -1ans[i]=−1，然后将所有的 c 字符的下标入队，并更新 ans[i] = 0ans[i]=0，然后跑一遍 BFS 逻辑，通过 ans[i]ans[i] 是否为 -1−1 来判断是否重复入队。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">shortestToChar</span>(<span class="params">self, s: <span class="built_in">str</span>, c: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">       <span class="comment">#首先准备一个结果列表，先置位-1</span></span><br><span class="line">       result = [-<span class="number">1</span>]*<span class="built_in">len</span>(s)</span><br><span class="line">       <span class="comment">#遍历一次，将和c字符相等的字符相应的位置入队，同时将对应的结果列表位置置为0</span></span><br><span class="line">       que = deque()</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">           <span class="keyword">if</span> s[i] == c:</span><br><span class="line">               result[i] = <span class="number">0</span></span><br><span class="line">               que.appendleft(i)</span><br><span class="line">       <span class="comment">#进行BFS逻辑</span></span><br><span class="line">       <span class="keyword">while</span> <span class="built_in">len</span>(que):</span><br><span class="line">           <span class="comment">#取出当前队头元素</span></span><br><span class="line">           t = que.pop()</span><br><span class="line">           <span class="keyword">for</span> i <span class="keyword">in</span> (-<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">               index = t+i</span><br><span class="line">               <span class="comment">#在位置不越界的情况下，如果该位置没被访问过，就将改位置的result值置为reslut[t] + 1</span></span><br><span class="line">               <span class="comment">#并将该节点入队</span></span><br><span class="line">               <span class="keyword">if</span> index&gt;=<span class="number">0</span> <span class="keyword">and</span> index &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> result[index]==-<span class="number">1</span>:</span><br><span class="line">                   result[index] = result[t] + <span class="number">1</span></span><br><span class="line">                   que.appendleft(index)</span><br><span class="line">       <span class="keyword">return</span> result </span><br></pre></td></tr></table></figure><h4 id="388-文件的最长绝对路径"><a class="anchor" href="#388-文件的最长绝对路径">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvbG9uZ2VzdC1hYnNvbHV0ZS1maWxlLXBhdGgv">388. 文件的最长绝对路径</span></h4><p>难度中等 215</p><p>假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：</p><p><img data-src="https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg" alt="img"></p><p>这里将 <code>dir</code> 作为根目录中的唯一目录。 <code>dir</code> 包含两个子目录 <code>subdir1</code> 和 <code>subdir2</code> 。 <code>subdir1</code> 包含文件 <code>file1.ext</code> 和子目录 <code>subsubdir1</code> ； <code>subdir2</code> 包含子目录 <code>subsubdir2</code> ，该子目录下包含文件 <code>file2.ext</code> 。</p><p>在文本格式中，如下所示 (⟶表示制表符)：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dir</span></span><br><span class="line"><span class="keyword"></span>⟶ <span class="keyword">subdir1</span></span><br><span class="line"><span class="keyword"></span>⟶ ⟶ file1.<span class="keyword">ext</span></span><br><span class="line"><span class="keyword"></span>⟶ ⟶ <span class="keyword">subsubdir1</span></span><br><span class="line"><span class="keyword"></span>⟶ <span class="keyword">subdir2</span></span><br><span class="line"><span class="keyword"></span>⟶ ⟶ <span class="keyword">subsubdir2</span></span><br><span class="line"><span class="keyword"></span>⟶ ⟶ ⟶ file2.<span class="keyword">ext</span></span><br></pre></td></tr></table></figure><p>如果是代码表示，上面的文件系统可以写为 <code>&quot;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&quot;</code> 。 <code>'\n'</code> 和 <code>'\t'</code> 分别是换行符和制表符。</p><p>文件系统中的每个文件和文件夹都有一个唯一的 <strong>绝对路径</strong> ，即必须打开才能到达文件 / 目录所在位置的目录顺序，所有路径用 <code>'/'</code> 连接。上面例子中，指向 <code>file2.ext</code> 的 <strong>绝对路径</strong> 是 <code>&quot;dir/subdir2/subsubdir2/file2.ext&quot;</code> 。每个目录名由字母、数字和 / 或空格组成，每个文件名遵循 <code>name.extension</code> 的格式，其中 <code>name</code> 和 <code>extension</code> 由字母、数字和 / 或空格组成。</p><p>给定一个以上述格式表示文件系统的字符串 <code>input</code> ，返回文件系统中 <em>指向 <strong>文件</strong> 的 <strong>最长绝对路径</strong> 的长度</em> 。 如果系统中没有文件，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg" alt="img"></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：input = <span class="string">&quot;dir<span class="subst">\n</span><span class="subst">\t</span>subdir1<span class="subst">\n</span><span class="subst">\t</span>subdir2<span class="subst">\n</span><span class="subst">\t</span><span class="subst">\t</span>file.ext&quot;</span></span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：只有一个文件，绝对路径为 <span class="string">&quot;dir/subdir2/file.ext&quot;</span> ，路径长度 <span class="number">20</span></span><br></pre></td></tr></table></figure><p>解法一：栈</p><ul><li>用一个栈去存储遍历过的路径，因为只要长度，所以栈中只保存文件路径的长度信息，栈中元素的个数即表示该路径的深度；而栈顶元素则表示该路径的长度</li><li>每遍历到一个 “文件”，首先得到该 &quot;文件&quot; 的路径深度，即它前面的制表符的个数；再得到该 “文件” 名称的长度以及该 “文件” 是否是一个文件，然后与栈顶比较<ul><li>如果当前遍历到的路径深度小于该 “文件” 的路径深度，那么当前路径肯定是该 “文件” 的上级路径</li><li>如果当前遍历到的路径深度大于等于该 “文件” 的路径深度，那么当前的路径肯定不是该 “文件” 的上级路径，所以得不断地弹出栈顶元素，直到栈顶元素所表示的路径深度小于该 “文件” 的路径深度，此时才能将该 “文件” 的绝对路径长度找到</li><li>如果当前找到的 “文件” 是真正的文件的话，就更新当前见过的文件绝对路径的最大值，遍历完成之后的路径长度即为最终结果</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthLongestPath</span>(<span class="params">self, <span class="built_in">input</span>: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        len_input = <span class="built_in">len</span>(<span class="built_in">input</span>)</span><br><span class="line">        i = <span class="number">0</span> </span><br><span class="line">        result = <span class="number">0</span> </span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> i&lt;len_input:</span><br><span class="line">            <span class="comment">#先计算当前文件的深度</span></span><br><span class="line">            depth = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len_input <span class="keyword">and</span> <span class="built_in">input</span>[i]==<span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">                depth +=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="comment">#再计算当前文件名的长度</span></span><br><span class="line">            file_length,is_file = <span class="number">0</span> , <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len_input <span class="keyword">and</span> <span class="built_in">input</span>[i] !=<span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                <span class="comment">#检查该名称是否是文件</span></span><br><span class="line">                <span class="keyword">if</span>  <span class="built_in">input</span>[i] == <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">                    is_file = <span class="literal">True</span></span><br><span class="line">                file_length+=<span class="number">1</span></span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="comment">#跳过换行符</span></span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="comment">#如果当前文件的深度小于等于当前路径的深度，就一直弹出栈中的最后一个目录，直到栈顶目录是该文件的上级为止</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(stack)&gt;=depth:</span><br><span class="line">                    stack.pop()</span><br><span class="line">            <span class="comment">#经过上述操作之后，栈顶目录即为该文件的上级目录</span></span><br><span class="line">            <span class="comment">#如果此时栈不空的话</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack):</span><br><span class="line">                stack.append(stack[-<span class="number">1</span>]+file_length+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(file_length)</span><br><span class="line">            <span class="comment">#如果当前路径是文件的话，就做路径长度更新操作</span></span><br><span class="line">            <span class="keyword">if</span> is_file:</span><br><span class="line">                result = <span class="built_in">max</span>(result,stack[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="396-旋转函数"><a class="anchor" href="#396-旋转函数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90YXRlLWZ1bmN0aW9uLw==">396. 旋转函数</span></h4><p>难度中等 115</p><p>给定一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。</p><p>假设 <code>arrk</code> 是数组 <code>nums</code> 顺时针旋转 <code>k</code> 个位置后的数组，我们定义 <code>nums</code> 的 <strong>旋转函数</strong> <code>F</code> 为：</p><ul><li><code>F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]</code></li></ul><p>返回 <em><code>F(0), F(1), ..., F(n-1)</code> 中的最大值</em> 。</p><p>生成的测试用例让答案符合 <strong>32 位</strong> 整数。</p><p><strong>示例 1:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [4,3,2,6]</span><br><span class="line">输出: 26</span><br><span class="line">解释:</span><br><span class="line">F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) =<span class="number"> 0 </span>+<span class="number"> 3 </span>+<span class="number"> 4 </span>+<span class="number"> 18 </span>= 25</span><br><span class="line">F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) =<span class="number"> 0 </span>+<span class="number"> 4 </span>+<span class="number"> 6 </span>+<span class="number"> 6 </span>= 16</span><br><span class="line">F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) =<span class="number"> 0 </span>+<span class="number"> 6 </span>+<span class="number"> 8 </span>+<span class="number"> 9 </span>= 23</span><br><span class="line">F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) =<span class="number"> 0 </span>+<span class="number"> 2 </span>+<span class="number"> 12 </span>+<span class="number"> 12 </span>= 26</span><br><span class="line">所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) =<span class="number"> 26 </span>。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: nums = [100]</span></span><br><span class="line"><span class="section">输出: 0</span></span><br></pre></td></tr></table></figure><p>题解：迭代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxRotateFunction</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"><span class="comment">#可以知道F(k+1)  =  (k+1) * nums[0] + (k+2)*nums[1] +....(n-1)*nums[n-k-2]+0*nums[n-k-1]+1*nums[n-k]+....+(k)*nums[n-1] </span></span><br><span class="line"><span class="comment"># F(k)  =  k * nums[0] + (k+1)*nums[1] +....(n-1)*nums[n-k-1]+0*nums[n-k]+1*nums[n-k+1]+....+(k-1)*nums[n-1] </span></span><br><span class="line"><span class="comment">#可知：F(k+1)-F(k)=Sum(nums)-n*nums[n-k-1]</span></span><br><span class="line"><span class="comment">#由此迭代公式可以求出F(1)~F(k)的值</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        nums_sum = <span class="built_in">sum</span>(nums)</span><br><span class="line">        num=[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            num[<span class="number">0</span>]+=i*nums[i]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">            num.append(num[-<span class="number">1</span>]+nums_sum-length*nums[length-k])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(num)</span><br><span class="line">                </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="47-全排列-ii"><a class="anchor" href="#47-全排列-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLWlpLw==">47. 全排列 II</span></h4><p>难度中等 1032</p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,1,2]</span></span><br><span class="line">输出：</span><br><span class="line"><span class="comment">[<span class="comment">[1,1,2]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[1,2,1]</span>,</span></span><br><span class="line"><span class="comment"> <span class="comment">[2,1,1]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[1,2,3]</span></span><br><span class="line">输出：<span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[1,3,2]</span>,<span class="comment">[2,1,3]</span>,<span class="comment">[2,3,1]</span>,<span class="comment">[3,1,2]</span>,<span class="comment">[3,2,1]</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">nums:<span class="built_in">list</span>,n:<span class="built_in">int</span>,used:<span class="built_in">list</span>,result:<span class="built_in">list</span>,path:<span class="built_in">list</span></span>):</span><br><span class="line">            <span class="keyword">if</span> n == <span class="built_in">len</span>(nums):</span><br><span class="line">                result.append(path[:])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment">#如果该位置没有没访问过，就直接加入</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                    path.append(nums[i])</span><br><span class="line">                    used[i] = <span class="literal">True</span></span><br><span class="line">                    dfs(nums,n+<span class="number">1</span>,used,result,path)</span><br><span class="line">                    <span class="comment">#回溯</span></span><br><span class="line">                    path.pop()</span><br><span class="line">                    used[i]  =  <span class="literal">False</span></span><br><span class="line">        used = [<span class="literal">False</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        result = []</span><br><span class="line">        path = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        dfs(nums,<span class="number">0</span>,used,result,path)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="587-安装栅栏"><a class="anchor" href="#587-安装栅栏">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZXJlY3QtdGhlLWZlbmNlLw==">587. 安装栅栏</span></h4><p>难度困难 102</p><p>在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用<strong>最短</strong>的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。</p><p><strong>示例 1:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="comment">[<span class="comment">[1,1]</span>,<span class="comment">[2,2]</span>,<span class="comment">[2,0]</span>,<span class="comment">[2,4]</span>,<span class="comment">[3,3]</span>,<span class="comment">[4,2]</span>]</span></span><br><span class="line">输出: <span class="comment">[<span class="comment">[1,1]</span>,<span class="comment">[2,0]</span>,<span class="comment">[4,2]</span>,<span class="comment">[3,3]</span>,<span class="comment">[2,4]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">[[1,2],[2,2],[4,2]]</span></span><br><span class="line">输出: <span class="string">[[1,2],[2,2],[4,2]]</span></span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">即使树都在一条直线上，你也需要先用绳子包围它们。</span><br></pre></td></tr></table></figure><p>分析：凸包问题</p><p>解法一：Jarvis 算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">#计算叉积（非严格意义上的），如果大于零说明r在pq向量的左侧</span></span><br><span class="line">        <span class="comment">#如果除了pq两点，其他的r点都在pq向量的左侧，就将pq添加进凸包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cross</span>(<span class="params">p:<span class="built_in">list</span>,q:<span class="built_in">list</span>,r:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param p: [p0,p1]</span></span><br><span class="line"><span class="string">    :param q: [q0,q1]</span></span><br><span class="line"><span class="string">    :param r: [r0,r1]</span></span><br><span class="line"><span class="string">    :return: q0-p0  r0-q0</span></span><br><span class="line"><span class="string">             q1-p1  r1-q1</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    result = (r[<span class="number">1</span>]-q[<span class="number">1</span>])*(q[<span class="number">0</span>]-p[<span class="number">0</span>])-(r[<span class="number">0</span>]-q[<span class="number">0</span>])*(q[<span class="number">1</span>]-p[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    trees = [[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">3</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>]]</span><br><span class="line">    result = []</span><br><span class="line">    length = <span class="built_in">len</span>(trees)</span><br><span class="line">    <span class="comment"># 找到最左边的点</span></span><br><span class="line">    left_max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        <span class="keyword">if</span> trees[i][<span class="number">0</span>] &lt; trees[left_max][<span class="number">0</span>]:</span><br><span class="line">            left_max = i</span><br><span class="line">    <span class="comment"># 将最左边的点，加入到结果数组中</span></span><br><span class="line">    result.append(trees[left_max])</span><br><span class="line">    V = [<span class="literal">True</span> <span class="keyword">if</span> i == left_max <span class="keyword">else</span> <span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">    p = left_max</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        q = (p + <span class="number">1</span>) % length</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="comment">#暂时先不管是否是已找到的边界上的点，只要右侧还有点，说明该边界不是最终的边界</span></span><br><span class="line">            <span class="keyword">if</span> cross(trees[p], trees[q], trees[i])&lt;<span class="number">0</span>:</span><br><span class="line">                q = i</span><br><span class="line">        <span class="comment">#寻找是否在一条直线的，可以一次性加入</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> V[i] <span class="keyword">and</span> i!=q <span class="keyword">and</span> cross(trees[p],trees[q],trees[i])==<span class="number">0</span>:</span><br><span class="line">                result.append(trees[i])</span><br><span class="line">                V[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> V[q]:</span><br><span class="line">            result.append(trees[q])</span><br><span class="line">            V[q] = <span class="literal">True</span></span><br><span class="line">        p = q</span><br><span class="line">        <span class="keyword">if</span> p == left_max:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>解法二：Graham 算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果r点是在pq向量的左侧，则返回值大于零</span></span><br><span class="line"><span class="string">如果r点是在pq向量的右侧，则返回值小于零</span></span><br><span class="line"><span class="string">如果r点是在pq向量上，则返回值等于零</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">trees = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cross</span>(<span class="params">p:<span class="built_in">list</span>,q:<span class="built_in">list</span>,r:<span class="built_in">list</span></span>):</span><br><span class="line">   <span class="keyword">return</span> (q[<span class="number">0</span>]-p[<span class="number">0</span>])*(r[<span class="number">1</span>]-q[<span class="number">1</span>])-(r[<span class="number">0</span>]-q[<span class="number">0</span>])*(q[<span class="number">1</span>]-p[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">返回p、q两点之间的距离</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">distance</span>(<span class="params">p:<span class="built_in">list</span>,q:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">return</span> (q[<span class="number">0</span>]-p[<span class="number">0</span>])**<span class="number">2</span> + (q[<span class="number">1</span>]-p[<span class="number">1</span>])**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">比较函数，将个点以第一个点为原点，按照极角大小从小到大排序（即按照顺时针）</span></span><br><span class="line"><span class="string">如果极角大小相等，就按照距离原点的距离从小到大进行排序</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">a:<span class="built_in">list</span>,b:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">if</span> cross(trees[<span class="number">0</span>],a,b)&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> cross(trees[<span class="number">0</span>],a,b)&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> distance(trees[<span class="number">0</span>],a)&lt;distance(trees[<span class="number">0</span>],b):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    trees = [[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">3</span>],[<span class="number">7</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>]]</span><br><span class="line">    length = <span class="built_in">len</span>(trees)</span><br><span class="line">    <span class="comment">#首先应该找到y值最小的这个点（因为这个点肯定是在边界上的）</span></span><br><span class="line">    bottom = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        <span class="keyword">if</span> trees[i][<span class="number">1</span>]&lt; trees[bottom][<span class="number">1</span>]:</span><br><span class="line">            bottom = i</span><br><span class="line">    <span class="comment">#找到之后交换两者的位置，再将剩下的点，以该点为原点，按照比较准则进行排序</span></span><br><span class="line">    trees[<span class="number">0</span>],trees[bottom] = trees[bottom],trees[<span class="number">0</span>]</span><br><span class="line">    trees[<span class="number">1</span>:] = <span class="built_in">sorted</span>(trees[<span class="number">1</span>:],key=cmp_to_key(cmp))</span><br><span class="line">    <span class="comment">#对最后一个如果相等的边界掉转</span></span><br><span class="line">    i = length -<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">1</span> <span class="keyword">and</span> cross(trees[<span class="number">0</span>],trees[i],trees[i-<span class="number">1</span>])==<span class="number">0</span>:</span><br><span class="line">        i-=<span class="number">1</span></span><br><span class="line">    trees[i:] = trees[-<span class="number">1</span>:i-<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">    <span class="comment">#建立一个栈，先把前两个入栈，然后在进行调动</span></span><br><span class="line">    stack = []</span><br><span class="line">    stack.append(trees[<span class="number">0</span>])</span><br><span class="line">    stack.append(trees[<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#从下标为2的点开始</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,length):</span><br><span class="line">        <span class="comment">#先将不符合条件的栈顶元素弹出</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack)&gt;<span class="number">1</span> <span class="keyword">and</span> cross(stack[-<span class="number">2</span>],stack[-<span class="number">1</span>],trees[i])&lt;<span class="number">0</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        stack.append(trees[i])</span><br><span class="line">    <span class="built_in">print</span>(stack)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解法三：Andrew 算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果r点是在pq向量的左侧，则返回值大于零</span></span><br><span class="line"><span class="string">如果r点是在pq向量的右侧，则返回值小于零</span></span><br><span class="line"><span class="string">如果r点是在pq向量上，则返回值等于零</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cross</span>(<span class="params">p:<span class="built_in">list</span>,q:<span class="built_in">list</span>,r:<span class="built_in">list</span></span>):</span><br><span class="line">   <span class="keyword">return</span> (q[<span class="number">0</span>]-p[<span class="number">0</span>])*(r[<span class="number">1</span>]-q[<span class="number">1</span>])-(r[<span class="number">0</span>]-q[<span class="number">0</span>])*(q[<span class="number">1</span>]-p[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    trees = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">6</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">2</span>]]</span><br><span class="line">    length = <span class="built_in">len</span>(trees)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    首先应该按照x坐标大小从大到小进行排序，如果x坐标一样，就按照y坐标从小到大进行排序</span></span><br><span class="line"><span class="string">    得到拍完须知后的数组之后，则第一个和最后一个肯定在最终的边界上，因此可以从第一个开始</span></span><br><span class="line"><span class="string">    找下凸壳，从最后一个开始找上凸壳，合在一起就是整个边界</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    trees.sort()</span><br><span class="line">    result = [<span class="number">0</span>]</span><br><span class="line">    used = [<span class="literal">False</span>]*length</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#找下凸壳</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(result)&gt;<span class="number">1</span> <span class="keyword">and</span> cross(trees[result[-<span class="number">2</span>]], trees[result[-<span class="number">1</span>]], trees[i]) &lt; <span class="number">0</span>:</span><br><span class="line">            used[result.pop()] = <span class="literal">False</span></span><br><span class="line">        used[i] = <span class="literal">True</span></span><br><span class="line">        result.append(i)</span><br><span class="line">    m = <span class="built_in">len</span>(result)</span><br><span class="line">    <span class="comment">#寻找上凸壳，因为最后肯定会将第一个点加入，所以第一个点就参与了两次，最后弹出就可以了</span></span><br><span class="line">    <span class="comment">#寻找上凸壳的时候，应该从后往前进行遍历，找的点肯定不会在之前的下凸壳上（即两个壳只在结束和开始位置相交）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(result) &gt; m  <span class="keyword">and</span> cross(trees[result[-<span class="number">2</span>]],trees[result[-<span class="number">1</span>]],trees[i])&lt;<span class="number">0</span>:</span><br><span class="line">                used[result.pop()] = <span class="literal">False</span></span><br><span class="line">            used[i] = <span class="literal">True</span></span><br><span class="line">            result.append(i)</span><br><span class="line">    <span class="comment">#因为第一个既参与了上凸壳的寻找，也参与了下凸壳的寻找，所以最后要弹出最后一个点</span></span><br><span class="line">    result.pop()</span><br><span class="line">    <span class="built_in">print</span>([trees[i] <span class="keyword">for</span> i <span class="keyword">in</span> result])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="560-和为-k-的子数组"><a class="anchor" href="#560-和为-k-的子数组">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3ViYXJyYXktc3VtLWVxdWFscy1rLw==">560. 和为 K 的子数组</span></h4><p>难度中等 1451</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,1,1], k = 2</span></span><br><span class="line"><span class="string">输出：2</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,2,3], k = 3</span></span><br><span class="line"><span class="string">输出：2</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-107 &lt;= k &lt;= 107</code></li></ul><p>题解：前缀和 + 哈希表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#前缀和+哈希表</span></span><br><span class="line">        pre_count = <span class="built_in">dict</span>()</span><br><span class="line">        pre_count[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        pre = <span class="number">0</span> </span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment">#更新此时的前缀和  map集合</span></span><br><span class="line">            pre+=nums[i]</span><br><span class="line">            pre_count[pre] = pre_count.get(pre,<span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">            <span class="comment">#查找以i结尾的子数组和为k的个数</span></span><br><span class="line">            <span class="keyword">if</span> k!=<span class="number">0</span>:</span><br><span class="line">               count += pre_count.get(pre-k,<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count += (pre_count.get(pre,<span class="number">0</span>)-<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h4 id="417-太平洋大西洋水流问题"><a class="anchor" href="#417-太平洋大西洋水流问题">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGFjaWZpYy1hdGxhbnRpYy13YXRlci1mbG93Lw==">417. 太平洋大西洋水流问题</span></h4><p>难度中等 417</p><p>有一个 <code>m × n</code> 的矩形岛屿，与 <strong>太平洋</strong> 和 <strong>大西洋</strong> 相邻。 <strong>“太平洋”</strong> 处于大陆的左边界和上边界，而 <strong>“大西洋”</strong> 处于大陆的右边界和下边界。</p><p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个 <code>m x n</code> 的整数矩阵 <code>heights</code> ， <code>heights[r][c]</code> 表示坐标 <code>(r, c)</code> 上单元格 <strong>高于海平面的高度</strong> 。</p><p>岛上雨水较多，如果相邻单元格的高度 <strong>小于或等于</strong> 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p><p>返回 <em>网格坐标 <code>result</code> 的 <strong>2D 列表</strong> ，其中 <code>result[i] = [ri, ci]</code> 表示雨水可以从单元格 <code>(ri, ci)</code> 流向 <strong>太平洋和大西洋</strong></em> 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: heights = <span class="comment">[<span class="comment">[1,2,2,3,5]</span>,<span class="comment">[3,2,3,4,4]</span>,<span class="comment">[2,4,5,3,1]</span>,<span class="comment">[6,7,1,4,5]</span>,<span class="comment">[5,1,1,2,4]</span>]</span></span><br><span class="line">输出: <span class="comment">[<span class="comment">[0,4]</span>,<span class="comment">[1,3]</span>,<span class="comment">[1,4]</span>,<span class="comment">[2,2]</span>,<span class="comment">[3,0]</span>,<span class="comment">[3,1]</span>,<span class="comment">[4,0]</span>]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: heights = <span class="string">[[2,1],[1,2]]</span></span><br><span class="line">输出: <span class="string">[[0,0],[0,1],[1,0],[1,1]]</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == heights.length</code></li><li><code>n == heights[r].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>0 &lt;= heights[r][c] &lt;= 105</code></li></ul><p>题解：深度优先搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断在某一位置水是否可以流向太平洋和大西洋</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Pacific_Atlantic</span>(<span class="params">heights: <span class="built_in">list</span>, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, i: <span class="built_in">int</span>, j: <span class="built_in">int</span>, result: <span class="built_in">list</span>,V:<span class="built_in">list</span></span>):</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span>:</span><br><span class="line">        result[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; m-<span class="number">1</span> <span class="keyword">or</span> j &gt; n-<span class="number">1</span>:</span><br><span class="line">        result[<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    V[i][j] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> heights[i - <span class="number">1</span>][j] &lt;= heights[i][j] <span class="keyword">and</span> <span class="keyword">not</span> V[i-<span class="number">1</span>][j]:</span><br><span class="line">        Pacific_Atlantic(heights, m, n, i - <span class="number">1</span>, j, result,V)</span><br><span class="line">    <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">or</span> heights[i][j - <span class="number">1</span>] &lt;= heights[i][j] <span class="keyword">and</span> <span class="keyword">not</span> V[i][j-<span class="number">1</span>]:</span><br><span class="line">        Pacific_Atlantic(heights, m, n, i, j - <span class="number">1</span>, result,V)</span><br><span class="line">    <span class="keyword">if</span> i == m-<span class="number">1</span> <span class="keyword">or</span> heights[i + <span class="number">1</span>][j] &lt;= heights[i][j] <span class="keyword">and</span> <span class="keyword">not</span> V[i+<span class="number">1</span>][j]:</span><br><span class="line">        Pacific_Atlantic(heights, m, n, i + <span class="number">1</span>, j, result,V)</span><br><span class="line">    <span class="keyword">if</span> j == n-<span class="number">1</span> <span class="keyword">or</span> heights[i][j + <span class="number">1</span>] &lt;= heights[i][j] <span class="keyword">and</span> <span class="keyword">not</span> V[i][j+<span class="number">1</span>]:</span><br><span class="line">        Pacific_Atlantic(heights, m , n, i, j + <span class="number">1</span>, result,V)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    heights = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line">    m = <span class="built_in">len</span>(heights)</span><br><span class="line">    n = <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            t = [<span class="literal">False</span>] * <span class="number">2</span></span><br><span class="line">            V = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">            Pacific_Atlantic(heights, m, n, i, j, t,V)</span><br><span class="line">            <span class="keyword">if</span> t[<span class="number">0</span>] <span class="keyword">and</span> t[<span class="number">1</span>]:</span><br><span class="line">                result.append([i, j])</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h4 id="96-不同的二叉搜索树"><a class="anchor" href="#96-不同的二叉搜索树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdW5pcXVlLWJpbmFyeS1zZWFyY2gtdHJlZXMv">96. 不同的二叉搜索树</span></h4><p>难度中等 1720</p><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><p>题解：动态规划</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="201-数字范围按位与"><a class="anchor" href="#201-数字范围按位与">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvYml0d2lzZS1hbmQtb2YtbnVtYmVycy1yYW5nZS8=">201. 数字范围按位与</span></h4><p>难度中等 376</p><p>给你两个整数 <code>left</code> 和 <code>right</code> ，表示区间 <code>[left, right]</code> ，返回此区间内所有数字 <strong>按位与</strong> 的结果（包含 <code>left</code> 、 <code>right</code> 端点）。</p><p><strong>示例 1：</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">left</span> = <span class="number">5</span>, <span class="built_in">right</span> = <span class="number">7</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">left</span> = <span class="number">1</span>, <span class="built_in">right</span> = <span class="number">2147483647</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p>题解：概述</p><p>移位操作直到两个数相等，此时两个数就是 [m,n] 之间所有数的公共前缀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rangeBitwiseAnd</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#寻找公共前缀</span></span><br><span class="line">        <span class="comment">#因为是找公共前缀，所以就找其中最不相同的两个，就是第一个和最后一个就可以了</span></span><br><span class="line">        <span class="comment">#记录次数，（即最后结果中后面零的个数）</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left !=right:</span><br><span class="line">            <span class="comment">#向右移一位</span></span><br><span class="line">            left &gt;&gt;= <span class="number">1</span></span><br><span class="line">            right &gt;&gt;= <span class="number">1</span></span><br><span class="line">            result +=<span class="number">1</span></span><br><span class="line">        <span class="comment">#将前缀移到原来的位置上</span></span><br><span class="line">        <span class="keyword">return</span> left&lt;&lt;result</span><br></pre></td></tr></table></figure><p>N&amp;(N-1) ：能够去除一个数二进制形式上，最后一位 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rangeBitwiseAnd</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">while</span> right&gt;left:</span><br><span class="line">            right = (right-<span class="number">1</span>)&amp;right</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h4 id="909-蛇梯棋"><a class="anchor" href="#909-蛇梯棋">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc25ha2VzLWFuZC1sYWRkZXJzLw==">909. 蛇梯棋</span></h4><p>难度中等</p><p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>board</code> ，方格按从 <code>1</code> 到 <code>n2</code> 编号，编号遵循 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclODklOUIlRTglODAlOTUlRTUlQkMlOEYlRTglQkQlQUMlRTglQTElOEMlRTQlQjklQTYlRTUlODYlOTklRTYlQjMlOTUvMTcxOTU3ODY=">转行交替方式</span> ，<strong>从左下角开始</strong> （即，从 <code>board[n - 1][0]</code> 开始）每一行交替方向。</p><p>玩家从棋盘上的方格 <code>1</code> （总是在最后一行、第一列）开始出发。</p><p>每一回合，玩家需要从当前方格 <code>curr</code> 开始出发，按下述要求前进：</p><ul><li><p>选定目标方格</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">next</span></span><br></pre></td></tr></table></figure><p>，目标方格的编号符合范围</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">curr</span> + <span class="number">1</span>, min(<span class="name">curr</span> + <span class="number">6</span>, n2)]</span><br></pre></td></tr></table></figure><p>。</p><ul><li>该选择模拟了掷 <strong>六面体骰子</strong> 的情景，无论棋盘大小如何，玩家最多只能有 6 个目的地。</li></ul></li><li><p>传送玩家：如果目标方格 <code>next</code> 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 <code>next</code> 。</p></li><li><p>当玩家到达编号 <code>n2</code> 的方格时，游戏结束。</p></li></ul><p><code>r</code> 行 <code>c</code> 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 <code>board[r][c] != -1</code> ，那个蛇或梯子的目的地将会是 <code>board[r][c]</code> 。编号为 <code>1</code> 和 <code>n2</code> 的方格上没有蛇或梯子。</p><p>注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，玩家也 <strong>不能</strong> 继续移动。</p><ul><li>举个例子，假设棋盘是 <code>[[-1,4],[-1,3]]</code> ，第一次移动，玩家的目标方格是 <code>2</code> 。那么这个玩家将会顺着梯子到达方格 <code>3</code> ，但 <strong>不能</strong> 顺着方格 <code>3</code> 上的梯子前往方格 <code>4</code> 。</li></ul><p>返回达到编号为 <code>n2</code> 的方格所需的最少移动次数，如果不可能，则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2018/09/23/snakes.png" alt="img"></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>],[<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>],[<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>],[<span class="string">-1</span>,35,<span class="string">-1</span>,<span class="string">-1</span>,13,<span class="string">-1</span>],[<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>],[<span class="string">-1</span>,15,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>,<span class="string">-1</span>]]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">首先，从方格 1 [第 5 行，第 0 列] 开始。 </span><br><span class="line">先决定移动到方格 2 ，并必须爬过梯子移动到到方格 15 。</span><br><span class="line">然后决定移动到方格 17 [第 3 行，第 4 列]，必须爬过蛇到方格 13 。</span><br><span class="line">接着决定移动到方格 14 ，且必须通过梯子移动到方格 35 。 </span><br><span class="line">最后决定移动到方格 36 , 游戏结束。 </span><br><span class="line">可以证明需要至少 4 次移动才能到达最后一个方格，所以答案是 4 。 </span><br></pre></td></tr></table></figure><p>我们可以将棋盘抽象成一个包含 N^2 个节点的有向图，对于每个节点 x，若 x+i (1≤i≤6) 上没有蛇或梯子，则连一条从 x 到 x+i 的有向边；否则记蛇梯的目的地为 y，连一条从 x 到 y 的有向边。如此转换后，原问题等价于在这张有向图上求出从 1 到 N^2 的最短路长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">snakesAndLadders</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(board)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">id2rc</span>(<span class="params">idx: <span class="built_in">int</span></span>) -&gt; (<span class="built_in">int</span>, <span class="built_in">int</span>):</span><br><span class="line">            r, c = (idx - <span class="number">1</span>) // n, (idx - <span class="number">1</span>) % n</span><br><span class="line">            <span class="keyword">if</span> r % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                c = n - <span class="number">1</span> - c</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span> - r, c</span><br><span class="line">        </span><br><span class="line">        vis = <span class="built_in">set</span>()</span><br><span class="line">        q = deque([(<span class="number">1</span>, <span class="number">0</span>)])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            idx, step = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span> + <span class="number">1</span>):</span><br><span class="line">                idx_nxt = idx + i</span><br><span class="line">                <span class="keyword">if</span> idx_nxt &gt; n * n:   <span class="comment"># 超出边界</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">                x_nxt, y_nxt = id2rc(idx_nxt)   <span class="comment"># 得到下一步的行列</span></span><br><span class="line">                <span class="keyword">if</span> board[x_nxt][y_nxt] &gt; <span class="number">0</span>:   <span class="comment"># 存在蛇或梯子</span></span><br><span class="line">                    idx_nxt = board[x_nxt][y_nxt]</span><br><span class="line">                <span class="keyword">if</span> idx_nxt == n * n:   <span class="comment"># 到达终点</span></span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> idx_nxt <span class="keyword">not</span> <span class="keyword">in</span> vis:</span><br><span class="line">                    vis.add(idx_nxt)</span><br><span class="line">                    q.append((idx_nxt, step + <span class="number">1</span>))   <span class="comment"># 扩展新状态</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="591-标签验证器"><a class="anchor" href="#591-标签验证器">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvdGFnLXZhbGlkYXRvci8=">591. 标签验证器</span></h4><p>难度困难 43</p><p>给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：</p><ol><li>代码必须被<strong>合法的闭合标签</strong>包围。否则，代码是无效的。</li><li><strong>闭合标签</strong>（不一定合法）要严格符合格式： <code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code> 。其中， <code>&lt;TAG_NAME&gt;</code> 是起始标签， <code>&lt;/TAG_NAME&gt;</code> 是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是<strong>合法的</strong>。</li><li><strong>合法的</strong> <code>TAG_NAME</code> 仅含有<strong>大写字母</strong>，长度在范围 [1,9] 之间。否则，该 <code>TAG_NAME</code> 是<strong>不合法的</strong>。</li><li><strong>合法的</strong> <code>TAG_CONTENT</code> 可以包含其他<strong>合法的闭合标签</strong>，<strong>cdata</strong> （请参考规则 7）和任意字符（注意参考规则 1）<strong>除了</strong>不匹配的 <code>&lt;</code> 、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则， <code>TAG_CONTENT</code> 是<strong>不合法的</strong>。</li><li>一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。</li><li>一个 <code>&lt;</code> ，如果你找不到一个后续的 <code>&gt;</code> 与之匹配，是不合法的。并且当你找到一个 <code>&lt;</code> 或 <code>&lt;/</code> 时，所有直到下一个 <code>&gt;</code> 的前的字符，都应当被解析为 TAG_NAME（不一定合法）。</li><li>cdata 有如下格式： <code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code> 。 <code>CDATA_CONTENT</code> 的范围被定义成 <code>&lt;![CDATA[</code> 和<strong>后续的第一个</strong> <code>]]&gt;</code> 之间的字符。</li><li><code>CDATA_CONTENT</code> 可以包含<strong>任意字符</strong>。cdata 的功能是阻止验证器解析 <code>CDATA_CONTENT</code> ，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为<strong>常规字符</strong>。</li></ol><p><strong>合法代码的例子:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;<span class="tag">&lt;<span class="name">DIV</span>&gt;</span>This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;<span class="tag">&lt;/<span class="name">DIV</span>&gt;</span>&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">代码被包含在了闭合的标签内： <span class="tag">&lt;<span class="name">DIV</span>&gt;</span> 和 <span class="tag">&lt;/<span class="name">DIV</span>&gt;</span> 。</span><br><span class="line"></span><br><span class="line">TAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 </span><br><span class="line"></span><br><span class="line">即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。</span><br><span class="line"></span><br><span class="line">所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: &quot;<span class="tag">&lt;<span class="name">DIV</span>&gt;</span>&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]<span class="tag">&lt;/<span class="name">DIV</span>&gt;</span>&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">我们首先将代码分割为： start_tag|tag_content|end_tag 。</span><br><span class="line"></span><br><span class="line">start_tag -&gt; &quot;<span class="tag">&lt;<span class="name">DIV</span>&gt;</span>&quot;</span><br><span class="line"></span><br><span class="line">end_tag -&gt; &quot;<span class="tag">&lt;/<span class="name">DIV</span>&gt;</span>&quot;</span><br><span class="line"></span><br><span class="line">tag_content 也可被分割为： text1|cdata|text2 。</span><br><span class="line"></span><br><span class="line">text1 -&gt; &quot;&gt;&gt;  ![cdata[]] &quot;</span><br><span class="line"></span><br><span class="line">cdata -&gt; &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot; ，其中 CDATA_CONTENT 为 &quot;<span class="tag">&lt;<span class="name">div</span>&gt;</span>]&gt;&quot;</span><br><span class="line"></span><br><span class="line">text2 -&gt; &quot;]]&gt;&gt;]&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_tag 不是 &quot;<span class="tag">&lt;<span class="name">DIV</span>&gt;</span>&gt;&gt;&quot; 的原因参照规则 6 。</span><br><span class="line">cdata 不是 &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot; 的原因参照规则 7 。</span><br></pre></td></tr></table></figure><p><strong>不合法代码的例子:</strong></p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;<span class="attribute">&lt;A&gt;</span>  <span class="attribute">&lt;B&gt;</span> <span class="attribute">&lt;/A&gt;</span>   <span class="attribute">&lt;/B&gt;</span>&quot;</span><br><span class="line">输出: False</span><br><span class="line">解释: 不合法。如果 &quot;<span class="attribute">&lt;A&gt;</span>&quot; 是闭合的，那么 &quot;<span class="attribute">&lt;B&gt;</span>&quot; 一定是不匹配的，反之亦然。</span><br><span class="line"></span><br><span class="line">输入: &quot;<span class="attribute">&lt;DIV&gt;</span>  div tag is not closed  <span class="attribute">&lt;DIV&gt;</span>&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;<span class="attribute">&lt;DIV&gt;</span>  unmatched <span class="attribute">&lt;  &lt;/DIV&gt;</span>&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;<span class="attribute">&lt;DIV&gt;</span> closed tags with invalid tag name  <span class="attribute">&lt;b&gt;</span>123<span class="attribute">&lt;/b&gt;</span> <span class="attribute">&lt;/DIV&gt;</span>&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;<span class="attribute">&lt;DIV&gt;</span> unmatched tags with invalid tag name  <span class="attribute">&lt;/1234567890&gt;</span> and <span class="attribute">&lt;CDATA[[]]&gt;</span>  <span class="attribute">&lt;/DIV&gt;</span>&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;<span class="attribute">&lt;DIV&gt;</span>  unmatched start tag <span class="attribute">&lt;B&gt;</span>  and unmatched end tag <span class="attribute">&lt;/C&gt;</span>  <span class="attribute">&lt;/DIV&gt;</span>&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>为简明起见，你可以假设输入的代码（包括提到的<strong>任意字符</strong>）只包含 <code>数字</code> ，字母， <code>'&lt;'</code> , <code>'&gt;'</code> , <code>'/'</code> , <code>'!'</code> , <code>'['</code> , <code>']'</code> 和 <code>' '</code> 。</li></ol><h5 id="栈-字符串遍历"><a class="anchor" href="#栈-字符串遍历">#</a> 栈 + 字符串遍历</h5><p>思路与算法</p><p>本题是一道解析字符串的题目，涉及到标签的闭合。由于标签具有「最先开始的标签最后结束」的特性，因此我们可以考虑使用一个栈存储当前开放的标签。除此之外，我们还需要考虑 \text {cdata} cdata 以及一般的字符，二者都可以使用遍历 + 判断的方法直接进行验证。</p><p>我们可以对字符串 } code 进行一次遍历。在遍历的过程中，根据遍历到位置 ii 的当前字符，采取对应的判断：</p><p>如果当前的字符为 &lt;，那么需要考虑下面的四种情况：</p><ul><li><p>如果下一个字符为 /，那么说明我们遇到了一个结束标签。我们需要定位下一个 &gt; 的位置 j，此时 code [i+2…j−1] 就是该结束标签的名称。我们需要判断该名称与当前栈顶的名称是否匹配，如果匹配，说明名称的标签已经闭合，我们需要将当前栈顶的名称弹出。同时根据规则 1，我们需要保证整个 code 被闭合标签包围，因此如果栈中已经没有标签，但是 j 并不是 code 的末尾，那么说明后续还会有字符，它们不被闭合标签包围。</p></li><li><p>如果下一个字符为！，那么说明我们遇到了一个 cdata，我们需要继续往后读 77 个字符，判断其是否为 [CDATA [。在这之后，我们定位下一个]]&gt; 的位置 j，此时 code [i+9…j−1] 就是 cdata 中的内容，它不需要被解析，所以我们也不必进行任何验证。需要注意的是，根据规则 1，栈中需要存在至少一个开放的标签。</p></li><li><p>如果下一个字符为大写字母，那么说明我们遇到了一个开始标签。我们需要定位下一个 &gt; 的位置 j，此时 code [i+2…j−1] 就是该开始标签的名称。我们需要判断该名称是否恰好由 1 至 9 个大写字母组成，如果是，说明该标签合法，我们需要将该名称放入栈顶。</p></li><li><p>除此之外，如果不存在下一个字符，或者下一个字符不属于上述三种情况，那么 code 是不合法的。</p></li></ul><p>如果当前的字符为其它字符，那么根据规则 1，栈中需要存在至少一个开放的标签。</p><p>在遍历完成后，我们还需要保证此时栈中没有任何（还没有结束的）标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, code: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        tags = []</span><br><span class="line">        i, n = <span class="number">0</span>, <span class="built_in">len</span>(code)</span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> code[i] != <span class="string">&quot;&lt;&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tags:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i == n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> code[i + <span class="number">1</span>] == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                j = code.find(<span class="string">&quot;&gt;&quot;</span>, i)</span><br><span class="line">                <span class="keyword">if</span> j == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                tagname = code[i + <span class="number">2</span>: j]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tags <span class="keyword">or</span> tags[-<span class="number">1</span>] != tagname:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                tags.pop()</span><br><span class="line">                i = j + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tags <span class="keyword">and</span> i != n:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> code[i + <span class="number">1</span>] == <span class="string">&quot;!&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tags:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                cdata = code[i + <span class="number">2</span>: i + <span class="number">9</span>]</span><br><span class="line">                <span class="keyword">if</span> cdata != <span class="string">&quot;[CDATA[&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                j = code.find(<span class="string">&quot;]]&gt;&quot;</span>, i)</span><br><span class="line">                <span class="keyword">if</span> j == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                i = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = code.find(<span class="string">&quot;&gt;&quot;</span>, i)</span><br><span class="line">                <span class="keyword">if</span> j == -<span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                tagname = code[i + <span class="number">1</span>: j]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">1</span> &lt;= <span class="built_in">len</span>(tagname) &lt;= <span class="number">9</span> <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">all</span>(ch.isupper() <span class="keyword">for</span> ch <span class="keyword">in</span> tagname):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                tags.append(tagname)</span><br><span class="line">                i = j + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> tags</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="713-乘积小于-k-的子数组"><a class="anchor" href="#713-乘积小于-k-的子数组">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3ViYXJyYXktcHJvZHVjdC1sZXNzLXRoYW4tay8=">713. 乘积小于 K 的子数组</span></h4><p>难度中等 420 收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回子数组内所有元素的乘积严格小于 <code>k</code> 的连续子数组的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[10,5,2,6]</span>, k = 100</span><br><span class="line">输出：8</span><br><span class="line">解释：8 个乘积小于 100 的子数组分别为：<span class="comment">[10]</span>、<span class="comment">[5]</span>、<span class="comment">[2]</span>,、<span class="comment">[6]</span>、<span class="comment">[10,5]</span>、<span class="comment">[5,2]</span>、<span class="comment">[2,6]</span>、<span class="comment">[5,2,6]</span>。</span><br><span class="line">需要注意的是 <span class="comment">[10,5,2]</span> 并不是乘积小于 100 的子数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,2,3], k = 0</span></span><br><span class="line"><span class="string">输出：0</span></span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>0 &lt;= k &lt;= 106</code></li></ul><p>方法一：二分查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>], k = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">ans, n = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">logPrefix = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">    logPrefix[i + <span class="number">1</span>] = logPrefix[i] + log(num)</span><br><span class="line">logK = log(k)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    l = bisect_right(logPrefix, logPrefix[j] - logK + <span class="number">1e-10</span>, <span class="number">0</span>, j)</span><br><span class="line">    ans += j - l</span><br><span class="line"><span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>方法二：滑动窗口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#滑动窗口，找到以每一个位置结尾的字数租的个数，相加就得出结果</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        left , right = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        conProduct = <span class="number">1</span></span><br><span class="line">        result = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">if</span> k&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; length:</span><br><span class="line">            conProduct*=nums[right]</span><br><span class="line">            <span class="keyword">while</span> conProduct &gt;=k:</span><br><span class="line">                conProduct /=nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            result += right -left +<span class="number">1</span></span><br><span class="line">            right +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="48-旋转图像"><a class="anchor" href="#48-旋转图像">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcm90YXRlLWltYWdlLw==">48. 旋转图像</span></h4><p>难度中等 1276</p><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 **<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEUlOUYlRTUlOUMlQjAlRTclQUUlOTclRTYlQjMlOTU="> 原地</span> ** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = <span class="string">[[1,2,3],[4,5,6],[7,8,9]]</span></span><br><span class="line">输出：<span class="string">[[7,4,1],[8,5,2],[9,6,3]]</span></span><br></pre></td></tr></table></figure><p>题解：就是宏观调度</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="437-路径总和-iii"><a class="anchor" href="#437-路径总和-iii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvcGF0aC1zdW0taWlpLw==">437. 路径总和 III</span></h4><p>难度中等 1325</p><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">10</span>,<span class="number">5</span>,-<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">11</span>,<span class="number">3</span>,-<span class="number">2</span>,<span class="literal">null</span>,<span class="number">1</span>], <span class="attr">targetSum</span> = <span class="number">8</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：和等于 <span class="number">8</span> 的路径有 <span class="number">3</span> 条，如图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">1</span>], <span class="attr">targetSum</span> = <span class="number">22</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,1000]</code></li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><p>深度优先搜索</p><p>我们首先想到的解法是穷举所有的可能，我们访问每一个节点 node，检测以 node 为起始节点且向下延深的路径有多少种。我们递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#先解决以每一个节点为起始节点时，路径和等于目标值的个数，然后遍历所有节点</span></span><br><span class="line">        <span class="comment">#依次求出所有节点为起始节点时的路径数，然后依次加和，就是最终结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">path_sum</span>(<span class="params">root:<span class="type">Optional</span>[TreeNode],target:<span class="built_in">int</span></span>):</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">            <span class="comment">#深度优先遍历</span></span><br><span class="line">            <span class="keyword">if</span> root != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> root.val == target:</span><br><span class="line">                    result+=<span class="number">1</span></span><br><span class="line">                result += path_sum(root.left,target-root.val)</span><br><span class="line">                result += path_sum(root.right,target-root.val)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root:<span class="type">Optional</span>[TreeNode],target:<span class="built_in">int</span></span>):</span><br><span class="line">            result = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root != <span class="literal">None</span>:</span><br><span class="line">                <span class="comment">#先求头结点，然后左右节点</span></span><br><span class="line">                result += path_sum(root,target)</span><br><span class="line">                result += dfs(root.left,target)</span><br><span class="line">                result += dfs(root.right,target)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> dfs(root,targetSum)</span><br></pre></td></tr></table></figure><h4 id="691-贴纸拼词"><a class="anchor" href="#691-贴纸拼词">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdGlja2Vycy10by1zcGVsbC13b3JkLw==">691. 贴纸拼词</span></h4><p>难度困难 137</p><p>我们有 <code>n</code> 种不同的贴纸。每个贴纸上都有一个小写的英文单词。</p><p>您想要拼写出给定的字符串 <code>target</code> ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。</p><p>返回你需要拼出 <code>target</code> 的最小贴纸数量。如果任务不可能，则返回 <code>-1</code> 。</p><p>** 注意：** 在所有的测试用例中，所有的单词都是从 <code>1000</code> 个最常见的美国英语单词中随机选择的，并且 <code>target</code> 被选择为两个随机单词的连接。</p><p><strong>示例 1：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： stickers = [<span class="string">&quot;with&quot;</span>,<span class="string">&quot;example&quot;</span>,<span class="string">&quot;science&quot;</span>], <span class="keyword">target</span> = <span class="string">&quot;thehat&quot;</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">我们可以使用 <span class="number">2</span> 个 <span class="string">&quot;with&quot;</span> 贴纸，和 <span class="number">1</span> 个 <span class="string">&quot;example&quot;</span> 贴纸。</span><br><span class="line">把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。</span><br><span class="line">此外，这是形成目标字符串所需的最小贴纸数量。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：stickers = [<span class="string">&quot;notice&quot;</span>,<span class="string">&quot;possible&quot;</span>], <span class="keyword">target</span> = <span class="string">&quot;basicbasic&quot;</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。</span><br></pre></td></tr></table></figure><p>题解：记忆化搜索 + 状态压缩</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minStickers</span>(<span class="params">self, stickers: <span class="type">List</span>[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(target)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">mask:<span class="built_in">int</span>,res:<span class="built_in">list</span></span>):</span><br><span class="line">            <span class="comment">#说明此时字符串已经分配完毕</span></span><br><span class="line">            <span class="keyword">if</span> mask == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">            result = m+<span class="number">1</span></span><br><span class="line">            <span class="comment">#针对于当前状态，遍历所有贴纸，寻找一个贴纸</span></span><br><span class="line">            <span class="comment">#当前状态去掉与贴纸的最大交集之后的状态最小的那个</span></span><br><span class="line">            <span class="keyword">for</span> sticker <span class="keyword">in</span> stickers:</span><br><span class="line">                left = mask</span><br><span class="line">                cnt = Counter(sticker)</span><br><span class="line">                <span class="comment">#找到该贴纸与当前状态的最大交集剩下的状态</span></span><br><span class="line">                <span class="keyword">for</span> index,item <span class="keyword">in</span> <span class="built_in">enumerate</span>(target):</span><br><span class="line">                    <span class="comment">#如果当前位置的字符存在于当前状态，并且当前位置的字符在sticker中还能找到</span></span><br><span class="line">    </span><br><span class="line">                    <span class="keyword">if</span> left&gt;&gt;index &amp; <span class="number">1</span> <span class="keyword">and</span> cnt[item]:</span><br><span class="line">                        <span class="comment">#更新状态，把当前位置的字符从状态的中去掉</span></span><br><span class="line">                        left ^= <span class="number">1</span>&lt;&lt;index </span><br><span class="line">                        <span class="comment">#并将贴纸中用过的字符去掉</span></span><br><span class="line">                        cnt[item]-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> left&lt;mask:</span><br><span class="line">                    <span class="keyword">if</span> res[left]!=-<span class="number">1</span>:</span><br><span class="line">                        result = <span class="built_in">min</span>(result,res[left]+<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res[left] = dp(left,res)</span><br><span class="line">                        result = <span class="built_in">min</span>(result,res[left]+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res[left] = result</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        res = [-<span class="number">1</span>]*(<span class="number">2</span>**m)</span><br><span class="line">        result =  dp(<span class="number">2</span>**m-<span class="number">1</span>,res)</span><br><span class="line">        <span class="keyword">return</span> result <span class="keyword">if</span> result&lt;=m <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="812-最大三角形面积"><a class="anchor" href="#812-最大三角形面积">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LXRyaWFuZ2xlLWFyZWEv">812. 最大三角形面积</span></h4><p>难度简单 117</p><p>给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: points = <span class="comment">[<span class="comment">[0,0]</span>,<span class="comment">[0,1]</span>,<span class="comment">[1,0]</span>,<span class="comment">[0,2]</span>,<span class="comment">[2,0]</span>]</span></span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">这五个点如下图所示。组成的橙色三角形是最大的，面积为2。</span><br></pre></td></tr></table></figure><p><img data-src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png" alt="img"></p><p><strong>注意:</strong></p><ul><li><code>3 &lt;= points.length &lt;= 50</code> .</li><li>不存在重复的点。</li><li><code>-50 &lt;= points[i][j] &lt;= 50</code> .</li><li>结果误差值在 <code>10^-6</code> 以内都认为是正确答案。</li></ul><p>凸包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    求凸包，因为可以知道最大的三角形的顶点肯定在凸包上，所以就不用所有顶点都遍历一遍，只用遍历凸包上的顶点就可以了</span></span><br><span class="line"><span class="string">    1.每次可以选取凸包上的两个顶点，找到第三个顶点的</span></span><br><span class="line"><span class="string">    2.一点底边的两个顶点确定下来，在凸包上的第三个顶点遍历的过程中，三角形的面积先增大，再减小，所以针对于同一个底边，很容易就能搜索到极值点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getConvexHull</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">cross</span>(<span class="params">p: <span class="type">List</span>[<span class="built_in">int</span>], q: <span class="type">List</span>[<span class="built_in">int</span>], r: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">return</span> (q[<span class="number">0</span>] - p[<span class="number">0</span>]) * (r[<span class="number">1</span>] - q[<span class="number">1</span>]) - (q[<span class="number">1</span>] - p[<span class="number">1</span>]) * (r[<span class="number">0</span>] - q[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按照 x 从小到大排序，如果 x 相同，则按照 y 从小到大排序</span></span><br><span class="line">        points.sort()</span><br><span class="line"></span><br><span class="line">        hull = []</span><br><span class="line">        <span class="comment"># 求凸包的下半部分</span></span><br><span class="line">        <span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(points):</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(hull) &gt; <span class="number">1</span> <span class="keyword">and</span> cross(hull[-<span class="number">2</span>], hull[-<span class="number">1</span>], p) &lt;= <span class="number">0</span>:</span><br><span class="line">                hull.pop()</span><br><span class="line">            hull.append(p)</span><br><span class="line">        <span class="comment"># 求凸包的上半部分</span></span><br><span class="line">        m = <span class="built_in">len</span>(hull)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(hull) &gt; m <span class="keyword">and</span> cross(hull[-<span class="number">2</span>], hull[-<span class="number">1</span>], points[i]) &lt;= <span class="number">0</span>:</span><br><span class="line">                hull.pop()</span><br><span class="line">            hull.append(points[i])</span><br><span class="line">        hull.pop()  <span class="comment"># hull[0] 同时参与凸包的上半部分检测，因此需去掉重复的 hull[0]</span></span><br><span class="line">        <span class="keyword">return</span> hull</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestTriangleArea</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">triangleArea</span>(<span class="params">x1: <span class="built_in">int</span>, y1: <span class="built_in">int</span>, x2: <span class="built_in">int</span>, y2: <span class="built_in">int</span>, x3: <span class="built_in">int</span>, y3: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        convexHull = <span class="variable language_">self</span>.getConvexHull(points)</span><br><span class="line">        ans, n = <span class="number">0</span>, <span class="built_in">len</span>(convexHull)</span><br><span class="line">        <span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(convexHull):</span><br><span class="line">            k = i + <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">                q = convexHull[j]</span><br><span class="line">                <span class="keyword">while</span> k + <span class="number">1</span> &lt; n:</span><br><span class="line">                    curArea = triangleArea(p[<span class="number">0</span>], p[<span class="number">1</span>], q[<span class="number">0</span>], q[<span class="number">1</span>], convexHull[k][<span class="number">0</span>], convexHull[k][<span class="number">1</span>])</span><br><span class="line">                    nextArea = triangleArea(p[<span class="number">0</span>], p[<span class="number">1</span>], q[<span class="number">0</span>], q[<span class="number">1</span>], convexHull[k + <span class="number">1</span>][<span class="number">0</span>], convexHull[k + <span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">if</span> curArea &gt;= nextArea:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, triangleArea(p[<span class="number">0</span>], p[<span class="number">1</span>], q[<span class="number">0</span>], q[<span class="number">1</span>], convexHull[k][<span class="number">0</span>], convexHull[k][<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="813-最大平均值和的分组"><a class="anchor" href="#813-最大平均值和的分组">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sYXJnZXN0LXN1bS1vZi1hdmVyYWdlcy8=">813. 最大平均值和的分组</span></h4><p>难度中等 218</p><p>给定数组 <code>nums</code> 和一个整数 <code>k</code> 。我们将给定的数组 <code>nums</code> 分成 <strong>最多</strong> <code>k</code> 个相邻的非空子数组 。 <strong>分数</strong> 由每个子数组内的平均值的总和构成。</p><p>注意我们必须使用 <code>nums</code> 数组中的每一个数进行分组，并且分数不一定需要是整数。</p><p>返回我们所能得到的最大 <strong>分数</strong> 是多少。答案误差在 <code>10-6</code> 内被视为是正确的。</p><p><strong>示例 1:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>], k = <span class="number">3</span></span><br><span class="line">输出: <span class="number">20.00000</span></span><br><span class="line">解释: </span><br><span class="line">nums 的最优分组是[<span class="number">9</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">9</span>]. 得到的分数是 <span class="number">9</span> + (<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>) / <span class="number">3</span> + <span class="number">9</span> = <span class="number">20.</span> </span><br><span class="line">我们也可以把 nums 分成[<span class="number">9</span>, <span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>, <span class="number">9</span>]. </span><br><span class="line">这样的分组得到的分数为 <span class="number">5</span> + <span class="number">2</span> + <span class="number">6</span> = <span class="number">13</span>, 但不是最大值.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [<span class="number">1,2,3,4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">4</span></span><br><span class="line">输出: <span class="number">20.50000</span></span><br></pre></td></tr></table></figure><p>动态规划：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestSumOfAverages</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="comment">#动态规划</span></span><br><span class="line">        <span class="comment">#计算平均值</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">avg</span>(<span class="params">nums:<span class="built_in">list</span>,start:<span class="built_in">int</span>,end:<span class="built_in">int</span></span>):</span><br><span class="line">            sum_t = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,end+<span class="number">1</span>):</span><br><span class="line">                sum_t += nums[i]</span><br><span class="line">            <span class="keyword">return</span> sum_t/(end-start+<span class="number">1</span>)</span><br><span class="line">        result  = [[<span class="number">0</span>]*(k+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span>  j == <span class="number">1</span>:</span><br><span class="line">                    result[i][j] = avg(nums,<span class="number">0</span>,i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    t = <span class="number">0</span> </span><br><span class="line">                    <span class="keyword">while</span> t &lt; i:</span><br><span class="line">                        result[i][j] = <span class="built_in">max</span>(result[i][j],result[t][j-<span class="number">1</span>]+avg(nums,t+<span class="number">1</span>,i))</span><br><span class="line">                        t+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result[-<span class="number">1</span>][k]</span><br></pre></td></tr></table></figure><h4 id="668-乘法表中第k小的数"><a class="anchor" href="#668-乘法表中第k小的数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rdGgtc21hbGxlc3QtbnVtYmVyLWluLW11bHRpcGxpY2F0aW9uLXRhYmxlLw==">668. 乘法表中第 k 小的数</span></h4><p>难度困难 252</p><p>几乎每一个人都用 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjklOTglRTYlQjMlOTUlRTglQTElQTg=">乘法表</span>。但是你能在乘法表中快速找到第 <code>k</code> 小的数字吗？</p><p>给定高度 <code>m</code> 、宽度 <code>n</code> 的一张 <code>m * n</code> 的乘法表，以及正整数 <code>k</code> ，你需要返回表中第 <code>k</code> 小的数字。</p><p><strong>例 1：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: m = 3, n = 3, k = 5</span></span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: </span></span><br><span class="line"><span class="section">乘法表:</span></span><br><span class="line">1	2	3</span><br><span class="line">2	4	6</span><br><span class="line">3	6	9</span><br><span class="line"></span><br><span class="line">第5小的数字是 3 (1, 2, 2, 3, 3).</span><br></pre></td></tr></table></figure><p><strong>例 2：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: m = 2, n = 3, k = 6</span></span><br><span class="line"><span class="section">输出: 6</span></span><br><span class="line"><span class="section">解释: </span></span><br><span class="line"><span class="section">乘法表:</span></span><br><span class="line">1	2	3</span><br><span class="line">2	4	6</span><br><span class="line"></span><br><span class="line">第6小的数字是 6 (1, 2, 2, 3, 4, 6).</span><br></pre></td></tr></table></figure><p><img data-src="https://github.com/zhihao-a/blog-img%5Cimage-20220518150230230.png" alt="image-20220518150230230"></p><h4 id="464-我能赢吗"><a class="anchor" href="#464-我能赢吗">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW4taS13aW4v">464. 我能赢吗</span></h4><p>难度中等 341</p><p>在 “100 game” 这个游戏中，两名玩家轮流选择从 <code>1</code> 到 <code>10</code> 的任意整数，累计整数和，先使得累计整数和 <strong>达到或超过</strong> 100 的玩家，即为胜者。</p><p>如果我们将游戏规则改为 “玩家 <strong>不能</strong> 重复使用整数” 呢？</p><p>例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。</p><p>给定两个整数 <code>maxChoosableInteger</code> （整数池中可选择的最大数）和 <code>desiredTotal</code> （累计和），若先出手的玩家是否能稳赢则返回 <code>true</code> ，否则返回 <code>false</code> 。假设两位玩家游戏时都表现 <strong>最佳</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：maxChoosableInteger = 10, desiredTotal = 11</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">无论第一个玩家选择哪个整数，他都会失败。</span><br><span class="line">第一个玩家可以选择从<span class="number"> 1 </span>到<span class="number"> 10 </span>的整数。</span><br><span class="line">如果第一个玩家选择 1，那么第二个玩家只能选择从<span class="number"> 2 </span>到<span class="number"> 10 </span>的整数。</span><br><span class="line">第二个玩家可以通过选择整数 10（那么累积和为<span class="number"> 11 </span>&gt;= desiredTotal），从而取得胜利.</span><br><span class="line">同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">maxChoosableInteger</span> = <span class="number">10</span>, <span class="attr">desiredTotal</span> = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">maxChoosableInteger</span> = <span class="number">10</span>, <span class="attr">desiredTotal</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= maxChoosableInteger &lt;= 20</code></li><li><code>0 &lt;= desiredTotal &lt;= 300</code></li></ul><p>题解：</p><p>边界情况，当所有数字选完仍无法到达 desiredTotal 时，两个人都无法获胜，返回 False，当所有数字的和大于等于 desiredTotal 时，其中一方能获得胜利</p><p>在某方行动时，可以有以下举措</p><p>​ ① 遍历当前剩余数字， 如果能在剩余的的数中，找到一个能使当前累加和达到题目要求，就直接返回 True</p><p>​ ② 如果① 不能满足，就找一个数，使得对方在去掉这个数的下一个状态不能获胜，也可以宣布自己获胜</p><p>如果两种方案都没有可行的，就直接宣布自己不可能获胜</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canIWin</span>(<span class="params">self, maxChoosableInteger: <span class="built_in">int</span>, desiredTotal: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line"><span class="meta">        @cache</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">usedNumbers: <span class="built_in">int</span>, currentTotal: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxChoosableInteger):</span><br><span class="line">                <span class="keyword">if</span> (usedNumbers &gt;&gt; i) &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> currentTotal + i + <span class="number">1</span> &gt;= desiredTotal <span class="keyword">or</span> <span class="keyword">not</span> dfs(usedNumbers | (<span class="number">1</span> &lt;&lt; i), currentTotal + i + <span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> + maxChoosableInteger) * maxChoosableInteger // <span class="number">2</span> &gt;= desiredTotal <span class="keyword">and</span> dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="675-为高尔夫比赛砍树"><a class="anchor" href="#675-为高尔夫比赛砍树">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jdXQtb2ZmLXRyZWVzLWZvci1nb2xmLWV2ZW50Lw==">675. 为高尔夫比赛砍树</span></h4><p>难度困难 121</p><p>你被请来给一个要举办高尔夫比赛的树林砍树。树林由一个 <code>m x n</code> 的矩阵表示， 在这个矩阵中：</p><ul><li><code>0</code> 表示障碍，无法触碰</li><li><code>1</code> 表示地面，可以行走</li><li><code>比 1 大的数</code> 表示有树的单元格，可以行走，数值表示树的高度</li></ul><p>每一步，你都可以向上、下、左、右四个方向之一移动一个单位，如果你站的地方有一棵树，那么你可以决定是否要砍倒它。</p><p>你需要按照树的高度从低向高砍掉所有的树，每砍过一颗树，该单元格的值变为 <code>1</code> （即变为地面）。</p><p>你将从 <code>(0, 0)</code> 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 <code>-1</code> 。</p><p>可以保证的是，没有两棵树的高度是相同的，并且你至少需要砍倒一棵树。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：forest = <span class="string">[[1,2,3],[0,0,4],[7,6,5]]</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：沿着上面的路径，你可以用 <span class="number">6</span> 步，按从最矮到最高的顺序砍掉这些树。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg" alt="img"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：forest = <span class="string">[[1,2,3],[0,0,0],[7,6,5]]</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：由于中间一行被障碍阻塞，无法访问最下面一行中的树。</span><br></pre></td></tr></table></figure><p>题目要求从 (0, 0) 开始并按照树的高度大小进行砍树并求出最小步数，假设所有树按照从高度从小到大的排序顺序为 t,t,t3,t,. ,tn，设 d (x,y) 表示从 x 到 y 之间的步数，设 to= (0,0) , 则可推出砍树的总的步数为 total = 求和 d (t,ti+ 1)，若使得 total 最小，只需满足所有的 d (i,i + 1) 都为最小，即可使得 total 最小，该题即转为求相邻树的两点之间的最短距离。</p><p>题解：广度优先搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cutOffTree</span>(<span class="params">self, forest: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">#广度优先搜索</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">start_x:<span class="built_in">int</span>,start_y:<span class="built_in">int</span>,end_x:<span class="built_in">int</span>,end_y</span>):</span><br><span class="line">            m,n = <span class="built_in">len</span>(forest),<span class="built_in">len</span>(forest[<span class="number">0</span>])</span><br><span class="line">            que = deque()</span><br><span class="line">            que.append((start_x,start_y,<span class="number">0</span>))</span><br><span class="line">            vis = &#123;(start_x,start_y)&#125;</span><br><span class="line">            <span class="keyword">while</span> que:</span><br><span class="line">                con_x , con_y , step = que.popleft()</span><br><span class="line">                <span class="keyword">if</span> con_x == end_x <span class="keyword">and</span> con_y == end_y:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">                <span class="keyword">for</span> x,y <span class="keyword">in</span> ((con_x,con_y-<span class="number">1</span>),(con_x,con_y+<span class="number">1</span>),(con_x+<span class="number">1</span>,con_y),(con_x-<span class="number">1</span>,con_y)):</span><br><span class="line">                    <span class="comment">#如果该点不是障碍，并且没被访问过，就访问该点</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; n <span class="keyword">and</span> forest[x][y] <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> vis:</span><br><span class="line">                        vis.add((x,y))</span><br><span class="line">                        que.append((x,y,step+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">#1.先将该树林中的树按照高度从低到高进行排列</span></span><br><span class="line">        data = []</span><br><span class="line">        m ,n  = <span class="built_in">len</span>(forest),<span class="built_in">len</span>(forest[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> forest[i][j]&gt;<span class="number">1</span>:</span><br><span class="line">                    data.append([i,j,forest[i][j]])</span><br><span class="line">        data.sort(key = <span class="keyword">lambda</span> x :x[<span class="number">2</span>])</span><br><span class="line">        <span class="comment">#2.然后求解每两个相邻的树之间的最小路径长度，这样加和起来就是最小路径长度</span></span><br><span class="line">        start_x,start_y = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x,y,_ <span class="keyword">in</span> data:</span><br><span class="line">            d = bfs(start_x,start_y,x,y)</span><br><span class="line">            <span class="keyword">if</span> d &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            result += d</span><br><span class="line">            start_x ,start_y = x,y</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="1022-从根到叶的二进制数之和"><a class="anchor" href="#1022-从根到叶的二进制数之和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdW0tb2Ytcm9vdC10by1sZWFmLWJpbmFyeS1udW1iZXJzLw==">1022. 从根到叶的二进制数之和</span></h4><p>难度简单 156</p><p>给出一棵二叉树，其上每个结点的值都是 <code>0</code> 或 <code>1</code> 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。</p><ul><li>例如，如果路径为 <code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code> ，那么它表示二进制数 <code>01101</code> ，也就是 <code>13</code> 。</li></ul><p>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。</p><p>返回这些数字之和。题目数据保证答案是一个 <strong>32 位</strong> 整数。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png" alt="img"></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：<span class="comment">(100)</span> + <span class="comment">(101)</span> + <span class="comment">(110)</span> + <span class="comment">(111)</span> = <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> = <span class="number">22</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root <span class="operator">=</span> [<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数在 <code>[1, 1000]</code> 范围内</li><li><code>Node.val</code> 仅为 <code>0</code> 或 <code>1</code></li></ul><p>题解一：后序遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRootToLeaf</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            val = (val &lt;&lt; <span class="number">1</span>) | node.val</span><br><span class="line">            <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> val</span><br><span class="line">            <span class="keyword">return</span> dfs(node.left, val) + dfs(node.right, val)</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>题解二：中序遍历 + 回退 + 栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRootToLeaf</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = val = <span class="number">0</span></span><br><span class="line">        st = []</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> st:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                val = (val &lt;&lt; <span class="number">1</span>) | root.val</span><br><span class="line">                st.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = st[-<span class="number">1</span>]</span><br><span class="line">            <span class="comment">#回退的几种可能情况</span></span><br><span class="line">            <span class="comment">#1.当前节点已经是叶子节点的时候，要先记录一个结果，然后在进行回退</span></span><br><span class="line">            <span class="comment">#2.当前节点的右子树已经遍历过了，因为中序遍历是左根右的顺序，所以该节点已经遍历完成，回退        </span></span><br><span class="line">            <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root.right == pre:</span><br><span class="line">                <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    ans += val</span><br><span class="line">                val &gt;&gt;= <span class="number">1</span></span><br><span class="line">                st.pop()</span><br><span class="line">                pre = root</span><br><span class="line">                root = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-114-外星文字典"><a class="anchor" href="#剑指-offer-ii-114-外星文字典">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9KZjFKdVQv">剑指 Offer II 114. 外星文字典</span></h4><p>难度困难 45</p><p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p><p>给定一个字符串列表 <code>words</code> ，作为这门语言的词典， <code>words</code> 中的字符串已经 <strong>按这门新语言的字母顺序进行了排序</strong> 。</p><p>请你根据该词典还原出此语言中已知的字母顺序，并 <strong>按字母递增顺序</strong> 排列。若不存在合法字母顺序，返回 <code>&quot;&quot;</code> 。若存在多种可能的合法字母顺序，返回其中 <strong>任意一种</strong> 顺序即可。</p><p>字符串 <code>s</code> <strong>字典顺序小于</strong> 字符串 <code>t</code> 有两种情况：</p><ul><li>在第一个不同字母处，如果 <code>s</code> 中的字母在这门外星语言的字母顺序中位于 <code>t</code> 中字母之前，那么 <code>s</code> 的字典顺序小于 <code>t</code> 。</li><li>如果前面 <code>min(s.length, t.length)</code> 字母都相同，那么 <code>s.length &lt; t.length</code> 时， <code>s</code> 的字典顺序也小于 <code>t</code> 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">words</span> = [<span class="string">&quot;wrt&quot;</span>,<span class="string">&quot;wrf&quot;</span>,<span class="string">&quot;er&quot;</span>,<span class="string">&quot;ett&quot;</span>,<span class="string">&quot;rftt&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;wertf&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">words</span> = [<span class="string">&quot;z&quot;</span>,<span class="string">&quot;x&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;zx&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">words</span> = [<span class="string">&quot;z&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;z&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br><span class="line">解释：不存在合法字母顺序，因此返回 <span class="string">&quot;&quot;</span> 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 100</code></li><li><code>words[i]</code> 仅由小写英文字母组成</li></ul><p>拓扑排序 + 深度优先搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">alienOrder</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        g = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> words[<span class="number">0</span>]:</span><br><span class="line">            g[c] = []</span><br><span class="line">        <span class="keyword">for</span> s, t <span class="keyword">in</span> pairwise(words):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">                g.setdefault(c, [])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> u, v <span class="keyword">in</span> <span class="built_in">zip</span>(s, t):</span><br><span class="line">                <span class="keyword">if</span> u != v:</span><br><span class="line">                    g[u].append(v)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="built_in">len</span>(t):</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        VISITING, VISITED = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        states = &#123;&#125;</span><br><span class="line">        order = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">u: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            states[u] = VISITING</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> g[u]:</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> states:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> dfs(v):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">elif</span> states[v] == VISITING:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            order.append(u)</span><br><span class="line">            states[u] = VISITED</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">reversed</span>(order)) <span class="keyword">if</span> <span class="built_in">all</span>(dfs(u) <span class="keyword">for</span> u <span class="keyword">in</span> g <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> states) <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>拓扑排序 + 广度优先搜索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">alienOrder</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        g = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        inDeg = &#123;c: <span class="number">0</span> <span class="keyword">for</span> c <span class="keyword">in</span> words[<span class="number">0</span>]&#125;</span><br><span class="line">        <span class="keyword">for</span> s, t <span class="keyword">in</span> pairwise(words):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">                inDeg.setdefault(c, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> u, v <span class="keyword">in</span> <span class="built_in">zip</span>(s, t):</span><br><span class="line">                <span class="keyword">if</span> u != v:</span><br><span class="line">                    g[u].append(v)</span><br><span class="line">                    inDeg[v] += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="built_in">len</span>(t):</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        q = [u <span class="keyword">for</span> u, d <span class="keyword">in</span> inDeg.items() <span class="keyword">if</span> d == <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> g[u]:</span><br><span class="line">                inDeg[v] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inDeg[v] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(q) <span class="keyword">if</span> <span class="built_in">len</span>(q) == <span class="built_in">len</span>(inDeg) <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="450-删除二叉搜索树中的节点"><a class="anchor" href="#450-删除二叉搜索树中的节点">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZS1pbi1hLWJzdC8=">450. 删除二叉搜索树中的节点</span></h4><p>难度中等 788</p><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例 1:</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img"></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>], <span class="built_in">key</span> = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>]</span><br><span class="line">解释：给定需要删除的节点值是 <span class="number">3</span>，所以我们首先找到 <span class="number">3</span> 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>], 如下图所示。</span><br><span class="line">另一个正确答案是 [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">7</span>]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: root = [5,3,6,2,4,null,7], key = 0</span></span><br><span class="line"><span class="section">输出: [5,3,6,2,4,null,7]</span></span><br><span class="line"><span class="section">解释: 二叉树不包含值为 0 的节点</span></span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = <span class="comment">[]</span>, key = 0</span><br><span class="line">输出: <span class="comment">[]</span></span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code> .</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], key: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 方法一迭代寻找</span></span><br><span class="line">        <span class="comment"># def search(root:Optional[TreeNode],key:int):</span></span><br><span class="line">        <span class="comment">#     if root!=None:</span></span><br><span class="line">        <span class="comment">#         if root.val &gt; key:</span></span><br><span class="line">        <span class="comment">#             return search(root.left,key)</span></span><br><span class="line">        <span class="comment">#         elif root.val &lt; key:</span></span><br><span class="line">        <span class="comment">#             return search(root.right,key)</span></span><br><span class="line">        <span class="comment">#         else:</span></span><br><span class="line">        <span class="comment">#             return root</span></span><br><span class="line">        <span class="comment">#     return None</span></span><br><span class="line">        <span class="comment"># target = search(root,key)</span></span><br><span class="line">        <span class="comment"># if not target:</span></span><br><span class="line">        <span class="comment">#     return root</span></span><br><span class="line">        <span class="comment"># if not target.left and not target.right:</span></span><br><span class="line">        <span class="comment">#     if target == root:</span></span><br><span class="line">        <span class="comment">#         return None</span></span><br><span class="line">        <span class="comment">#     target = None</span></span><br><span class="line">        <span class="comment"># elif target.right and not target.left:</span></span><br><span class="line">        <span class="comment">#     target.val = target.right.val</span></span><br><span class="line">        <span class="comment">#     target.left = target.right.left</span></span><br><span class="line">        <span class="comment">#     target.right = target.right.right</span></span><br><span class="line">        <span class="comment"># elif target.left and not target.right:</span></span><br><span class="line">        <span class="comment">#     target.val = target.left.val</span></span><br><span class="line">        <span class="comment">#     target.left = target.left.left</span></span><br><span class="line">        <span class="comment">#     target.right = target.left.right</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     pre = target</span></span><br><span class="line">        <span class="comment">#     p = target.right</span></span><br><span class="line">        <span class="comment">#     while p.left:</span></span><br><span class="line">        <span class="comment">#         pre = p</span></span><br><span class="line">        <span class="comment">#         p = p.left</span></span><br><span class="line">        <span class="comment">#     target.val = p.val</span></span><br><span class="line">        <span class="comment">#     if pre == target:</span></span><br><span class="line">        <span class="comment">#         pre.right = p.right</span></span><br><span class="line">        <span class="comment">#     else:</span></span><br><span class="line">        <span class="comment">#         pre.left = p.right</span></span><br><span class="line">        <span class="comment"># return root</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 方法二（题解）</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        大致思路就是递归，不断地寻找以root(函数迭代过程中的根节点)为根节点，删除指定元素，返回的树</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key:</span><br><span class="line">            root.left = <span class="variable language_">self</span>.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; key:</span><br><span class="line">            root.right = <span class="variable language_">self</span>.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">elif</span> root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            root = root.left <span class="keyword">if</span> root.left <span class="keyword">else</span> root.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            successor = root.right</span><br><span class="line">            <span class="keyword">while</span> successor.left:</span><br><span class="line">                successor = successor.left</span><br><span class="line">            successor.right = <span class="variable language_">self</span>.deleteNode(root.right, successor.val)</span><br><span class="line">            successor.left = root.left</span><br><span class="line">            <span class="keyword">return</span> successor</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="875-爱吃香蕉的珂珂"><a class="anchor" href="#875-爱吃香蕉的珂珂">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rb2tvLWVhdGluZy1iYW5hbmFzLw==">875. 爱吃香蕉的珂珂</span></h4><p>难度中等 319</p><p>珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 <code>k</code> （单位：根 / 小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。</p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code> （ <code>k</code> 为整数）。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">3,6,7,11</span>], h = <span class="number">8</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = <span class="string">[30,11,23,4,20]</span>, h = <span class="number">5</span></span><br><span class="line">输出：<span class="number">30</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = <span class="string">[30,11,23,4,20]</span>, h = <span class="number">6</span></span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= piles.length &lt;= 104</code></li><li><code>piles.length &lt;= h &lt;= 109</code></li><li><code>1 &lt;= piles[i] &lt;= 109</code></li></ul><p>二分查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">如果珂珂在 hh 小时内吃掉所有香蕉的最小速度是每小时 kk 个香蕉，则当吃香蕉的速度大于每小时 kk 个香蕉时一定可以在 hh 小时内吃掉所有香蕉，当吃香蕉的速度小于每小时 kk 个香蕉时一定不能在 hh 小时内吃掉所有香蕉。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">由于吃香蕉的速度和是否可以在规定时间内吃掉所有香蕉之间存在单调性，因此可以使用二分查找的方法得到最小速度 kk。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">由于每小时都要吃香蕉，即每小时至少吃 11 个香蕉，因此二分查找的下界是 11；由于每小时最多吃一堆香蕉，即每小时吃的香蕉数目不会超过最多的一堆中的香蕉数目，因此二分查找的上界是最多的一堆中的香蕉数目。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minEatingSpeed</span>(<span class="params">self, piles: <span class="type">List</span>[<span class="built_in">int</span>], h: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        max_num = <span class="built_in">max</span>(piles)</span><br><span class="line">        left,right = <span class="number">1</span>,max_num</span><br><span class="line">        time = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = left  + (right-left)//<span class="number">2</span></span><br><span class="line">            time = <span class="built_in">sum</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x//mid + <span class="number">1</span> <span class="keyword">if</span> x%mid!=<span class="number">0</span> <span class="keyword">else</span> x/mid,piles)))</span><br><span class="line">            <span class="keyword">if</span> time &lt;= h:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="926-将字符串翻转到单调递增"><a class="anchor" href="#926-将字符串翻转到单调递增">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mbGlwLXN0cmluZy10by1tb25vdG9uZS1pbmNyZWFzaW5nLw==">926. 将字符串翻转到单调递增</span></h4><p>难度中等 168</p><p>如果一个二进制字符串，是以一些 <code>0</code> （可能没有 <code>0</code> ）后面跟着一些 <code>1</code> （也可能没有 <code>1</code> ）的形式组成的，那么该字符串是 <strong>单调递增</strong> 的。</p><p>给你一个二进制字符串 <code>s</code> ，你可以将任何 <code>0</code> 翻转为 <code>1</code> 或者将 <code>1</code> 翻转为 <code>0</code> 。</p><p>返回使 <code>s</code> 单调递增的最小翻转次数。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;00110&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：翻转最后一位得到 <span class="number">00111</span>.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;010110&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：翻转得到 <span class="number">011111</span>，或者是 <span class="number">000111</span>。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;00011000&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：翻转得到 <span class="number">00000000</span>。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 为 <code>'0'</code> 或 <code>'1'</code></li></ul><p>预处理 + 动态规划</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minFlipsMonoIncr</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        统计一下每个位置左边的1的个数和右边0的个数</span></span><br><span class="line"><span class="string">        相加就是以该位置为分界线上的0或者1，整个数组需要的翻转次数</span></span><br><span class="line"><span class="string">        然后遍历求得最小的翻转次数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        num1 = [<span class="number">0</span>]*length</span><br><span class="line">        num0 = [<span class="number">0</span>]*length</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">            num1[i] = num1[i-<span class="number">1</span>] + <span class="number">1</span> <span class="keyword">if</span> s[i-<span class="number">1</span>]==<span class="string">&quot;1&quot;</span>  <span class="keyword">else</span> num1[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            num0[i] = num0[i+<span class="number">1</span>] + <span class="number">1</span> <span class="keyword">if</span> s[i+<span class="number">1</span>]==<span class="string">&quot;0&quot;</span>  <span class="keyword">else</span> num0[i+<span class="number">1</span>]</span><br><span class="line">        result = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            result = <span class="built_in">min</span>(result,num1[i]+num0[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="498-对角线遍历"><a class="anchor" href="#498-对角线遍历">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaWFnb25hbC10cmF2ZXJzZS8=">498. 对角线遍历</span></h4><p>难度中等 314</p><p>给你一个大小为 <code>m x n</code> 的矩阵 <code>mat</code> ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = <span class="comment">[<span class="comment">[1,2,3]</span>,<span class="comment">[4,5,6]</span>,<span class="comment">[7,8,9]</span>]</span></span><br><span class="line">输出：<span class="comment">[1,2,4,7,5,3,6,8,9]</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = <span class="string">[[1,2],[3,4]]</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>1 &lt;= m, n &lt;= 104</code></li><li><code>1 &lt;= m * n &lt;= 104</code></li><li><code>-105 &lt;= mat[i][j] &lt;= 105</code></li></ul><p>题解：宏观调度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDiagonalOrder</span>(<span class="params">self, mat: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:  </span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment">#打印函数</span></span><br><span class="line">         <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">           每次只用关心两个对角点的连线怎么打印就好了</span></span><br><span class="line"><span class="string">         &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">Print</span>(<span class="params">right_row:<span class="built_in">int</span>,right_col:<span class="built_in">int</span>,left_row:<span class="built_in">int</span>,left_col:<span class="built_in">int</span>,f:<span class="built_in">bool</span></span>):</span><br><span class="line">            <span class="keyword">if</span> f:</span><br><span class="line">                <span class="keyword">while</span> left_row &gt; right_row - <span class="number">1</span>:</span><br><span class="line">                    result.append(mat[left_row][left_col])</span><br><span class="line">                    left_row -= <span class="number">1</span></span><br><span class="line">                    left_col += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> right_row &lt; left_row + <span class="number">1</span>:</span><br><span class="line">                    result.append(mat[right_row][right_col])</span><br><span class="line">                    right_row += <span class="number">1</span></span><br><span class="line">                    right_col -= <span class="number">1</span></span><br><span class="line">        m = <span class="built_in">len</span>(mat)</span><br><span class="line">        n = <span class="built_in">len</span>(mat[<span class="number">0</span>])</span><br><span class="line">        left_row,left_col,right_row,right_col = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        f = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">while</span> left_row &gt;= right_row:</span><br><span class="line">            Print(right_row,right_col,left_row,left_col,f)</span><br><span class="line">            <span class="comment">#移动两个对角点左边的点首先选择向下移动，再向右移动</span></span><br><span class="line">            <span class="comment">#右上角的点首先选择向右移动，然后移动右边界之后，再向下移动</span></span><br><span class="line">            left_col = left_col <span class="keyword">if</span> left_row &lt; m - <span class="number">1</span> <span class="keyword">else</span> left_col + <span class="number">1</span></span><br><span class="line">            left_row = left_row + <span class="number">1</span> <span class="keyword">if</span> left_row &lt; m - <span class="number">1</span> <span class="keyword">else</span> left_row</span><br><span class="line">            right_row = right_row <span class="keyword">if</span> right_col &lt; n - <span class="number">1</span> <span class="keyword">else</span> right_row + <span class="number">1</span></span><br><span class="line">            right_col = right_col + <span class="number">1</span> <span class="keyword">if</span> right_col &lt; n - <span class="number">1</span> <span class="keyword">else</span> right_col</span><br><span class="line">            f = <span class="keyword">not</span> f</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">                    </span><br></pre></td></tr></table></figure><h4 id="2368-受限条件下可到达节点的数目"><a class="anchor" href="#2368-受限条件下可到达节点的数目">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWFjaGFibGUtbm9kZXMtd2l0aC1yZXN0cmljdGlvbnMv">2368. 受限条件下可到达节点的数目</span></h4><p>现有一棵由 <code>n</code> 个节点组成的无向树，节点编号从 <code>0</code> 到 <code>n - 1</code> ，共有 <code>n - 1</code> 条边。</p><p>给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条边。另给你一个整数数组 <code>restricted</code> 表示 <strong>受限</strong> 节点。</p><p>在不访问受限节点的前提下，返回你可以从节点 <code>0</code> 到达的 <strong>最多</strong> 节点数目 *。*</p><p>注意，节点 <code>0</code> <strong>不</strong> 会标记为受限节点。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png" alt="img"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 7, edges = <span class="comment">[<span class="comment">[0,1]</span>,<span class="comment">[1,2]</span>,<span class="comment">[3,1]</span>,<span class="comment">[4,0]</span>,<span class="comment">[0,5]</span>,<span class="comment">[5,6]</span>]</span>, restricted = <span class="comment">[4,5]</span></span><br><span class="line">输出：4</span><br><span class="line">解释：上图所示正是这棵树。</span><br><span class="line">在不访问受限节点的前提下，只有节点 <span class="comment">[0,1,2,3]</span> 可以从节点 0 到达。</span><br></pre></td></tr></table></figure><p>方法：深度优先搜索（dfs）</p><p>大致思路：首先将给到的边的信息，转化并保存成便于处理的形式 A [i] = [ a,b,c] ，(某个节点的后续节点的形式)，然后通过深度优先搜索（或者是广度优先搜索 bfs），进行遍历，通过跳过受限节点的形式，记录能够遍历得到的节点的个数，即（从 0 节点开始能够到达的节点的个数）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">reachableNodes</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; restricted)</span> </span>&#123; </span><br><span class="line">       <span class="comment">// 重新构造一个受限点的列表，便于查找，因为isrestricted[i]==1 就表示i点为受限点</span></span><br><span class="line">       <span class="comment">// 这样构造更容易查找</span></span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">isrestricted</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : restricted) &#123;</span><br><span class="line">            isrestricted[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">g</span>(n);</span><br><span class="line">        <span class="comment">// 因为是无向树，所以就是存成无向图的形式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : edges) &#123;</span><br><span class="line">            g[v[<span class="number">0</span>]].<span class="built_in">push_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">            g[v[<span class="number">1</span>]].<span class="built_in">push_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x, <span class="type">int</span> f) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;y : g[x]) &#123;</span><br><span class="line">                <span class="comment">// y!=f 保证不转圈</span></span><br><span class="line">                <span class="comment">// !isrestricted[y] 保证该点不是受限点</span></span><br><span class="line">                <span class="keyword">if</span> (y != f &amp;&amp; !isrestricted[y]) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(y, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2575-找出字符串的可整除数组"><a class="anchor" href="#2575-找出字符串的可整除数组">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1kaXZpc2liaWxpdHktYXJyYXktb2YtYS1zdHJpbmcv">2575. 找出字符串的可整除数组</span></h4><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>word</code> ，长度为 <code>n</code> ，由从 <code>0</code> 到 <code>9</code> 的数字组成。另给你一个正整数 <code>m</code> 。</p><p><code>word</code> 的 <strong>可整除数组</strong> <code>div</code> 是一个长度为 <code>n</code> 的整数数组，并满足：</p><ul><li>如果 <code>word[0,...,i]</code> 所表示的 <strong>数值</strong> 能被 <code>m</code> 整除， <code>div[i] = 1</code></li><li>否则， <code>div[i] = 0</code></li></ul><p>返回 <code>word</code> 的可整除数组。</p><p><strong>示例 1：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">&quot;998244353&quot;</span>, m = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：仅有 <span class="number">4</span> 个前缀可以被 <span class="number">3</span> 整除：<span class="string">&quot;9&quot;</span>、<span class="string">&quot;99&quot;</span>、<span class="string">&quot;998244&quot;</span> 和 <span class="string">&quot;9982443&quot;</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">&quot;1010&quot;</span>, m = <span class="number">10</span></span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">解释：仅有 <span class="number">2</span> 个前缀可以被 <span class="number">10</span> 整除：<span class="string">&quot;10&quot;</span> 和 <span class="string">&quot;1010&quot;</span> 。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="comment">// vector&lt;int&gt; divisibilityArray(string word, int m) &#123;</span></span><br><span class="line"><span class="comment">//       int length = word.size();</span></span><br><span class="line"><span class="comment">//       vector&lt;int&gt; dp(length,0);</span></span><br><span class="line"><span class="comment">//       if(int(word[0])%m==0)&#123;</span></span><br><span class="line"><span class="comment">//         dp[0] = 1;</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//       for(int i = 1;i&lt;length;i++)&#123;</span></span><br><span class="line"><span class="comment">//          for(int j = i;j &gt; 0;j--)&#123;</span></span><br><span class="line"><span class="comment">//            int a =  stoi(word.substr(j,i));</span></span><br><span class="line"><span class="comment">//            cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//              if(dp[j-1] &amp;&amp; a%m==0 )&#123;</span></span><br><span class="line"><span class="comment">//                 // cout &lt;&lt; word.substr(0,j-1) &lt;&lt; a &lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//                 dp[i] = 1;</span></span><br><span class="line"><span class="comment">//                 break;</span></span><br><span class="line"><span class="comment">//              &#125;</span></span><br><span class="line"><span class="comment">//          &#125;</span></span><br><span class="line"><span class="comment">//       &#125;</span></span><br><span class="line"><span class="comment">//       return dp;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 根据整数整除的规律 (a*10 + b) mod m  == ((a mod m) *10 + b) mod m</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">divisibilityArray</span><span class="params">(string word, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>&amp; c : word) &#123;</span><br><span class="line">            cur = (cur * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>)) % m;</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      string word = <span class="string">&quot;998244353&quot;</span>;</span><br><span class="line">      <span class="type">int</span> m = <span class="number">3</span>;</span><br><span class="line">      vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">divisibilityArray</span>(word,m);</span><br><span class="line">      cout &lt;&lt; <span class="built_in">stoi</span>(word.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>)) &lt;&lt; word.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>) &lt;&lt;endl;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;w:result)&#123;</span><br><span class="line">        cout &lt;&lt; w &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2834-找出美丽数组的最小和"><a class="anchor" href="#2834-找出美丽数组的最小和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1taW5pbXVtLXBvc3NpYmxlLXN1bS1vZi1hLWJlYXV0aWZ1bC1hcnJheS8=">2834. 找出美丽数组的最小和</span></h4><p>给你两个正整数： <code>n</code> 和 <code>target</code> 。</p><p>如果数组 <code>nums</code> 满足下述条件，则称其为 <strong>美丽数组</strong> 。</p><ul><li><code>nums.length == n</code> .</li><li><code>nums</code> 由两两互不相同的正整数组成。</li><li>在范围 <code>[0, n-1]</code> 内，<strong>不存在</strong> 两个 <strong>不同</strong> 下标 <code>i</code> 和 <code>j</code> ，使得 <code>nums[i] + nums[j] == target</code> 。</li></ul><p>返回符合条件的美丽数组所可能具备的 <strong>最小</strong> 和，并对结果进行取模 <code>109 + 7</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：nums = <span class="selector-attr">[1,3]</span> 是美丽数组。</span><br><span class="line">- nums 的长度为 n = <span class="number">2</span> 。</span><br><span class="line">- nums 由两两互不相同的正整数组成。</span><br><span class="line">- 不存在两个不同下标 <span class="selector-tag">i</span> 和 j ，使得 nums<span class="selector-attr">[i]</span> + nums<span class="selector-attr">[j]</span> == <span class="number">3</span> 。</span><br><span class="line">可以证明 <span class="number">4</span> 是符合条件的美丽数组所可能具备的最小和。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：</span><br><span class="line">nums = <span class="selector-attr">[1,3,4]</span> 是美丽数组。 </span><br><span class="line">- nums 的长度为 n = <span class="number">3</span> 。 </span><br><span class="line">- nums 由两两互不相同的正整数组成。 </span><br><span class="line">- 不存在两个不同下标 <span class="selector-tag">i</span> 和 j ，使得 nums<span class="selector-attr">[i]</span> + nums<span class="selector-attr">[j]</span> == <span class="number">3</span> 。</span><br><span class="line">可以证明 <span class="number">8</span> 是符合条件的美丽数组所可能具备的最小和。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, <span class="keyword">target</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：nums = [<span class="number">1</span>] 是美丽数组。</span><br></pre></td></tr></table></figure><p>思路：贪心思想，目标是找到的美丽数组之和最小，所以从最小的数 1, 开始寻找，直到找到 n 个，这样找到的数组之和肯定是最小的，但是为了满足 nums [i] + nums [j] != target (任意 i!=j) 所以 [0,target] 范围内，只能找 [1,2,3,…target//2]，因为 1 + target -1 == target 、 2 + target -2 == target， … 由于对称相加等于 target 所以只能取 target//2 以左（因为要达到最小），如果还不够 n 个，就从 target 、target + 1、… 往后取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minimumPossibleSum</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    思路：贪心思想，目标是找到的美丽数组之和最小，所以从最小的数1,</span></span><br><span class="line"><span class="comment">    开始寻找，直到找到n个，这样找到的数组之和肯定是最小的</span></span><br><span class="line"><span class="comment">    但是为了满足 nums[i] + nums[j] != target (任意i!=j)</span></span><br><span class="line"><span class="comment">    所以[0,target] 范围内，只能找[1,2,3,.....target//2]</span></span><br><span class="line"><span class="comment">    因为  1 + target -1 == target 、 2 + target -2 == target</span></span><br><span class="line"><span class="comment">    ....   由于对称相加等于target 所以只能取 target//2 以左（因为要达到最小）</span></span><br><span class="line"><span class="comment">    如果还不够 n 个，就从target 、target + 1、.... 往后取  </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">     <span class="type">int</span> k = target/<span class="number">2</span>;</span><br><span class="line">     <span class="type">int</span> mod = <span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">     <span class="keyword">if</span>(k&gt;= n)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">long</span> <span class="type">long</span>)(<span class="number">1</span> + n)*n/<span class="number">2</span> % mod;   <span class="comment">// 等差数列求和</span></span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">return</span> ((<span class="type">long</span> <span class="type">long</span>)(k + <span class="number">1</span>)*k/<span class="number">2</span> + ((<span class="type">long</span> <span class="type">long</span>)target + n - k - <span class="number">1</span> + target)*(n - k)/<span class="number">2</span> ) % mod;  <span class="comment">// 两个等差数列求和</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">minimumPossibleSum</span>(<span class="number">1000000000</span>,<span class="number">1000000000</span>) &lt;&lt;endl; <span class="comment">// 750000042</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="299-猜数字游戏"><a class="anchor" href="#299-猜数字游戏">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idWxscy1hbmQtY293cy8=">299. 猜数字游戏</span></h4><p>你在和朋友一起玩 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclOEMlOUMlRTYlOTUlQjAlRTUlQUQlOTcvODMyMDA/ZnJvbXRpdGxlPUJ1bGxzK2FuZCtDb3dzJmFtcDtmcm9taWQ9MTIwMDM0ODgmYW1wO2ZyPWFsYWRkaW4=">猜数字（Bulls and Cows）</span>游戏，该游戏规则如下：</p><p>写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：</p><ul><li>猜测数字中有多少位属于数字和确切位置都猜对了（称为 “Bulls”，公牛），</li><li>有多少位属于数字猜对了但是位置不对（称为 “Cows”，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。</li></ul><p>给你一个秘密数字 <code>secret</code> 和朋友猜测的数字 <code>guess</code> ，请你返回对朋友这次猜测的提示。</p><p>提示的格式为 <code>&quot;xAyB&quot;</code> ， <code>x</code> 是公牛个数， <code>y</code> 是奶牛个数， <code>A</code> 表示公牛， <code>B</code> 表示奶牛。</p><p>请注意秘密数字和朋友猜测的数字都可能含有重复数字。</p><p><strong>示例 1：</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：secret <span class="punctuation">=</span> <span class="string">&quot;1807&quot;</span><span class="punctuation">,</span> guess <span class="punctuation">=</span> <span class="string">&quot;7810&quot;</span></span><br><span class="line">输出：<span class="string">&quot;1A3B&quot;</span></span><br><span class="line">解释：数字和位置都对（公牛）用 &#x27;|&#x27; 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。</span><br><span class="line"><span class="string">&quot;1807&quot;</span></span><br><span class="line">  <span class="string">|</span></span><br><span class="line"><span class="string">&quot;7810&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：secret = <span class="comment">&quot;1123&quot;</span>, guess = <span class="comment">&quot;0111&quot;</span></span><br><span class="line">输出：<span class="comment">&quot;1A1B&quot;</span></span><br><span class="line">解释：数字和位置都对（公牛）用 <span class="string">&#x27;|&#x27;</span> 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。</span><br><span class="line"><span class="comment">&quot;1123&quot;</span>        <span class="comment">&quot;1123&quot;</span></span><br><span class="line">  |      or     |</span><br><span class="line"><span class="comment">&quot;0111&quot;</span>        <span class="comment">&quot;0111&quot;</span></span><br><span class="line">注意，两个不匹配的 <span class="number">1</span> 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 <span class="number">1</span> 可以成为公牛数字。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= secret.length, guess.length &lt;= 1000</code></li><li><code>secret.length == guess.length</code></li><li><code>secret</code> 和 <code>guess</code> 仅由数字组成</li></ul><p>解法一：用字典进行保存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">getHint</span><span class="params">(string secret, string guess)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = secret.<span class="built_in">size</span>();</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; secret_map;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; guess_map;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(secret[i]==guess[i]) x++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">             secret_map[<span class="built_in">to_string</span>(secret[i])]++;  </span><br><span class="line">             guess_map[<span class="built_in">to_string</span>(guess[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[key,value]:secret_map)&#123;</span><br><span class="line">        <span class="keyword">if</span>(secret_map[key]&gt;guess_map[key])&#123;</span><br><span class="line">            y+=guess_map[key];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            y+=value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">to_string</span>(x) + <span class="string">&quot;A&quot;</span> + <span class="built_in">to_string</span>(y) + <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//string secret = &quot;1807&quot;, guess = &quot;7810&quot;;</span></span><br><span class="line">        string secret = <span class="string">&quot;1123&quot;</span>, guess = <span class="string">&quot;0111&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">getHint</span>(secret,guess) &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二：还是解法一的思路，但是优化了内存，并且直接使用数组进行保存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getHint</span><span class="params">(string secret, string guess)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义两个全零数组</span></span><br><span class="line">           <span class="type">int</span> m_a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;, m_b[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, n = secret.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//记录两个字符串中的数字分别出现的次数</span></span><br><span class="line">            m_a[secret[i] - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">            m_b[guess[i] - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">            <span class="comment">// 如果出现值和位置都对的，直接记录</span></span><br><span class="line">            <span class="keyword">if</span>(secret[i] == guess[i]) a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录一样的数字的次数的交集个数，然后减去位置相同的情况，就是值相同，而位置不同的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) b += <span class="built_in">min</span>(m_a[i], m_b[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(a) + <span class="string">&#x27;A&#x27;</span> + <span class="built_in">to_string</span>(b - a) + <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//     int A=0,B=0;</span></span><br><span class="line">    <span class="comment">//     set&lt;int&gt; flag;</span></span><br><span class="line">    <span class="comment">//  //先遍历一次，找到数字和位置都对的个数</span></span><br><span class="line">    <span class="comment">//   for(int i=0;i&lt;secret.length();i++)&#123;</span></span><br><span class="line">    <span class="comment">//       if(secret[i]==guess[i])&#123;</span></span><br><span class="line">    <span class="comment">//           A++;</span></span><br><span class="line">    <span class="comment">//           // 利用集合来记录数字和位置都对的下标位置</span></span><br><span class="line">    <span class="comment">//           flag.insert(i);</span></span><br><span class="line">    <span class="comment">//       &#125;</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">//   //定义一个multiset存储guess</span></span><br><span class="line">    <span class="comment">//   multiset&lt;char&gt; g;</span></span><br><span class="line">    <span class="comment">//   for(int i=0;i&lt;guess.length();i++)&#123;</span></span><br><span class="line">    <span class="comment">//       g.insert(guess[i]);</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//  //排除数字和位置都对的位置，对其他位置进行检索</span></span><br><span class="line">    <span class="comment">//  for(int i=0;i&lt;secret.length();i++)&#123;</span></span><br><span class="line">    <span class="comment">//      //如果当前位置已经对了，就跳过</span></span><br><span class="line">    <span class="comment">//      if((flag.find(i))!=flag.end())&#123;</span></span><br><span class="line">    <span class="comment">//          continue;</span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">//      if(g.find(secret[i])!=g.end())&#123;</span></span><br><span class="line">    <span class="comment">//          B++;</span></span><br><span class="line">    <span class="comment">//          g.earse(g.find(secret[i]),g.find(secret[i])+1);</span></span><br><span class="line">    <span class="comment">//      &#125;  </span></span><br><span class="line">    <span class="comment">//  &#125;</span></span><br><span class="line">    <span class="comment">//  return A+&quot;A&quot;+B+&quot;B&quot;;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2386-找出数组的第-k-大和"><a class="anchor" href="#2386-找出数组的第-k-大和">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1rLXN1bS1vZi1hbi1hcnJheS8=">2386. 找出数组的第 K 大和</span></h4><p>困难</p><p>给你一个整数数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。你可以选择数组的任一 <strong>子序列</strong> 并且对其全部元素求和。</p><p>数组的 <strong>第 k 大和</strong> 定义为：可以获得的第 <code>k</code> 个 <strong>最大</strong> 子序列和（子序列和允许出现重复）</p><p>返回数组的 <strong>第 k 大和</strong> 。</p><p>子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。</p><p>** 注意：** 空子序列的和视作 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,4,<span class="string">-2</span>], k = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：所有可能获得的子序列和列出如下，按递减顺序排列：</span><br><span class="line">- 6、4、4、2、2、0、0、<span class="string">-2</span></span><br><span class="line">数组的第 5 大和是 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,<span class="string">-2</span>,3,4,<span class="string">-10</span>,12], k = 16</span><br><span class="line">输出：10</span><br><span class="line">解释：数组的第 16 大和是 10 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>1 &lt;= k &lt;= min(2000, 2n)</code></li></ul><p>解法：优先队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果都是非负数的话</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span>  <span class="title">sum_k</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> length =nums.<span class="built_in">size</span>();</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;&gt;&gt; pq;</span><br><span class="line">    <span class="comment">//首先将（0,-1）加进去</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;nums[<span class="number">0</span>],<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;k; j++)&#123;</span><br><span class="line">        <span class="comment">// 取出当前堆顶</span></span><br><span class="line">        <span class="keyword">auto</span> [t,i] = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        res = t;</span><br><span class="line">        <span class="keyword">if</span>(i == length <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;t + nums[i<span class="number">+1</span>],i<span class="number">+1</span>&#125;);</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;t + nums[i<span class="number">+1</span>]-nums[i],i<span class="number">+1</span>&#125;);        </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">kSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> length =nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">long</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">             result += nums[i];</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             nums[i] = -nums[i];</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result - <span class="built_in">sum_k</span>(nums,k);</span><br><span class="line">       </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">-2</span>&#125;; </span><br><span class="line">    <span class="type">int</span> k = <span class="number">5</span> ;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">kSum</span>(nums,k) &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1553-吃掉-n-个橘子的最少天数"><a class="anchor" href="#1553-吃掉-n-个橘子的最少天数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLW51bWJlci1vZi1kYXlzLXRvLWVhdC1uLW9yYW5nZXMv">1553. 吃掉 N 个橘子的最少天数</span></h4><p>厨房里总共有 <code>n</code> 个橘子，你决定每一天选择如下方式之一吃这些橘子：</p><ul><li>吃掉一个橘子。</li><li>如果剩余橘子数 <code>n</code> 能被 2 整除，那么你可以吃掉 <code>n/2</code> 个橘子。</li><li>如果剩余橘子数 <code>n</code> 能被 3 整除，那么你可以吃掉 <code>2*(n/3)</code> 个橘子。</li></ul><p>每天你只能从以上 3 种方案中选择一种方案。</p><p>请你返回吃掉所有 <code>n</code> 个橘子的最少天数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：你总共有<span class="number"> 10 </span>个橘子。</span><br><span class="line">第<span class="number"> 1 </span>天：吃<span class="number"> 1 </span>个橘子，剩余橘子数<span class="number"> 10 </span>-<span class="number"> 1 </span>= 9。</span><br><span class="line">第<span class="number"> 2 </span>天：吃<span class="number"> 6 </span>个橘子，剩余橘子数<span class="number"> 9 </span>- 2*(9/3) =<span class="number"> 9 </span>-<span class="number"> 6 </span>= 3。（9 可以被<span class="number"> 3 </span>整除）</span><br><span class="line">第<span class="number"> 3 </span>天：吃<span class="number"> 2 </span>个橘子，剩余橘子数<span class="number"> 3 </span>- 2*(3/3) =<span class="number"> 3 </span>-<span class="number"> 2 </span>= 1。</span><br><span class="line">第<span class="number"> 4 </span>天：吃掉最后<span class="number"> 1 </span>个橘子，剩余橘子数<span class="number"> 1 </span>-<span class="number"> 1 </span>= 0。</span><br><span class="line">你需要至少<span class="number"> 4 </span>天吃掉<span class="number"> 10 </span>个橘子。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 6</span><br><span class="line">输出：3</span><br><span class="line">解释：你总共有<span class="number"> 6 </span>个橘子。</span><br><span class="line">第<span class="number"> 1 </span>天：吃<span class="number"> 3 </span>个橘子，剩余橘子数<span class="number"> 6 </span>- 6/2 =<span class="number"> 6 </span>-<span class="number"> 3 </span>= 3。（6 可以被<span class="number"> 2 </span>整除）</span><br><span class="line">第<span class="number"> 2 </span>天：吃<span class="number"> 2 </span>个橘子，剩余橘子数<span class="number"> 3 </span>- 2*(3/3) =<span class="number"> 3 </span>-<span class="number"> 2 </span>= 1。（3 可以被<span class="number"> 3 </span>整除）</span><br><span class="line">第<span class="number"> 3 </span>天：吃掉剩余<span class="number"> 1 </span>个橘子，剩余橘子数<span class="number"> 1 </span>-<span class="number"> 1 </span>= 0。</span><br><span class="line">你至少需要<span class="number"> 3 </span>天吃掉<span class="number"> 6 </span>个橘子。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n <span class="operator">=</span> <span class="number">56</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2*10^9</code></li></ul><p><img data-src="https://raw.githubusercontent.com/zhihao-a/blog-img/main/image-20240512201903900.png" alt="image-20240512201903900"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//   vector&lt;int&gt; dp(n+1,-1);</span></span><br><span class="line">   <span class="comment">//   function&lt;int(int)&gt; days = [&amp;](int num)-&gt;int&#123;</span></span><br><span class="line">   <span class="comment">//     if(num==0)&#123;</span></span><br><span class="line">   <span class="comment">//         return 0;</span></span><br><span class="line">   <span class="comment">//     &#125;</span></span><br><span class="line">   <span class="comment">//     if(dp[num]!=-1)&#123;</span></span><br><span class="line">   <span class="comment">//         return dp[num];</span></span><br><span class="line">   <span class="comment">//     &#125;</span></span><br><span class="line">   <span class="comment">//     int D = INT_MAX;</span></span><br><span class="line">   <span class="comment">//     dp[num-1] = days(num-1);</span></span><br><span class="line">   <span class="comment">//     D = min(D,1 + dp[num-1]);</span></span><br><span class="line">   <span class="comment">//     if(num%2 == 0)&#123;</span></span><br><span class="line">   <span class="comment">//         dp[num/2] = days(num/2);</span></span><br><span class="line">   <span class="comment">//         D = min(D,1 + dp[num/2]);</span></span><br><span class="line">   <span class="comment">//     &#125;</span></span><br><span class="line">   <span class="comment">//     if(num%3 == 0)&#123;</span></span><br><span class="line">   <span class="comment">//         dp[num/3] = days(num/3);</span></span><br><span class="line">   <span class="comment">//         D = min(D, 1 + dp[num/3]);</span></span><br><span class="line">   <span class="comment">//     &#125;</span></span><br><span class="line">   <span class="comment">//     dp[num] = D;</span></span><br><span class="line">   <span class="comment">//     return dp[num];</span></span><br><span class="line">   <span class="comment">//   &#125;;</span></span><br><span class="line">   <span class="comment">//   return days(n);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// vector&lt;int&gt; dp(n+1,INT_MAX);</span></span><br><span class="line">   <span class="comment">// dp[0] = 0;</span></span><br><span class="line">   <span class="comment">// dp[1] = 1;</span></span><br><span class="line">   <span class="comment">// for(int i = 2;i&lt;n+1;i++)&#123;</span></span><br><span class="line">   <span class="comment">//     dp[i] = min(dp[i] , dp[i-1] + 1);</span></span><br><span class="line">   <span class="comment">//     if(i%2==0)&#123;</span></span><br><span class="line">   <span class="comment">//         dp[i] = min(dp[i],dp[i/2] + 1);</span></span><br><span class="line">   <span class="comment">//     &#125;</span></span><br><span class="line">   <span class="comment">//     if(i%3==0)&#123;</span></span><br><span class="line">   <span class="comment">//         dp[i] = min(dp[i],dp[i/3] + 1);</span></span><br><span class="line">   <span class="comment">//     &#125;</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line">   <span class="comment">// return dp[n];</span></span><br><span class="line">   <span class="comment">//vector&lt;int&gt;  memo(n+1,-1);</span></span><br><span class="line">  <span class="comment">// 只有下面的这个可以通过</span></span><br><span class="line">   <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> n;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span>  <span class="built_in">min</span>(<span class="built_in">minDays</span>(n &gt;&gt; <span class="number">1</span>) + <span class="number">1</span> + (n &amp; <span class="number">1</span>), <span class="built_in">minDays</span>(n / <span class="number">3</span>) + <span class="number">1</span> + n % <span class="number">3</span>);</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="2589-完成所有任务的最少时间"><a class="anchor" href="#2589-完成所有任务的最少时间">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXRpbWUtdG8tY29tcGxldGUtYWxsLXRhc2tzLw==">2589. 完成所有任务的最少时间</span></h4><p>你有一台电脑，它可以 <strong>同时</strong> 运行无数个任务。给你一个二维整数数组 <code>tasks</code> ，其中 <code>tasks[i] = [starti, endi, durationi]</code> 表示第 <code>i</code> 个任务需要在 <strong>闭区间</strong> 时间段 <code>[starti, endi]</code> 内运行 <code>durationi</code> 个整数时间点（但不需要连续）。</p><p>当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。</p><p>请你返回完成所有任务的情况下，电脑最少需要运行多少秒。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = <span class="comment">[<span class="comment">[2,3,1]</span>,<span class="comment">[4,5,1]</span>,<span class="comment">[1,5,2]</span>]</span></span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 第一个任务在闭区间 <span class="comment">[2, 2]</span> 运行。</span><br><span class="line">- 第二个任务在闭区间 <span class="comment">[5, 5]</span> 运行。</span><br><span class="line">- 第三个任务在闭区间 <span class="comment">[2, 2]</span> 和 <span class="comment">[5, 5]</span> 运行。</span><br><span class="line">电脑总共运行 2 个整数时间点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = <span class="comment">[<span class="comment">[1,3,2]</span>,<span class="comment">[2,5,3]</span>,<span class="comment">[5,6,2]</span>]</span></span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">- 第一个任务在闭区间 <span class="comment">[2, 3]</span> 运行</span><br><span class="line">- 第二个任务在闭区间 <span class="comment">[2, 3]</span> 和 <span class="comment">[5, 5]</span> 运行。</span><br><span class="line">- 第三个任务在闭区间 <span class="comment">[5, 6]</span> 运行。</span><br><span class="line">电脑总共运行 4 个整数时间点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tasks.length &lt;= 2000</code></li><li><code>tasks[i].length == 3</code></li><li><code>1 &lt;= starti, endi &lt;= 2000</code></li><li><code>1 &lt;= durationi &lt;= endi - starti + 1</code></li></ul><p><strong>贪心思想</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinimumTime</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; tasks)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 首先，先根据任务的结束时间 end 从小到大进行排序</span></span><br><span class="line">   <span class="built_in">sort</span>(tasks.<span class="built_in">begin</span>(),tasks.<span class="built_in">end</span>(),[&amp;](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;t1,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;t2)-&gt;<span class="type">bool</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1[<span class="number">1</span>] &lt; t2[<span class="number">1</span>];</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="type">int</span> n = tasks.<span class="built_in">size</span>();</span><br><span class="line">   <span class="comment">// 排完序之后，用 run 数组去记录当前某一个时间点是否已经有任务在运行，该任务的目的就是尽可能的将</span></span><br><span class="line">   <span class="comment">// 新任务都安排在已经存在的任务点上面，根据一种贪心的思想去使得更多的任务点并行</span></span><br><span class="line">   <span class="function">vector&lt;<span class="type">int</span>&gt;  <span class="title">run</span><span class="params">(tasks[n<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>)</span></span>;</span><br><span class="line">   <span class="type">int</span> ressult = <span class="number">0</span> ;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">         <span class="comment">// 按照已经排好序的数组，从前到后依次取出每一个任务的信息</span></span><br><span class="line">         <span class="type">int</span> start = tasks[i][<span class="number">0</span>] ,end = tasks[i][<span class="number">1</span>] ,duration = tasks[i][<span class="number">2</span>];</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 查找 在该任务范围内已经存在的任务时间点数，然后将任务尽可能的安排在上面，得到剩下的任务数</span></span><br><span class="line">         duration -= <span class="built_in">accumulate</span>(run.<span class="built_in">begin</span>() + start ,run.<span class="built_in">begin</span>() + end  + <span class="number">1</span> ,<span class="number">0</span>);</span><br><span class="line">          </span><br><span class="line">         <span class="comment">// 将剩下的作为新增的时间点，加到最后的结果上</span></span><br><span class="line">         result += <span class="built_in">max</span>(duration,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 然后 将已经安排到之前已经存在的任务时间点上之后剩下的任务，从右到左安排在 该任务指定的时间点上面</span></span><br><span class="line">         <span class="comment">// 为啥要从左到右呢 ？ 就是为了更方便于后面的任务合并上来，尽可能的安排在更靠近下一个区间，导致后面的任务有更多的机会合并在已经存在的任务点上</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j = end;j&gt;=<span class="number">0</span> &amp;&amp; duration&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">// 要找此时没有分配任务的时间点，因为有任务的时间点，已经分配过了，单个时间段的任务是不可重叠的</span></span><br><span class="line">            <span class="keyword">if</span>(run[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                duration--;</span><br><span class="line">                run[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1542-找出最长的超赞子字符串"><a class="anchor" href="#1542-找出最长的超赞子字符串">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWxvbmdlc3QtYXdlc29tZS1zdWJzdHJpbmcv">1542. 找出最长的超赞子字符串</span></h4><p>给你一个字符串 <code>s</code> 。请返回 <code>s</code> 中最长的 <strong>超赞子字符串</strong> 的长度。</p><p>「超赞子字符串」需满足满足下述两个条件：</p><ul><li>该字符串是 <code>s</code> 的一个非空子字符串</li><li>进行任意次数的字符交换后，该字符串可以变成一个回文字符串</li></ul><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;3242415&quot;</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：<span class="string">&quot;24241&quot;</span> 是最长的超赞子字符串，交换其中的字符后，可以得到回文 <span class="string">&quot;24142&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;12345678&quot;</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;213123&quot;</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="string">&quot;213123&quot;</span> 是最长的超赞子字符串，交换其中的字符后，可以得到回文 <span class="string">&quot;231132&quot;</span></span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s <span class="operator">=</span> <span class="string">&quot;00&quot;</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 仅由数字组成</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestAwesome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; prefix = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sequence = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> digit = s[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 不断地更新 t[0,j] ，即状态压缩之后的代表[0,j]范围内0-9每一个数字出现的奇偶性 0-偶数，1-奇数</span></span><br><span class="line">            sequence ^= (<span class="number">1</span> &lt;&lt; digit);</span><br><span class="line">            <span class="comment">// 因为如果s[i,j]是一个可以经过任意交换后，形成回文子字符串，那么t[0,i-1](i&lt;j)和t[0,j]的至多会有一个二进制位不同</span></span><br><span class="line">            <span class="comment">// 因为如果这个s[i,j]满足回文性质的话，至多只有一个数字出现的次数为奇数，其他都是偶数，而根据前缀和的性质，s[i,j]</span></span><br><span class="line">            <span class="comment">// 中，某一个数字出现的次数，是s[0,j] - s[0,i-1] 所以s[i,j] 是偶数的情况只有两种 即，偶数-偶数 或者 奇数-奇数</span></span><br><span class="line">            <span class="comment">// 至多有一个相同，也可能相同 ，即s[i,j] 中都是出现偶数次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在这里就是寻找之前记录的状态 t[0,i] 中是否存在一样的，如果存在一样的，就说明存在一个 i(i&lt;j) 使得s[i+1,j] 满足条件 </span></span><br><span class="line">            <span class="keyword">if</span> (prefix.<span class="built_in">count</span>(sequence)) &#123;</span><br><span class="line">                <span class="comment">// 不断更新结果</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, j - prefix[sequence]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不存在的话，就记录当前的 t[0,j]</span></span><br><span class="line">                prefix[sequence] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历每一个数位，通过翻转各个位置，找到之前已经记录过的 i(i&lt;j) 与当前的状态 t[0,j] 是否存在一个位置不一样的情况</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prefix.<span class="built_in">count</span>(sequence ^ (<span class="number">1</span> &lt;&lt; k))) &#123;</span><br><span class="line">                    <span class="comment">// 如果存在的话，就更新此时的结果</span></span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, j - prefix[sequence ^ (<span class="number">1</span> &lt;&lt; k)]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3072-将元素分配到两个数组中-ii"><a class="anchor" href="#3072-将元素分配到两个数组中-ii">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXN0cmlidXRlLWVsZW1lbnRzLWludG8tdHdvLWFycmF5cy1paS8=">3072. 将元素分配到两个数组中 II</span></h4><p>给你一个下标从 <strong>1</strong> 开始、长度为 <code>n</code> 的整数数组 <code>nums</code> 。</p><p>现定义函数 <code>greaterCount</code> ，使得 <code>greaterCount(arr, val)</code> 返回数组 <code>arr</code> 中 <strong>严格大于</strong> <code>val</code> 的元素数量。</p><p>你需要使用 <code>n</code> 次操作，将 <code>nums</code> 的所有元素分配到两个数组 <code>arr1</code> 和 <code>arr2</code> 中。在第一次操作中，将 <code>nums[1]</code> 追加到 <code>arr1</code> 。在第二次操作中，将 <code>nums[2]</code> 追加到 <code>arr2</code> 。之后，在第 <code>i</code> 次操作中：</p><ul><li>如果 <code>greaterCount(arr1, nums[i]) &gt; greaterCount(arr2, nums[i])</code> ，将 <code>nums[i]</code> 追加到 <code>arr1</code> 。</li><li>如果 <code>greaterCount(arr1, nums[i]) &lt; greaterCount(arr2, nums[i])</code> ，将 <code>nums[i]</code> 追加到 <code>arr2</code> 。</li><li>如果 <code>greaterCount(arr1, nums[i]) == greaterCount(arr2, nums[i])</code> ，将 <code>nums[i]</code> 追加到元素数量较少的数组中。</li><li>如果仍然相等，那么将 <code>nums[i]</code> 追加到 <code>arr1</code> 。</li></ul><p>连接数组 <code>arr1</code> 和 <code>arr2</code> 形成数组 <code>result</code> 。例如，如果 <code>arr1 == [1,2,3]</code> 且 <code>arr2 == [4,5,6]</code> ，那么 <code>result = [1,2,3,4,5,6]</code> 。</p><p>返回整数数组 <code>result</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[2,1,3,3]</span></span><br><span class="line">输出：<span class="comment">[2,3,1,3]</span></span><br><span class="line">解释：在前两次操作后，arr1 = <span class="comment">[2]</span> ，arr2 = <span class="comment">[1]</span> 。</span><br><span class="line">在第 3 次操作中，两个数组中大于 3 的元素数量都是零，并且长度相等，因此，将 nums<span class="comment">[3]</span> 追加到 arr1 。</span><br><span class="line">在第 4 次操作中，两个数组中大于 3 的元素数量都是零，但 arr2 的长度较小，因此，将 nums<span class="comment">[4]</span> 追加到 arr2 。</span><br><span class="line">在 4 次操作后，arr1 = <span class="comment">[2,3]</span> ，arr2 = <span class="comment">[1,3]</span> 。</span><br><span class="line">因此，连接形成的数组 result 是 <span class="comment">[2,3,1,3]</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[5,14,3,1,2]</span></span><br><span class="line">输出：<span class="comment">[5,3,1,2,14]</span></span><br><span class="line">解释：在前两次操作后，arr1 = <span class="comment">[5]</span> ，arr2 = <span class="comment">[14]</span> 。</span><br><span class="line">在第 3 次操作中，两个数组中大于 3 的元素数量都是一，并且长度相等，因此，将 nums<span class="comment">[3]</span> 追加到 arr1 。</span><br><span class="line">在第 4 次操作中，arr1 中大于 1 的元素数量大于 arr2 中的数量（2 &gt; 1），因此，将 nums<span class="comment">[4]</span> 追加到 arr1 。</span><br><span class="line">在第 5 次操作中，arr1 中大于 2 的元素数量大于 arr2 中的数量（2 &gt; 1），因此，将 nums<span class="comment">[5]</span> 追加到 arr1 。</span><br><span class="line">在 5 次操作后，arr1 = <span class="comment">[5,3,1,2]</span> ，arr2 = <span class="comment">[14]</span> 。</span><br><span class="line">因此，连接形成的数组 result 是 <span class="comment">[5,3,1,2,14]</span> 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,3,3,3]</span></span><br><span class="line">输出：<span class="comment">[3,3,3,3]</span></span><br><span class="line">解释：在 4 次操作后，arr1 = <span class="comment">[3,3]</span> ，arr2 = <span class="comment">[3,3]</span> 。</span><br><span class="line">因此，连接形成的数组 result 是 <span class="comment">[3,3,3,3]</span> 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 109</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryIndexedTree</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BinaryIndexedTree</span>(<span class="type">int</span> n) : <span class="built_in">tree</span>(n + <span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; tree.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            tree[i] += <span class="number">1</span>;</span><br><span class="line">            i += i &amp; -i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res += tree[i];</span><br><span class="line">            i &amp;= i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">resultArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//    function&lt;int(vector&lt;int&gt; ,int)&gt; greaterCount = [&amp;](vector&lt;int&gt; vec,int val)-&gt;int&#123;</span></span><br><span class="line">    <span class="comment">//         int left = 0 ,right =  vec.size();</span></span><br><span class="line">    <span class="comment">//         int mid;</span></span><br><span class="line">    <span class="comment">//         while(left&lt;right)&#123;</span></span><br><span class="line">    <span class="comment">//             mid = (left + right)&gt;&gt;1;</span></span><br><span class="line">    <span class="comment">//             if(vec[mid]&gt;val)&#123;</span></span><br><span class="line">    <span class="comment">//                 right = mid;</span></span><br><span class="line">    <span class="comment">//             &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//                 left = mid + 1;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125; </span></span><br><span class="line">    <span class="comment">//         return left;</span></span><br><span class="line">    <span class="comment">//    &#125;;</span></span><br><span class="line">    <span class="comment">//    vector&lt;int&gt; arr1;</span></span><br><span class="line">    <span class="comment">//    vector&lt;int&gt; arr2;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    vector&lt;int&gt; arr1_seq;</span></span><br><span class="line">    <span class="comment">//    vector&lt;int&gt; arr2_seq;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    for(int i = 0;i&lt;nums.size();i++)&#123;</span></span><br><span class="line">    <span class="comment">//      if(i == 0)&#123;</span></span><br><span class="line">    <span class="comment">//          arr1.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//          arr1_seq.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//      &#125;else if(i==1)&#123;</span></span><br><span class="line">    <span class="comment">//         arr2.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//         arr2_seq.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//      &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//         int index1 = greaterCount(arr1_seq,nums[i]);</span></span><br><span class="line">    <span class="comment">//         int index2 = greaterCount(arr2_seq,nums[i]);</span></span><br><span class="line">    <span class="comment">//         if(arr1.size()-index1 &gt; arr2.size() - index2)&#123;</span></span><br><span class="line">    <span class="comment">//             arr1.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//             arr1_seq.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//             // 移到排好序的位置</span></span><br><span class="line">    <span class="comment">//             int k = arr1_seq.size()-1;</span></span><br><span class="line">    <span class="comment">//             while(k&gt;index1)&#123;</span></span><br><span class="line">    <span class="comment">//                 arr1_seq[k] = arr1_seq[k-1];</span></span><br><span class="line">    <span class="comment">//                 k--;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             arr1_seq[k] = nums[i];</span></span><br><span class="line">    <span class="comment">//         &#125;else if (arr1.size()-index1 &lt; arr2.size() - index2)&#123;</span></span><br><span class="line">    <span class="comment">//             arr2.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//             arr2_seq.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//             // 移到排好序的位置</span></span><br><span class="line">    <span class="comment">//             int k = arr2_seq.size()-1;</span></span><br><span class="line">    <span class="comment">//             while(k&gt;index2)&#123;</span></span><br><span class="line">    <span class="comment">//                 arr2_seq[k] = arr2_seq[k-1];</span></span><br><span class="line">    <span class="comment">//                 k--;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             arr2_seq[k] = nums[i];</span></span><br><span class="line">    <span class="comment">//         &#125;else&#123;</span></span><br><span class="line">    <span class="comment">//             if(arr1.size()&lt;=arr2.size())&#123;</span></span><br><span class="line">    <span class="comment">//                arr1.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//                arr1_seq.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//                // 移到排好序的位置</span></span><br><span class="line">    <span class="comment">//                int k = arr1_seq.size()-1;</span></span><br><span class="line">    <span class="comment">//                while(k&gt;index1)&#123;</span></span><br><span class="line">    <span class="comment">//                 arr1_seq[k] = arr1_seq[k-1];</span></span><br><span class="line">    <span class="comment">//                 k--;</span></span><br><span class="line">    <span class="comment">//                &#125;</span></span><br><span class="line">    <span class="comment">//                arr1_seq[k] = nums[i];</span></span><br><span class="line">    <span class="comment">//             &#125;else if(arr1.size()&gt;arr2.size())&#123;</span></span><br><span class="line">    <span class="comment">//                 arr2.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//                 arr2_seq.emplace_back(nums[i]);</span></span><br><span class="line">    <span class="comment">//                 // 移到排好序的位置</span></span><br><span class="line">    <span class="comment">//                 int k = arr2_seq.size()-1;</span></span><br><span class="line">    <span class="comment">//                 while(k&gt;index2)&#123;</span></span><br><span class="line">    <span class="comment">//                     arr2_seq[k] = arr2_seq[k-1];</span></span><br><span class="line">    <span class="comment">//                     k--;</span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//                 arr2_seq[k] = nums[i];</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    <span class="comment">//    &#125; </span></span><br><span class="line">    <span class="comment">//    for(auto &amp;t:arr1)&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; t &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//    &#125;cout &lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//    for(auto &amp;t:arr2)&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt;t &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//    &#125;cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//   arr1.insert(arr1.end(),arr2.begin(),arr2.end());</span></span><br><span class="line">    <span class="comment">//   return arr1;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sortedNums = nums;</span><br><span class="line">        <span class="built_in">sort</span>(sortedNums.<span class="built_in">begin</span>(), sortedNums.<span class="built_in">end</span>());</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            index[sortedNums[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr1 = &#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr2 = &#123;nums[<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="function">BinaryIndexedTree <span class="title">tree1</span><span class="params">(n)</span>, <span class="title">tree2</span><span class="params">(n)</span></span>;</span><br><span class="line">        tree<span class="number">1.</span><span class="built_in">add</span>(index[nums[<span class="number">0</span>]]);</span><br><span class="line">        tree<span class="number">2.</span><span class="built_in">add</span>(index[nums[<span class="number">1</span>]]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> count1 = arr<span class="number">1.</span><span class="built_in">size</span>() - tree<span class="number">1.</span><span class="built_in">get</span>(index[nums[i]]);</span><br><span class="line">            <span class="type">int</span> count2 = arr<span class="number">2.</span><span class="built_in">size</span>() - tree<span class="number">2.</span><span class="built_in">get</span>(index[nums[i]]);</span><br><span class="line">            <span class="keyword">if</span> (count1 &gt; count2 || (count1 == count2 &amp;&amp; arr<span class="number">1.</span><span class="built_in">size</span>() &lt;= arr<span class="number">2.</span><span class="built_in">size</span>())) &#123;</span><br><span class="line">                arr<span class="number">1.</span><span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                tree<span class="number">1.</span><span class="built_in">add</span>(index[nums[i]]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr<span class="number">2.</span><span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                tree<span class="number">2.</span><span class="built_in">add</span>(index[nums[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr<span class="number">1.</span><span class="built_in">insert</span>(arr<span class="number">1.</span><span class="built_in">end</span>(), arr<span class="number">2.</span><span class="built_in">begin</span>(), arr<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> arr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2813-子序列最大优雅度"><a class="anchor" href="#2813-子序列最大优雅度">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWVsZWdhbmNlLW9mLWEtay1sZW5ndGgtc3Vic2VxdWVuY2Uv">2813. 子序列最大优雅度</span></h4><p>给你一个长度为 <code>n</code> 的二维整数数组 <code>items</code> 和一个整数 <code>k</code> 。</p><p><code>items[i] = [profiti, categoryi]</code> ，其中 <code>profiti</code> 和 <code>categoryi</code> 分别表示第 <code>i</code> 个项目的利润和类别。</p><p>现定义 <code>items</code> 的 <strong>子序列</strong> 的 <strong>优雅度</strong> 可以用 <code>total_profit + distinct_categories2</code> 计算，其中 <code>total_profit</code> 是子序列中所有项目的利润总和， <code>distinct_categories</code> 是所选子序列所含的所有类别中不同类别的数量。</p><p>你的任务是从 <code>items</code> 所有长度为 <code>k</code> 的子序列中，找出 <strong>最大优雅度</strong> 。</p><p>用整数形式表示并返回 <code>items</code> 中所有长度恰好为 <code>k</code> 的子序列的最大优雅度。</p><p>** 注意：** 数组的子序列是经由原数组删除一些元素（可能不删除）而产生的新数组，且删除不改变其余元素相对顺序。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items = <span class="comment">[<span class="comment">[3,2]</span>,<span class="comment">[5,1]</span>,<span class="comment">[10,1]</span>]</span>, k = 2</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">在这个例子中，我们需要选出长度为 2 的子序列。</span><br><span class="line">其中一种方案是 items<span class="comment">[0]</span> = <span class="comment">[3,2]</span> 和 items<span class="comment">[2]</span> = <span class="comment">[10,1]</span> 。</span><br><span class="line">子序列的总利润为 3 + 10 = 13 ，子序列包含 2 种不同类别 <span class="comment">[2,1]</span> 。</span><br><span class="line">因此，优雅度为 13 + 22 = 17 ，可以证明 17 是可以获得的最大优雅度。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items = <span class="comment">[<span class="comment">[3,1]</span>,<span class="comment">[3,1]</span>,<span class="comment">[2,2]</span>,<span class="comment">[5,3]</span>]</span>, k = 3</span><br><span class="line">输出：19</span><br><span class="line">解释：</span><br><span class="line">在这个例子中，我们需要选出长度为 3 的子序列。 </span><br><span class="line">其中一种方案是 items<span class="comment">[0]</span> = <span class="comment">[3,1]</span> ，items<span class="comment">[2]</span> = <span class="comment">[2,2]</span> 和 items<span class="comment">[3]</span> = <span class="comment">[5,3]</span> 。</span><br><span class="line">子序列的总利润为 3 + 2 + 5 = 10 ，子序列包含 3 种不同类别 <span class="comment">[1, 2, 3]</span> 。 </span><br><span class="line">因此，优雅度为 10 + 32 = 19 ，可以证明 19 是可以获得的最大优雅度。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[1,1],[2,1],[3,1]], k = 3</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">在这个例子中，我们需要选出长度为<span class="number"> 3 </span>的子序列。</span><br><span class="line">我们需要选中所有项目。</span><br><span class="line">子序列的总利润为<span class="number"> 1 </span>+<span class="number"> 2 </span>+<span class="number"> 3 </span>= 6，子序列包含<span class="number"> 1 </span>种不同类别 [1] 。</span><br><span class="line">因此，最大优雅度为<span class="number"> 6 </span>+<span class="number"> 12 </span>=<span class="number"> 7 </span>。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= items.length == n &lt;= 105</code></li><li><code>items[i].length == 2</code></li><li><code>items[i][0] == profiti</code></li><li><code>items[i][1] == categoryi</code></li><li><code>1 &lt;= profiti &lt;= 109</code></li><li><code>1 &lt;= categoryi &lt;= n</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><p><img data-src="E:%5Ctypora%E5%9B%BE%E7%89%87%5Cimage-20240613120203217.png" alt="image-20240613120203217"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">findMaximumElegance</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; items, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 思路：就是先按照利润从大到小进行排序，之后选出利润最大的前 k 个 任务</span></span><br><span class="line">        <span class="comment">// 然后就是从后续任务中选择一个任务 ，替换前面的其中一个任务</span></span><br><span class="line">        <span class="comment">// 但是替换的情况只有一种能够让总体优雅度增大，因为利润总和肯定会减小，只有让类别总数更大，才有可能会让总体优雅度更大</span></span><br><span class="line">        <span class="comment">// 那么只有一种情况，就是被替换掉的类别在当前序列中出现过两次以上，并且将要替换的类别也不能在其中出现过，而且当前替换的话，不用回溯，因为之后替换肯定不会</span></span><br><span class="line">        <span class="comment">// 比当前替换形成的优雅度更大，因为依次替换的收益只有类别增大一，但是越早替换利益损失就会越小</span></span><br><span class="line">        <span class="comment">// 从前到后遍历，依次进行替换，找到优雅度最大的那一组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先，按照利益从大到小进行排序</span></span><br><span class="line">        <span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;item1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;item2) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> item1[<span class="number">0</span>] &gt; item2[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录出现过的类别，以供后续进行替换，或者记录出现次数的时候进行查询是否出现过当前类别</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; categorySet;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>, profit = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; items.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 前 k 个 任务，此时利益是最大的，剩下就是在增大类别总数（减小利益）的情况下</span></span><br><span class="line">            <span class="comment">//  看看能否提高优雅度</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line"></span><br><span class="line">                profit += items[i][<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// 如果没有之前没有出现过这个类别，那么直接记录出现过</span></span><br><span class="line">                <span class="keyword">if</span> (categorySet.<span class="built_in">count</span>(items[i][<span class="number">1</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    categorySet.<span class="built_in">insert</span>(items[i][<span class="number">1</span>]);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// 否则就认为是第二次以上出现，那么就将这个类别加入到多次出现的栈中</span></span><br><span class="line">                <span class="comment">// 以此来维护多次出现的类别，并且因为是从左到右遍历的，栈顶永远是利益较小的一个</span></span><br><span class="line">                <span class="comment">// 替换的时候就是秉承着利益损失最小的宗旨，拿着符合条件的任务中利益最小的那个进行替换</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(items[i][<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 前 k 个任务之后，开始按照制定的准则进行替换</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (categorySet.<span class="built_in">count</span>(items[i][<span class="number">1</span>]) == <span class="number">0</span> &amp;&amp; !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="comment">// 更新利益值</span></span><br><span class="line">                profit += items[i][<span class="number">0</span>] - st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 因为是新类别，所以就是直接加入进去就行了，因为每次替换都不可能替换已经存在的类别，</span></span><br><span class="line">                <span class="comment">// 这样不可能有任何收益</span></span><br><span class="line">                categorySet.<span class="built_in">insert</span>(items[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新当前结果，选择最大的</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, (<span class="type">long</span> <span class="type">long</span>)(profit + categorySet.<span class="built_in">size</span>() * categorySet.<span class="built_in">size</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2713-矩阵中严格递增的单元格数"><a class="anchor" href="#2713-矩阵中严格递增的单元格数">#</a> <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXN0cmljdGx5LWluY3JlYXNpbmctY2VsbHMtaW4tYS1tYXRyaXgv">2713. 矩阵中严格递增的单元格数</span></h4><p>给你一个下标从 <strong>1</strong> 开始、大小为 <code>m x n</code> 的整数矩阵 <code>mat</code> ，你可以选择任一单元格作为 <strong>起始单元格</strong> 。</p><p>从起始单元格出发，你可以移动到 <strong>同一行或同一列</strong> 中的任何其他单元格，但前提是目标单元格的值 <strong>严格大于</strong> 当前单元格的值。</p><p>你可以多次重复这一过程，从一个单元格移动到另一个单元格，直到无法再进行任何移动。</p><p>请你找出从某个单元开始访问矩阵所能访问的 <strong>单元格的最大数量</strong> 。</p><p>返回一个表示可访问单元格最大数量的整数。</p><p><strong>示例 1：</strong></p><p><strong><img data-src="https://assets.leetcode.com/uploads/2023/04/23/diag1drawio.png" alt="img"></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = <span class="string">[[3,1],[3,4]]</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：上图展示了从第 <span class="number">1</span> 行、第 <span class="number">2</span> 列的单元格开始，可以访问 <span class="number">2</span> 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 <span class="number">2</span> 个单元格，因此答案是 <span class="number">2</span> 。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong><img data-src="https://assets.leetcode.com/uploads/2023/04/23/diag3drawio.png" alt="img"></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = <span class="string">[[1,1],[1,1]]</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：由于目标单元格必须严格大于当前单元格，在本示例中只能访问 <span class="number">1</span> 个单元格。 </span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img data-src="https://assets.leetcode.com/uploads/2023/04/23/diag4drawio.png" alt="img"></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = <span class="string">[[3,1,6],[-9,5,7]]</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：上图展示了从第 <span class="number">2</span> 行、第 <span class="number">1</span> 列的单元格开始，可以访问 <span class="number">4</span> 个单元格。可以证明，无论从哪个单元格开始，最多只能访问 <span class="number">4</span> 个单元格，因此答案是 <span class="number">4</span> 。  </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>-105 &lt;= mat[i][j] &lt;= 105</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxIncreasingCells</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> m = mat.<span class="built_in">size</span>(), n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        map&lt;<span class="type">int</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; mp;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(m)</span>, <span class="title">col</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">// 首先，就是将数值按照顺序，从低到高进行归类整理，能够精确定位到每一个相同值的坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                mp[mat[i][j]].<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res; <span class="comment">// 存放相同数值的答案，便于后续更新 row 和 col</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[_, pos] : mp) &#123;</span><br><span class="line">            res.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[x, y] : pos) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">max</span>(row[x], col[y]) + <span class="number">1</span>);   <span class="comment">// 迭代公式，就是去选择行列中的最大的步数，然后加一</span></span><br><span class="line">                                                          </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pos.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;[x, y] = pos[i];</span><br><span class="line">                row[x] = <span class="built_in">max</span>(row[x], res[i]);  <span class="comment">// 更新这一行每一个位置中的最大的那个</span></span><br><span class="line">                col[y] = <span class="built_in">max</span>(col[y], res[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(row.<span class="built_in">begin</span>(), row.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="洛谷题解"><a class="anchor" href="#洛谷题解">#</a> 洛谷题解</h2><h4 id="p004-方格取数"><a class="anchor" href="#p004-方格取数">#</a> P004 方格取数</h4><h5 id="题目描述"><a class="anchor" href="#题目描述">#</a> 题目描述</h5><p>设有 N 的方格图 N≤9，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 0。如下图所示（见样例）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line"> 0  0  0  0  0  0  0  0</span><br><span class="line"> 0  0 13  0  0  6  0  0</span><br><span class="line"> 0  0  0  0  7  0  0  0</span><br><span class="line"> 0  0  0 14  0  0  0  0</span><br><span class="line"> 0 21  0  0  0  4  0  0</span><br><span class="line"> 0  0 15  0  0  0  0  0</span><br><span class="line"> 0 14  0  0  0  0  0  0</span><br><span class="line"> 0  0  0  0  0  0  0  0</span><br><span class="line">                         B</span><br></pre></td></tr></table></figure><p>某人从图的左上角的 A 点出发，可以向下行走，也可以向右走，直到到达右下角的 B 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 0）<br>此人从 A 点到 B 点共走两次，试找出 2 条这样的路径，使得取得的数之和为最大。</p><h5 id="输入格式"><a class="anchor" href="#输入格式">#</a> 输入格式</h5><p>输入的第一行为一个整数 N（表示 N 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 0 表示输入结束。</p><h5 id="输出格式"><a class="anchor" href="#输出格式">#</a> 输出格式</h5><p>只需输出一个整数，表示 22 条路径上取得的最大的和。</p><h5 id="输入输出样例"><a class="anchor" href="#输入输出样例">#</a> 输入输出样例</h5><h6 id="输入-1"><a class="anchor" href="#输入-1">#</a> <strong>输入 #1</strong></h6><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">13</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">6</span>  <span class="number">6</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span>  <span class="number">7</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">4</span> <span class="number">14</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">2</span> <span class="number">21</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">6</span>  <span class="number">4</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">3</span> <span class="number">15</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">2</span> <span class="number">14</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><h6 id="输出-1"><a class="anchor" href="#输出-1">#</a> <strong>输出 #1</strong></h6><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">67</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方格取数~深搜  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">int</span> N=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> s[<span class="number">15</span>][<span class="number">15</span>],f[<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> x2,<span class="type">int</span> y2)</span><span class="comment">//两种方案同时执行，表示当第一种方案走到x,y,第二种方案走到x2,y2时到终点取得的最大数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果这种情况已经被记录过了，直接返回，节省时间 </span></span><br><span class="line">    <span class="keyword">if</span> (f[x][y][x2][y2]!=<span class="number">-1</span>) <span class="keyword">return</span> f[x][y][x2][y2];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果两种方案都走到了终点，返回结束 </span></span><br><span class="line">    <span class="keyword">if</span> (x==N&amp;&amp;y==N&amp;&amp;x2==N&amp;&amp;y2==N) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> M=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果两种方案都不在最后一列，就都往下走，统计取得的数，如果有重复，就减去一部分 </span></span><br><span class="line">    <span class="keyword">if</span> (x&lt;N&amp;&amp;x2&lt;N) M=<span class="built_in">max</span>(M,<span class="built_in">dfs</span>(x<span class="number">+1</span>,y,x2<span class="number">+1</span>,y2)+s[x<span class="number">+1</span>][y]+s[x2<span class="number">+1</span>][y2]-s[x<span class="number">+1</span>][y]*(x<span class="number">+1</span>==x2<span class="number">+1</span>&amp;&amp;y==y2));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果第一种方案不在最后一行，第二种方案不在最后一列，第一种就向下走，第二种就向右走， </span></span><br><span class="line">    <span class="comment">//统计取得的数，如果有重复，就减去一部分</span></span><br><span class="line">    <span class="keyword">if</span> (x&lt;N&amp;&amp;y2&lt;N) M=<span class="built_in">max</span>(M,<span class="built_in">dfs</span>(x<span class="number">+1</span>,y,x2,y2<span class="number">+1</span>)+s[x<span class="number">+1</span>][y]+s[x2][y2<span class="number">+1</span>]-s[x<span class="number">+1</span>][y]*(x<span class="number">+1</span>==x2&amp;&amp;y==y2<span class="number">+1</span>));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果第一种方案不在最后一列，第二种方案不在最后一行，第一种就向右走，第二种就向下走， </span></span><br><span class="line">    <span class="comment">//统计取得的数，如果有重复，就减去一部分</span></span><br><span class="line">    <span class="keyword">if</span> (y&lt;N&amp;&amp;x2&lt;N) M=<span class="built_in">max</span>(M,<span class="built_in">dfs</span>(x,y<span class="number">+1</span>,x2<span class="number">+1</span>,y2)+s[x][y<span class="number">+1</span>]+s[x2<span class="number">+1</span>][y2]-s[x][y<span class="number">+1</span>]*(x==x2<span class="number">+1</span>&amp;&amp;y<span class="number">+1</span>==y2));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果第一种方案和第二种方案都不在最后一列，就都向右走，统计取得的数，如果有重复，就减去一部分</span></span><br><span class="line">    <span class="keyword">if</span> (y&lt;N&amp;&amp;y2&lt;N) M=<span class="built_in">max</span>(M,<span class="built_in">dfs</span>(x,y<span class="number">+1</span>,x2,y2<span class="number">+1</span>)+s[x][y<span class="number">+1</span>]+s[x2][y2<span class="number">+1</span>]-s[x][y<span class="number">+1</span>]*(x==x2&amp;&amp;y<span class="number">+1</span>==y2<span class="number">+1</span>));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对最后那个 s[x][y+1]*(x==x2&amp;&amp;y+1==y2+1))的解释：这个是用来判断两种方案是不是走到了同一格的</span></span><br><span class="line">    <span class="comment">//如果是真，就返回1，否则返回0，如果是1的话，理所当然的可以减去s[x][y+1]*1,否则减去s[x][y+1]*0相当于不减</span></span><br><span class="line">    <span class="comment">//记录这种情况 </span></span><br><span class="line">    </span><br><span class="line">    f[x][y][x2][y2]=M;</span><br><span class="line">   <span class="comment">//返回最大值 </span></span><br><span class="line">    <span class="keyword">return</span> M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="comment">//将记录数组初始化成-1，因为可能出现取的数为0的情况，如果直接判断f[x][y][x2][y2]!=0（见dfs第一行）</span></span><br><span class="line">    <span class="comment">//可能出现死循环而导致超时，细节问题 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;=N;a++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> b=<span class="number">0</span>;b&lt;=N;b++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>;c&lt;=N;c++)</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>;d&lt;=N;d++) f[a][b][c][d]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)<span class="comment">//读入 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t1=<span class="number">0</span>,t2=<span class="number">0</span>,t3=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;t1&gt;&gt;t2&gt;&gt;t3;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="number">0</span>&amp;&amp;t2==<span class="number">0</span>&amp;&amp;t3==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        s[t1][t2]=t3;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)+s[<span class="number">1</span>][<span class="number">1</span>];<span class="comment">//输出，因为dfs中没有考虑第一格，即s[1][1]，所以最后要加一下 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p1020导弹拦截"><a class="anchor" href="#p1020导弹拦截">#</a> P1020 导弹拦截</h4><h5 id="题目描述-2"><a class="anchor" href="#题目描述-2">#</a> 题目描述</h5><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</p><p>输入导弹依次飞来的高度（雷达给出的高度数据是 \le 50000≤50000 的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p><h5 id="输入格式-2"><a class="anchor" href="#输入格式-2">#</a> 输入格式</h5><p>11 行，若干个整数（个数 \le 100000≤100000）</p><p>NOIP 原题数据规模不超过 2000。</p><h5 id="输出格式-2"><a class="anchor" href="#输出格式-2">#</a> 输出格式</h5><p>22 行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。</p><h5 id="输入输出样例-2"><a class="anchor" href="#输入输出样例-2">#</a> 输入输出样例</h5><p><strong>输入 #1</strong> 复制</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">389 </span><span class="number">207</span> <span class="number">155</span> <span class="number">300</span> <span class="number">299</span> <span class="number">170</span> <span class="number">158</span> <span class="number">65</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong> 复制</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>这题是道线性的动态规划，可以双重循环，时间复杂度为 O (N²)。数据量为 n≤100000，那么这样做肯定超时。于是我就想用单重循环，可是没想出方法。因为这题要瞻前顾后，没有状态转移方程，单重循环肯定是搞不定的。</p><p>看下面的提示与说明，n 方 100 分，nlogn200 分。什么算法的时间复杂度是 logn 呢？我立刻想到了二分。</p><p>我们建立一个数组 dp，存放前 i 个导弹拦截最多时，所拦截的每个导弹的高度。例如样例中所给的 389 207 155 300 299 170 158 65，我们从第一个导弹开始。第一个是 389，把 389 存入数组 dp，即 dp [1]=389。定义变量 s 记录数组中数的个数。开始时 s=1，数组中只有 1 个数。</p><p>第二个是 207，用 207 与 389 比较，207≤389，可以拦截，所以将 207 存入数组。此时，数组中有 2 个数。</p><p>第三个是 155，用 155 与 207 比较，155≤207，可以拦截，故将 155 存入数组。此时，数组中有 3 个数。</p><p>第四个是 300，用 300 与 155 比较，300＞155，不能拦截。但我们不能确保拦截 155 而不拦截 300 是最优的，所以不能弃之。我们在 dp 数组中找，找到比它小的数中最大的那个，用 300 替换之。注意：在找的过程中，不能从 dp [1] 到 dp [s] 逐个去找，那样又变成双重循环，会超时。由于 dp 数组中的数是非升序排列，所以我们可以用二分。定义 l=1，r=s，每次找 dp [(l+r)/2]，与 300 比较。发现 207 是比它小的数中最大的一个，于是我们用 300 替换 207。</p><p>有人会问：“这样做可行吗？” 我们看，用 300 替换 207，相当于拦截完 389 后直接拦截 300。s 表示的含义不仅仅是数组中数的个数，更是拦截导弹的数量的最大值。每来一个导弹，我们都把它放在最优的位置。用 300 替换 207，表面上是替换，实际上是将 300 安排到最优的位置上。因为 207 现在已经没用了。一方面，300 比它大，新来的导弹接到 300 之后肯定优于接到 207 之后。另一方面，300-207-155 这个序列仍然存在，想要延续这个序列，我们只关心谁接到 155 之后，跟 207 没有关系了。</p><p>接下来是第五个数 299，299＞155，用二分查找。结果是用 299 替换 155。</p><p>第六个数是 170, 此时 dp 的最后一个数是 299，因为 155 被它换掉了。170≤299，所以 s++，将 170 存入数组。此时数组中有 4 个数。</p><p>接下来 158 和 65 存入数组，最终 s=6，故答案是 6。</p><p>部分代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">daodan</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">100001</span>] ;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">100000</span> ;</span><br><span class="line">	dp[<span class="number">1</span>] = a[<span class="number">1</span>] ;<span class="comment">//先将第一个数存入数组 </span></span><br><span class="line">	<span class="type">int</span> i, j, s=<span class="number">1</span>, l, r, mid, ans ;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;=dp[s])<span class="comment">//如果比它小，则直接存入 </span></span><br><span class="line">		&#123;</span><br><span class="line">		    s++ ;</span><br><span class="line">		    dp[s] = a[i] ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			l = <span class="number">0</span> ;</span><br><span class="line">			r = s ;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r)<span class="comment">//如果比它大，则进行二分 </span></span><br><span class="line">			&#123;</span><br><span class="line">				mid = (l+r)/<span class="number">2</span> ;</span><br><span class="line">				<span class="keyword">if</span>(dp[mid]&gt;=a[i])</span><br><span class="line">				&#123;</span><br><span class="line">					ans = mid ;</span><br><span class="line">					l = mid + <span class="number">1</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					r = mid - <span class="number">1</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			dp[ans<span class="number">+1</span>] = a[i] ;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再说第二问，拦截所有导弹需要多少次。</p><p>其实这问比第一问简单多了。如果你把第一问当成做第二问的基础，那就错了。第二问不需要知道每次如何拦截最优，只需要知道拦截多少次。</p><p>这就像一笔画问题，如果让你一笔画完成一个图案，你需要考虑怎么走。但如果给你一个一笔画完不成的图案，问你需要几笔走完，你只需要数奇点的个数就可以了。</p><p>这问的思路很简单，只要导弹能拦截，就拦截这个导弹。我们定义一个变量 b，记录已经拦截的导弹的数量。当 b==n 时循环结束。每次循环时，从第一个导弹逐个往后找，拦截过的做个标记，不找拦截过的。每找完一遍，ans++。整个循环结束后，输出 ans 就行了。</p><p>这样做可行的原因是，所有的导弹都要拦截，用哪个导弹拦截系统都是一样的，导弹拦截系统的数目不会变。</p><p>部分代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="number">0</span> ;</span><br><span class="line">ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span>(s&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">	maxs = <span class="number">100000</span> ;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;=maxs &amp;&amp; a[i]&gt;=<span class="number">0</span>)<span class="comment">//拦截过的不找</span></span><br><span class="line">		&#123;</span><br><span class="line">			s++ ;</span><br><span class="line">			maxs = a[i] ;</span><br><span class="line">			a[i] = <span class="number">-1</span> ;<span class="comment">//标记已经拦截过</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决本题的想法是优化时间复杂度。做第一问时，如果双重循环找，会做很多无用功。于是我们改进一下，用二分做，建立一个数组，存最优序列。做第二问时，不用考虑每次最优的拦截方法，只需记录次数。</p><p>完整的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">daodan</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">100001</span>] ;</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">100000</span> ;</span><br><span class="line">	dp[<span class="number">1</span>] = a[<span class="number">1</span>] ;</span><br><span class="line">	<span class="type">int</span> i, j, s=<span class="number">1</span>, l, r, mid, ans ;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;=dp[s])</span><br><span class="line">		&#123;</span><br><span class="line">			s++ ;</span><br><span class="line">			dp[s] = a[i] ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			l = <span class="number">0</span> ;</span><br><span class="line">			r = s ;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">			&#123;</span><br><span class="line">				mid = (l+r)/<span class="number">2</span> ;</span><br><span class="line">				<span class="keyword">if</span>(dp[mid]&gt;=a[i])</span><br><span class="line">				&#123;</span><br><span class="line">					ans = mid ;</span><br><span class="line">					l = mid + <span class="number">1</span> ;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					r = mid - <span class="number">1</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">			dp[ans<span class="number">+1</span>] = a[i] ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">1</span>, a[<span class="number">100001</span>], s=<span class="number">0</span>, i, maxs, ans=<span class="number">0</span> ;</span><br><span class="line">	<span class="type">char</span> c ;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; a[n])</span><br><span class="line">	    n++ ;</span><br><span class="line">	n-- ;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">daodan</span>(n,a) &lt;&lt; endl ;</span><br><span class="line">	<span class="keyword">while</span>(s&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		maxs = <span class="number">100000</span> ;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;=maxs &amp;&amp; a[i]&gt;=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				s++ ;</span><br><span class="line">				maxs = a[i] ;</span><br><span class="line">				a[i] = <span class="number">-1</span> ;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans++ ;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小程序</p><div class="tags"><a href="/tags/%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB/" rel="tag"><i class="ic i-tag"></i> 刷题汇总</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-10-14 19:20:31" itemprop="dateModified" datetime="2024-10-14T19:20:31+08:00">2024-10-14</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>氨基酸小童鞋 <i class="ic i-at"><em>@</em></i>氨基酸小童鞋的博客</li><li class="link"><strong>本文链接：</strong> <a href="https://zhihao-a.github.io/2023/12/17/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E5%8F%8A%E9%A2%98%E8%A7%A3%E6%B1%87%E6%80%BB/" title="算法训练及题解汇总">https://zhihao-a.github.io/2023/12/17/算法训练及题解汇总/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/12/17/%E7%AE%97%E6%B3%95%E5%8E%9F%E5%9E%8B/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2023&#x2F;12&#x2F;17&#x2F;50ba7546276faaee.jpg" title="算法原型"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>算法原型</h3></a></div><div class="item right"><a href="/2023/12/17/Pandas&Numpy/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s3.bmp.ovh&#x2F;imgs&#x2F;2023&#x2F;12&#x2F;17&#x2F;694c7ce95dcbdbb7.jpg" title="Pandas&amp;Numpy"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Pandas&Numpy</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#cowcode%E9%A2%98%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">cowcode 题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95"><span class="toc-number">1.1.</span> <span class="toc-text">简单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">二叉树前中后续遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nc78-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">NC78 反转链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%AD%89"><span class="toc-number">1.2.</span> <span class="toc-text">中等</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bm7-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">BM7 链表中环的入口结点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nc10-%E5%A4%A7%E6%95%B0%E4%B9%98%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">NC10 大数乘法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nc108-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-number">1.2.3.</span> <span class="toc-text">NC108 最大正方形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nc77-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%E4%B8%80"><span class="toc-number">1.2.4.</span> <span class="toc-text">NC77 调整数组顺序使奇数位于偶数前面 (一)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nc79-%E4%B8%91%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">NC79 丑数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%B0%E9%9A%BE"><span class="toc-number">1.3.</span> <span class="toc-text">困难</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nc6-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">1.3.1.</span> <span class="toc-text">NC6 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nc35-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E4%BA%8C"><span class="toc-number">1.3.2.</span> <span class="toc-text">NC35 编辑距离 (二)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nc36-%E5%9C%A8%E4%B8%A4%E4%B8%AA%E9%95%BF%E5%BA%A6%E7%9B%B8%E7%AD%89%E7%9A%84%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%8A%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">NC36 在两个长度相等的排序数组中找到上中位数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nc82-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">1.3.4.</span> <span class="toc-text">NC82 滑动窗口的最大值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#leetcode%E9%A2%98%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">Leetcode 题解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95-2"><span class="toc-number">2.1.</span> <span class="toc-text">简单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.1.</span> <span class="toc-text">27. 移除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">2.1.2.</span> <span class="toc-text">303. 区域和检索 - 数组不可变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">2.1.3.</span> <span class="toc-text">26. 删除有序数组中的重复项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number">2.1.4.</span> <span class="toc-text">455. 分发饼干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">2.1.5.</span> <span class="toc-text">121. 买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88"><span class="toc-number">2.1.6.</span> <span class="toc-text">705. 设计哈希集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2739-%E6%80%BB%E8%A1%8C%E9%A9%B6%E8%B7%9D%E7%A6%BB"><span class="toc-number">2.1.7.</span> <span class="toc-text">2739. 总行驶距离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2928-%E7%BB%99%E5%B0%8F%E6%9C%8B%E5%8F%8B%E4%BB%AC%E5%88%86%E7%B3%96%E6%9E%9C-i"><span class="toc-number">2.1.8.</span> <span class="toc-text">2928. 给小朋友们分糖果 I</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%AD%89-2"><span class="toc-number">2.2.</span> <span class="toc-text">中等</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2789-%E5%90%88%E5%B9%B6%E5%90%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.1.</span> <span class="toc-text">2789. 合并后数组中的最大元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2684-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%A7%BB%E5%8A%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AC%A1%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">2684. 矩阵中移动的最大次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91"><span class="toc-number">2.2.3.</span> <span class="toc-text">310. 最小高度树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii"><span class="toc-number">2.2.4.</span> <span class="toc-text">80. 删除有序数组中的重复项 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1969-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E9%9D%9E%E9%9B%B6%E4%B9%98%E7%A7%AF"><span class="toc-number">2.2.5.</span> <span class="toc-text">1969. 数组元素的最小非零乘积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.6.</span> <span class="toc-text">189. 轮转数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii"><span class="toc-number">2.2.7.</span> <span class="toc-text">122. 买卖股票的最佳时机 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii"><span class="toc-number">2.2.8.</span> <span class="toc-text">518. 零钱兑换 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#274-h-%E6%8C%87%E6%95%B0"><span class="toc-number">2.2.9.</span> <span class="toc-text">274. H 指数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-number">2.2.10.</span> <span class="toc-text">238. 除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2580-%E7%BB%9F%E8%AE%A1%E5%B0%86%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6%E6%88%90%E7%BB%84%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">2.2.11.</span> <span class="toc-text">2580. 统计将重叠区间合并成组的方案数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#380-o1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0"><span class="toc-number">2.2.12.</span> <span class="toc-text">380. O (1) 时间插入、删除和获取随机元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number">2.2.13.</span> <span class="toc-text">134. 加油站</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2952-%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F"><span class="toc-number">2.2.14.</span> <span class="toc-text">2952. 需要添加的硬币的最小数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#331-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.2.15.</span> <span class="toc-text">331. 验证二叉树的前序序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2192-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%89%80%E6%9C%89%E7%A5%96%E5%85%88"><span class="toc-number">2.2.16.</span> <span class="toc-text">2192. 有向无环图中一个节点的所有祖先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1026-%E8%8A%82%E7%82%B9%E4%B8%8E%E5%85%B6%E7%A5%96%E5%85%88%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC"><span class="toc-number">2.2.17.</span> <span class="toc-text">1026. 节点与其祖先之间的最大差值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1702-%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.18.</span> <span class="toc-text">1702. 修改后的最大二进制字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2007-%E4%BB%8E%E5%8F%8C%E5%80%8D%E6%95%B0%E7%BB%84%E4%B8%AD%E8%BF%98%E5%8E%9F%E5%8E%9F%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.19.</span> <span class="toc-text">2007. 从双倍数组中还原原数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">2.2.20.</span> <span class="toc-text">39. 组合总和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-iii"><span class="toc-number">2.2.21.</span> <span class="toc-text">216. 组合总和 III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF"><span class="toc-number">2.2.22.</span> <span class="toc-text">1052. 爱生气的书店老板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2385-%E6%84%9F%E6%9F%93%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9C%80%E8%A6%81%E7%9A%84%E6%80%BB%E6%97%B6%E9%97%B4"><span class="toc-number">2.2.23.</span> <span class="toc-text">2385. 感染二叉树需要的总时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90"><span class="toc-number">2.2.24.</span> <span class="toc-text">994. 腐烂的橘子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1953-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E6%95%B0"><span class="toc-number">2.2.25.</span> <span class="toc-text">1953. 你可以工作的最大周数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#826-%E5%AE%89%E6%8E%92%E5%B7%A5%E4%BD%9C%E4%BB%A5%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E6%94%B6%E7%9B%8A"><span class="toc-number">2.2.26.</span> <span class="toc-text">826. 安排工作以达到最大收益</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1535-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E6%B8%B8%E6%88%8F%E7%9A%84%E8%B5%A2%E5%AE%B6"><span class="toc-number">2.2.27.</span> <span class="toc-text">1535. 找出数组游戏的赢家</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2831-%E6%89%BE%E5%87%BA%E6%9C%80%E9%95%BF%E7%AD%89%E5%80%BC%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.28.</span> <span class="toc-text">2831. 找出最长等值子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1673-%E6%89%BE%E5%87%BA%E6%9C%80%E5%85%B7%E7%AB%9E%E4%BA%89%E5%8A%9B%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.2.29.</span> <span class="toc-text">1673. 找出最具竞争力的子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1738-%E6%89%BE%E5%87%BA%E7%AC%AC-k-%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%E5%9D%90%E6%A0%87%E5%80%BC"><span class="toc-number">2.2.30.</span> <span class="toc-text">1738. 找出第 K 大的异或坐标值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2028-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.31.</span> <span class="toc-text">2028. 找出缺失的观测数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2982-%E6%89%BE%E5%87%BA%E5%87%BA%E7%8E%B0%E8%87%B3%E5%B0%91%E4%B8%89%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-ii"><span class="toc-number">2.2.32.</span> <span class="toc-text">2982. 找出出现至少三次的最长特殊子字符串 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3067-%E5%9C%A8%E5%B8%A6%E6%9D%83%E6%A0%91%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%BB%9F%E8%AE%A1%E5%8F%AF%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E6%95%B0%E7%9B%AE"><span class="toc-number">2.2.33.</span> <span class="toc-text">3067. 在带权树网络中统计可连接服务器对数目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3040-%E7%9B%B8%E5%90%8C%E5%88%86%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9B%AE-ii"><span class="toc-number">2.2.34.</span> <span class="toc-text">3040. 相同分数的最大操作数目 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#312-%E6%88%B3%E6%B0%94%E7%90%83"><span class="toc-number">2.2.35.</span> <span class="toc-text">312. 戳气球</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2786-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%BD%BF%E5%88%86%E6%95%B0%E6%9C%80%E5%A4%A7"><span class="toc-number">2.2.36.</span> <span class="toc-text">2786. 访问数组中的位置使分数最大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2779-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%BE%8E%E4%B8%BD%E5%80%BC"><span class="toc-number">2.2.37.</span> <span class="toc-text">2779. 数组的最大美丽值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2288-%E4%BB%B7%E6%A0%BC%E5%87%8F%E5%85%8D"><span class="toc-number">2.2.38.</span> <span class="toc-text">2288. 价格减免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-ii"><span class="toc-number">2.2.39.</span> <span class="toc-text">503. 下一个更大元素 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2734-%E6%89%A7%E8%A1%8C%E5%AD%90%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.2.40.</span> <span class="toc-text">2734. 执行子串操作后的字典序最小字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%B0%E9%9A%BE-2"><span class="toc-number">2.3.</span> <span class="toc-text">困难</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1883-%E5%87%86%E6%97%B6%E6%8A%B5%E8%BE%BE%E4%BC%9A%E8%AE%AE%E7%8E%B0%E5%9C%BA%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%B3%E8%BF%87%E4%BC%91%E6%81%AF%E6%AC%A1%E6%95%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">1883. 准时抵达会议现场的最小跳过休息次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#924-%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD"><span class="toc-number">2.3.2.</span> <span class="toc-text">924. 尽量减少恶意软件的传播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#928-%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD-ii"><span class="toc-number">2.3.3.</span> <span class="toc-text">928. 尽量减少恶意软件的传播 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2009-%E4%BD%BF%E6%95%B0%E7%BB%84%E8%BF%9E%E7%BB%AD%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-number">2.3.4.</span> <span class="toc-text">2009. 使数组连续的最少操作数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">2.3.5.</span> <span class="toc-text">42. 接雨水</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">2.3.6.</span> <span class="toc-text">135. 分发糖果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2642-%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BB%A5%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9B%BE%E7%B1%BB"><span class="toc-number">2.3.7.</span> <span class="toc-text">2642. 设计可以求最短路径的图类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lcp-24-%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F"><span class="toc-number">2.3.8.</span> <span class="toc-text">LCP 24. 数字游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2617-%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%B0%91%E8%AE%BF%E9%97%AE%E7%9A%84%E6%A0%BC%E5%AD%90%E6%95%B0"><span class="toc-number">2.3.9.</span> <span class="toc-text">2617. 网格图中最少访问的格子数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0"><span class="toc-number">2.3.10.</span> <span class="toc-text">1793. 好子数组的最大分数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2312-%E5%8D%96%E6%9C%A8%E5%A4%B4%E5%9D%97"><span class="toc-number">2.3.11.</span> <span class="toc-text">2312. 卖木头块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#564-%E5%AF%BB%E6%89%BE%E6%9C%80%E8%BF%91%E7%9A%84%E5%9B%9E%E6%96%87%E6%95%B0"><span class="toc-number">2.3.12.</span> <span class="toc-text">564. 寻找最近的回文数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">2.3.13.</span> <span class="toc-text">3. 无重复字符的最长子串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">2.3.13.1.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2024-%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6"><span class="toc-number">2.3.14.</span> <span class="toc-text">2024. 考试的最大困扰度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1606-%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E6%9C%80%E5%A4%9A%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.3.15.</span> <span class="toc-text">1606. 找到处理最多请求的服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#728-%E8%87%AA%E9%99%A4%E6%95%B0"><span class="toc-number">2.3.16.</span> <span class="toc-text">728. 自除数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-number">2.3.17.</span> <span class="toc-text">307. 区域和检索 - 数组可修改</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E8%A7%A3"><span class="toc-number">2.3.17.1.</span> <span class="toc-text">题解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%B8%80%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">2.3.17.1.1.</span> <span class="toc-text">解法一：线段树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%88%86%E5%9D%97"><span class="toc-number">2.3.17.1.2.</span> <span class="toc-text">解法二：分块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">2.3.18.</span> <span class="toc-text">55. 跳跃游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">2.3.19.</span> <span class="toc-text">56. 合并区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4"><span class="toc-number">2.3.20.</span> <span class="toc-text">57. 插入区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-number">2.3.21.</span> <span class="toc-text">763. 划分字母区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii"><span class="toc-number">2.3.22.</span> <span class="toc-text">45. 跳跃游戏 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1306-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-iii"><span class="toc-number">2.3.23.</span> <span class="toc-text">1306. 跳跃游戏 III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91-2"><span class="toc-number">2.3.24.</span> <span class="toc-text">310. 最小高度树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#357-%E7%BB%9F%E8%AE%A1%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E9%83%BD%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0"><span class="toc-number">2.3.25.</span> <span class="toc-text">357. 统计各位数字都不同的数字个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#479-%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E6%95%B0%E4%B9%98%E7%A7%AF"><span class="toc-number">2.3.26.</span> <span class="toc-text">479. 最大回文数乘积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#386-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0"><span class="toc-number">2.3.27.</span> <span class="toc-text">386. 字典序排数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#821-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB"><span class="toc-number">2.3.28.</span> <span class="toc-text">821. 字符的最短距离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#388-%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">2.3.29.</span> <span class="toc-text">388. 文件的最长绝对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#396-%E6%97%8B%E8%BD%AC%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.30.</span> <span class="toc-text">396. 旋转函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%97-ii"><span class="toc-number">2.3.31.</span> <span class="toc-text">47. 全排列 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#587-%E5%AE%89%E8%A3%85%E6%A0%85%E6%A0%8F"><span class="toc-number">2.3.32.</span> <span class="toc-text">587. 安装栅栏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.33.</span> <span class="toc-text">560. 和为 K 的子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#417-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.34.</span> <span class="toc-text">417. 太平洋大西洋水流问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.3.35.</span> <span class="toc-text">96. 不同的二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#201-%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="toc-number">2.3.36.</span> <span class="toc-text">201. 数字范围按位与</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#909-%E8%9B%87%E6%A2%AF%E6%A3%8B"><span class="toc-number">2.3.37.</span> <span class="toc-text">909. 蛇梯棋</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#591-%E6%A0%87%E7%AD%BE%E9%AA%8C%E8%AF%81%E5%99%A8"><span class="toc-number">2.3.38.</span> <span class="toc-text">591. 标签验证器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.38.1.</span> <span class="toc-text">栈 + 字符串遍历</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#713-%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.39.</span> <span class="toc-text">713. 乘积小于 K 的子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-number">2.3.40.</span> <span class="toc-text">48. 旋转图像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii"><span class="toc-number">2.3.41.</span> <span class="toc-text">437. 路径总和 III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#691-%E8%B4%B4%E7%BA%B8%E6%8B%BC%E8%AF%8D"><span class="toc-number">2.3.42.</span> <span class="toc-text">691. 贴纸拼词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#812-%E6%9C%80%E5%A4%A7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF"><span class="toc-number">2.3.43.</span> <span class="toc-text">812. 最大三角形面积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#813-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E5%80%BC%E5%92%8C%E7%9A%84%E5%88%86%E7%BB%84"><span class="toc-number">2.3.44.</span> <span class="toc-text">813. 最大平均值和的分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#668-%E4%B9%98%E6%B3%95%E8%A1%A8%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">2.3.45.</span> <span class="toc-text">668. 乘法表中第 k 小的数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#464-%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97"><span class="toc-number">2.3.46.</span> <span class="toc-text">464. 我能赢吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#675-%E4%B8%BA%E9%AB%98%E5%B0%94%E5%A4%AB%E6%AF%94%E8%B5%9B%E7%A0%8D%E6%A0%91"><span class="toc-number">2.3.47.</span> <span class="toc-text">675. 为高尔夫比赛砍树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1022-%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">2.3.48.</span> <span class="toc-text">1022. 从根到叶的二进制数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%91%E6%8C%87-offer-ii-114-%E5%A4%96%E6%98%9F%E6%96%87%E5%AD%97%E5%85%B8"><span class="toc-number">2.3.49.</span> <span class="toc-text">剑指 Offer II 114. 外星文字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">2.3.50.</span> <span class="toc-text">450. 删除二叉搜索树中的节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#875-%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82"><span class="toc-number">2.3.51.</span> <span class="toc-text">875. 爱吃香蕉的珂珂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#926-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC%E5%88%B0%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E"><span class="toc-number">2.3.52.</span> <span class="toc-text">926. 将字符串翻转到单调递增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.53.</span> <span class="toc-text">498. 对角线遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2368-%E5%8F%97%E9%99%90%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">2.3.54.</span> <span class="toc-text">2368. 受限条件下可到达节点的数目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2575-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8F%AF%E6%95%B4%E9%99%A4%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.55.</span> <span class="toc-text">2575. 找出字符串的可整除数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2834-%E6%89%BE%E5%87%BA%E7%BE%8E%E4%B8%BD%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%92%8C"><span class="toc-number">2.3.56.</span> <span class="toc-text">2834. 找出美丽数组的最小和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#299-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F"><span class="toc-number">2.3.57.</span> <span class="toc-text">299. 猜数字游戏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%AC-k-%E5%A4%A7%E5%92%8C"><span class="toc-number">2.3.58.</span> <span class="toc-text">2386. 找出数组的第 K 大和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1553-%E5%90%83%E6%8E%89-n-%E4%B8%AA%E6%A9%98%E5%AD%90%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0"><span class="toc-number">2.3.59.</span> <span class="toc-text">1553. 吃掉 N 个橘子的最少天数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2589-%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4"><span class="toc-number">2.3.60.</span> <span class="toc-text">2589. 完成所有任务的最少时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1542-%E6%89%BE%E5%87%BA%E6%9C%80%E9%95%BF%E7%9A%84%E8%B6%85%E8%B5%9E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.3.61.</span> <span class="toc-text">1542. 找出最长的超赞子字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3072-%E5%B0%86%E5%85%83%E7%B4%A0%E5%88%86%E9%85%8D%E5%88%B0%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD-ii"><span class="toc-number">2.3.62.</span> <span class="toc-text">3072. 将元素分配到两个数组中 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2813-%E5%AD%90%E5%BA%8F%E5%88%97%E6%9C%80%E5%A4%A7%E4%BC%98%E9%9B%85%E5%BA%A6"><span class="toc-number">2.3.63.</span> <span class="toc-text">2813. 子序列最大优雅度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2713-%E7%9F%A9%E9%98%B5%E4%B8%AD%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC%E6%95%B0"><span class="toc-number">2.3.64.</span> <span class="toc-text">2713. 矩阵中严格递增的单元格数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%9B%E8%B0%B7%E9%A2%98%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">洛谷题解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#p004-%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0"><span class="toc-number">3.0.1.</span> <span class="toc-text">P004 方格取数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.0.1.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.0.1.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B"><span class="toc-number">3.0.1.4.</span> <span class="toc-text">输入输出样例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-1"><span class="toc-number">3.0.1.4.1.</span> <span class="toc-text">输入 #1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-1"><span class="toc-number">3.0.1.4.2.</span> <span class="toc-text">输出 #1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#p1020%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA"><span class="toc-number">3.0.2.</span> <span class="toc-text">P1020 导弹拦截</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">3.0.2.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">3.0.2.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-2"><span class="toc-number">3.0.2.4.</span> <span class="toc-text">输入输出样例</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="氨基酸小童鞋" data-src="/images/avatar.jpg"><p class="name" itemprop="name">氨基酸小童鞋</p><div class="description" itemprop="description">氨基酸小童鞋的博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">15</span> <span class="name">文章</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly96aGloYW8tYS5naXRodWIuY29tLw==" title="https:&#x2F;&#x2F;zhihao-a.github.com&#x2F;"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>文章</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/12/17/%E7%AE%97%E6%B3%95%E5%8E%9F%E5%9E%8B/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/12/17/Pandas&Numpy/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2023/12/17/Linux%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/" title="My First Post">My First Post</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/12/17/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E5%8F%8A%E9%A2%98%E8%A7%A3%E6%B1%87%E6%80%BB/" title="算法训练及题解汇总">算法训练及题解汇总</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/12/17/javaWeb%E5%85%A8%E6%A0%88/" title="javaWeb全栈">javaWeb全栈</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/03/21/git%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/" title="git配置相关">git配置相关</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/12/10/My%20First%20Blog/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/12/17/Pandas&Numpy/" title="Pandas&amp;Numpy">Pandas&Numpy</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/12/09/MyBatis-Plus/" title="mybatis-plus">mybatis-plus</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/05/21/bug%E6%B1%87%E6%80%BB/" title="bug汇总">bug汇总</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/03/02/Domain-adversarial-neural-networks-for-domain-generalizationwhen-it-works-and-how-to-improve/" title="Domain adversarial neural networks for domain generalizationwhen it works and how to improve">Domain adversarial neural networks for domain generalizationwhen it works and how to improve</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/12/17/%E7%AE%97%E6%B3%95%E5%8E%9F%E5%9E%8B/" title="算法原型">算法原型</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-garden hamster"></i> </span><span class="author" itemprop="copyrightHolder">氨基酸小童鞋 @ 氨基酸小童鞋</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">416k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">6:18</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/12/17/算法训练及题解汇总/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>